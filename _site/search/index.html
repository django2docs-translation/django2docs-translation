<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Imformal refs</title>
  <meta name="description" content="Imformal django references translation to korean, this project starts from Gangju, South, Korea. GIST college. 
">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/search/">
  <link rel="alternate" type="application/rss+xml" title="Imformal refs" href="http://localhost:4000/feed.xml">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.0/css/all.css" integrity="sha384-lZN37f5QGtY3VHgisS14W3ExzMWZxybE1SJSEsQp9S+oqd12jhcu+A56Ebc1zFSJ" crossorigin="anonymous">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+KR:300,400&amp;subset=korean" rel="stylesheet">
</head>


  <body>
    <header class="site-master-header">
    <div class="site-master-title">
        <i class="fab fa-python" id="master-header-icon"></i>
        <a class="site-title" href="/">Imformal refs</a>
        <div class="langbox">       
   
            
        </div>

    </div>
</header>
      
    <header class="site-header" id="becomesticky">
    <script>


        document.onscroll = function() {becomingsticky()};

        var navbar = document.getElementById("becomesticky");
        var navbarsticky = navbar.offsetTop;

        function becomingsticky() {
          if (window.pageYOffset >= navbarsticky) {
            navbar.classList.add("sticky");
          }else{
            navbar.classList.remove("sticky");
          }
        }
    </script>

  <div class="wrapper">

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about">about</a>
          
        
          
          <a class="page-link" href="/authors">authors</a>
          
        
          
          <a class="page-link" href="/documents">documents</a>
          
        
          
          <a class="page-link" href="/search/">Search</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <form action="/search/" method="get" id="search-form">
  <label for="search-box" id="search-label">Search</label>
  <input type="text" id="search-box" name="query" />
</form>

<ul id="search-results"></ul>

<script>
  window.store = {
    
    
    
      "2019-02-01-field-types-html": {
        "title": "Field Types",
        "date": "Feb 1, 2019",
        "author": "김선규(Kim,seon-kyu)",
        "category": "",
        "content": "  원본 링크: https://docs.djangoproject.com/en/2.1/ref/models/fields/이 문서는 장고가 제공하는 모든 field options과 field types을 포함한 Field에 대해 설명하고 있습니다.See also만약 내장된 field가 작동하지 않으면 django-localflavor(documentation)를 시도해 보십시오. 이는 특별한 국가와 문화에 대해서 갖가지 유용한 code의 조각을 가지고 있습니다.또한 당신은 쉽게 당신만의 custom model fields를 만들 수 있습니다.Note기술적으로, 이런 모델들은 django.db.models.fields에 저장되어 있으나 편리함을 위해 그들은 django.db.models안에 imported 되어있습니다. 기본적인 명명 관습은 from django.go import models를 사용하는 것이며, fields는 **models.Field**로 나타나는 것입니다.Field options아래의 arguments는 모두 field의 타입들입니다. 모든 것은 선택적입니다.  Field options는 Field type안에 포함되는 설정입니다. 예시: name = CharField(max_length=150, null=False). null은 field option이고, max_length는 필수 arguement입니다nullField.null만약 True라면, 장고는 데이터 베이스에 비어 있는 값으로 NULL을 저장할 것입니다. 기본적으로 False로 설정 되어있습니다.CharField 와 TextField와 같은 문자열 기반 field의 경우는 null의 사용을 피하는 것이 좋습니다. 문자열을 저장하는 field에 null=True 라면, 데이터가 없을 경우 field에는 NULL과 빈 문자열 두 값이 모두 저장될 수 있습니다. 같은 값에 대해 두 가지 가능한 값을 갖는 것은 지양해야 합니다. 장고의 관습은 빈 문자열을 저장하는 것입니다.한 가지 예외는 CharField가 unique=True와 blank=True를 전부 가지고 있는 때입니다. 이는 복수의 객체에서 blank value를 저장할 때 unique 조건에 위배되는 것을 피하기 위함입니다. (NULL은 여러 개 가질 수 있고, 빈 문자열은 하나의 값으로 인식되어 unique 때문에 하나만 가질 수 있는 것 같습니다.)string-based 와 non-string-based field 에서 forms에 빈값을 넣는 것을 원한다면 blank=True로 설정해 주어야 합니다. null 값은 단지 database storage에 영향을 미치기 때문입니다(blank를 보십시오).NoteOracle database backend를 사용할 때, NULL은 이 attribute와 상관없이 빈 값을 나타내는 것으로 저장될 것입니다.blankField.blank만약 True 라면 field는 blank를 허용합니다. 기본적으로 Flase입니다.null은 순수하게 database-related 인 반면에 blank는 validation-related 입니다. 만약 field가 blank=True를 가진다면 form validation은 empty value의 입력을 허용 해줄 것입니다. 만약 field가 blank=False 라면 field는 반드시 채워져야 합니다choicesField.choicesfield에 choices로 사용하기 위해서는 두 items의 iterables 이거나 이를 포함하고 있는 iterable이어야 합니다(e.g. [(A, B), (A, B), …]). 만약 choice가 주어진다면, 그들은 model validation에 의해 실행되고, text field가 아닌, select box에 선택지가 담긴 기본 위젯 form이 실행 될 것입니다.각 튜플에서 첫번째 요소는 model에 저장되는 실질적 값이고, 두 번째 요소(element)는 사람이 읽게 되는 이름입니다. 예시:YEAR_IN_SCHOOL_CHOICES = (        ('FR', 'Freshman'),        ('SO', 'Sophomore'),        ('JR', 'Junior'),        ('SR', 'Senior'),    )일반적으로 model class 안에 choices를 각 값에 대해서 변함 없게 알맞은 이름을 정의하는 가장 좋은 방법은 다음과 같습니다.from django.db import models    class Student(models.Model):    FRESHMAN = 'FR'    SOPHOMORE = 'SO'    JUNIOR = 'JR'    SENIOR = 'SR'    YEAR_IN_SCHOOL_CHOICES = (        (FRESHMAN, 'Freshman'),        (SOPHOMORE, 'Sophomore'),        (JUNIOR, 'Junior'),        (SENIOR, 'Senior'),    )    year_in_school = models.CharField(        max_length=2,        choices=YEAR_IN_SCHOOL_CHOICES,        default=FRESHMAN,    )        def is_upperclass(self):        return self.year_in_school in (self.JUNIOR, self.SENIOR)choices list를 model class의 외부에 정의하여 참조하게 할 수 있지만, model class 내부에 각 choice를 정의하는 것은 이것을 사용한 class에 모든 정보를 보관할 수 있다는 장점이 있습니다. 그리고 choices를 쉽게 참조 할 수 있게 합니다.(e.g. Student 모델이 import 된 어느 곳에서라도 Student.SOPHOMORE이 작동할 것입니다)사용 가능한 choices를 체계화 하기 위한 목적으로 그룹에 이름을 지을 수 있습니다.MEDIA_CHOICES = (    ('Audio', (            ('vinyl', 'Vinyl'),            ('cd', 'CD'),        )    ),    ('Video', (            ('vhs', 'VHS Tape'),            ('dvd', 'DVD'),        )    ),    ('unknown', 'Unknown'),)각 tuple의 첫 번째 요소는 그룹을 나타낼 이름입니다. 두 번째 요소는 두 값의 iterable로, 저장되는 값과 사람이 읽을 수 있는 값으로 묶여진 tuple입니다. 하나의 list를 사용하여 그룹화 된 선택지들과 그룹화 되지 않은 선택지들을 합칠 수 있습니다.(예를 들면, 위에서의 unknown option들은 그룹화 되지 않은 선택지입니다)choices 을 가진 model field 별로, field의 현재 값에 대응되는 사람에게 보여지는 이름을 받아오는 method를 추가합니다. 더 자세한 것은 database API documentation 안에 있는 get_FOO_display()를 참고하십시오.choices는 그 어떤 iterable object로도 받을 수 있다는 것을 기억하십시오. 굳이 list나 tuple 로 구성할 필요가 없습니다. 이것은 choices를 dynamically하게 만들 수 있다는 의미입니다. 어쩌면 choices를 dynamic 하게 만들 방법을 찾아낼 수도 있지만, 아마 적절한 데이터베이스 테이블을 foreignkey와 함께 사용하는 것이 더 좋을 것입니다. choices는 어차피 크게 바꾸지 않을 정적 데이터이기 때문입니다.default로 blank=False가 field에 설정되지 않는 이상 select box label에는 “——————————”가 담겨 제공될 것이다. 이를 override 하기 위해서는 None을 가진 choices tuple을 추가하십시오; e.g. (None, ‘Your String For Dispay’). 대안으로 예를 들어 CharField와 같이 적절한 곳에서는 empty string 대신 None을 자주 쓸 것입니다.db_columField.db_columnfield에 사용할 database column의 이름입니다. 만약 주어지지 않았다면, 장고는 field의 이름을 사용할 것이다.만약 database column name 이 SQL reserved word, 또는 파이썬 변수이름에서는 사용할 수 없는 문자열을 포함하고 있어도 - 예를 들어 하이픈 - 장고에서는 사용할 수 있습니다. Django quotes column and table names behind the scenes.db_indexField.db_index만약 True 이면 이 field를 위해 database index가 생성될 것입니다.db_tablespacesField.db_tablespace만약 field가 indexed 되어 있다면, 필드의 index에 대해 사용할 database tablespace의 이름입니다. 기본 값은 프로젝트의 DEFAULT_INDEX_TABLESPACE 설정, 또는 모델의 db_tablespace(설정된 경우)입니다. 만약 backend가 tablespace를 지원하지 않는다면 이 옵션은 무시될 것입니다.defaultField.default필드에 대한 기본 값입니다. 이는 한 값이나 callable 객체가 될 수도 있습니다. 만약 callable 객체라면 새로운 객체가 생성될 때마다 호출될 것입니다.default는 변경 가능한 객체(model instance, list, set 등)일 수 없으며, 이 객체의 동일한 인스턴스에 대한 참조는 모든 새로운 모델 인스턴스에서 기본 값으로 사용될 것입니다. 대신에, callable로 원하는 default를 wrap할 수 있습니다. 예를 들어, JSONField에 대해 default dict을 명시하고 싶다면, 다음 함수를 사용하십시오:def contact_default():    return {\"email\": \"to1@example.com\"}    contact_info = FSONField(\"ContactInfo\", default=contact_default)default와 같은 field option으로 lamda는 사용할 수 없습니다. 왜냐하면 이들은 Migrations로 serialized되지 않기 때문입니다. 해당 설명서를 참고하십시오.모델 인스턴스로 매핑하는 ForeignKey와 같은 필드에 대해서는, default는 모델 인스턴스 대신 그들이 참조하는 필드 값(to_field가 설정되지 않은 경우 pk)이어야 합니다.  default 값을 모델을 설정하지 말고, 해당 모델의 primary key인 field로 설정해야 한다는 뜻 같습니다.default(기본 값)은 새로운 모델 인스턴스가 생기고, 해당 필드에 대해 값이 주어지지 않을 경우 사용됩니다. 필드가 primary key일 경우, 필드가 None으로 설정되어 있어도 default를 사용합니다.editableField.editable만약 False라면, 이 field는 admin이나 ModelForm에서 표시되지 않을 것입니다. 또한 model validation을 생략할 것입니다. 기본적으로 True입니다.error_messagesFields.error_messageserror_messages arguments는 이 field에서 에러가 발생할 때의 기본 메세지를 override합니다. override하고 싶은 에러에 대한 메세지를 dictionary로 넘겨주십시오.에러 메세지의 key는 null, blank, invalid, invalid_choice, unique, 그리고 unique_for_date를 포함합니다. 추가적인 error message의 key들은 Field types 섹션에 각각의 필드에 명시돼 있습니다.에러 메세지들은 종종 form으로 전달되지 않습니다. 모델의 error_messages에 대해 고려해야 할 사항에 대한 문서를 참조하십시오.help_textField.help_text폼 위젯(form widget)에 표시될 추가적인 도움말입니다. 만약 폼에서 해당 필드를 사용하지 않는다 하더라도 설명하기에 유용합니다.이 값은 자동으로 생성된 폼에서 HTML을 help_text에 원하는 대로 포함할 수 있게 해줍니다. 다음은 예시입니다:help_text=\"Please use the following format: &lt;em&gt;YYYY-MM-DD&lt;/em&gt;.\"일반 텍스트와 django.utils.html.escape()를 사용하여 HTML 특수 문자를 사용하지 않을 수 있습니다. cross-site scripting attack를 피하기 위해서 신뢰할 수 없는 사용자로부터 온 help text를 확실히 escape 해야 합니다.primary_keyField.primary_keyTrue라면, 이 필드는 해당 모델에 primary key입니다.어떤 모델에도 primary_key=Ture를 설정하지 않았다면, 장고는 자동으로 primary key 역할을 할 AutoField를 추가할 것입니다. 따라서 기본 primary-key behavior을 override하지 않는 이상, primary_key=Ture을 명시할 필요가 없습니다. 자세한 사항은 Automatic primary key fields를 보십시오.primary_key=True는 null=False와 unique=True를 암시합니다. 한 객체에 대해서는 하나의 Primary key만 허용됩니다.primary key 필드는 읽을 수만 있습니다. 만약 존재하는 객체의 primary key 값을 변경하고 저장한다면, 새로운 객체가 옛날 것 옆에 만들어질 것입니다.uniqueField.uniqueTrue라면, 이 필드는 테이블 전체에 걸쳐 고유해야 합니다.이는 데이터베이스 레벨에서, model validation에 의해 시행됩니다. 만약 unique 필드에 중복된 값의 객체를 저장하려 한다면, django.db.IntegrityError가 모델의 save() method에 의해 발생할 것입니다.이 옵션은 ManyToManyField와 OneToOneField를 제외하고 모든 필드에서 사용할 수 있습니다.unique가 True일 때, db_index를 명시할 필요가 없습니다. 왜냐하면 unique는 index의 생성을 의미합니다.unique_for_dateField.unique_for_date이 필드가 date field 값에 대해 unique하게 하기 위해서 DateField or DateTimeField의 이름으로 이 값을 설정하십시오.예를 들어, unique_for_date=”pub_date”를 갖고 있는 title field를 갖고 있다고 가정하면, 장고는 title과 pub_date를 동시에 갖고 있는 레코드의 입력을 허락하지 않을 것입니다.  pub_date = models.DateField( … )  title = models.CharField( … , unique_for_date=”pub_date”)이 설정을 DateTimeField를 가리키도록 설정하면, 오직 필드의 날짜 부분만 고려된다는 점을 주의하십시오. 게다가 USE_TZ가 True라면, 객체가 저장될 때 현재 시간대에서 점검(check)이 수행될 것입니다.이는 Model.validate_unique()에 의해 수행되는데, model validation 동안 시행되지만 데이터베이스 레벨에서는 시행되지 않습니다. 만약 unique_for_date 제약 조건이 ModelForm의 일부가 아닌 필드(예: 필드 중 하나가 제외되거나 editable=False)라면, Model.validate_unique()는 해당 제약 조건에 대한 유효성(validation) 검사를 생략합니다.unique_for_monthField.unique_for_monthunique_for_date와 비슷하지만, 달(month)에 대해서 고유한 필드를 요구합니다.unique_for_yearField.unique_for_yearunique_for_date와 unique_for_month와 비슷합니다.verbose_nameField.verbose_name해당 필드에 대해 사람이 읽기 쉬운 이름입니다. 만약 verbose name이 주어지지 않는다면, 장고는 자동적으로 field의 attribute 이름에서 undersocre을 띄어쓰기로 바꾸어 사용할 것입니다. Verbose field names를 보십시오.validatorsField.validators해당 필드에 대해서 실행할 validator의 list입니다. 자세한 사항은 validator document를 보십시오.Registering and fetching lookupsField는 lookup registration API를 구현했습니다. API를 사용하여 필드 클래스에 사용할 수 있는 lookup과 필드에서 lookup을 가져오는 방법을 customize할 수 있다.Field typesAutoFieldclass AutoField(options)**사용 가능한 ID에 따라 자동적으로 증가하는 IntegerField 입니다. 이를 직접적으로 사용할 필요는 없습니다; 만약 primary key를 따로 명시하지 않는다면 자동으로 모델에 추가될 것입니다. Automatic primary key fields를 참고하십시오.BigAutoFieldclass BigAutoField(**options)64bit의 정수입니다. 숫자가 1부터 9223372036854775807 까지 증가한다는 점을 제외하고는 AutoField와 같습니다.BigIntegerFieldclass BigIntegerField(options)**64bit의 정수입니다. 숫자가 -9223372036854775808에서 9223372036854775807까지 증가한다는 점을 제외하고는 IntegerField와 같습니다. 이 필드에 대한 기본 폼 위젯은 TextInput입니다.BinaryFieldclass BinaryField(max_length=None, **options)원시 바이너리 데이터를 저장하는 필드입니다. bytes, bytearray, memoryview를 할당할 수 있습니다.기본적으로 BinaryField는 eidtable을 False로 설정합니다. 이 경우 ModelForm에 추가될 수 없습니다.      Changed in Django 2.1:    이전 버전에서는 editable을 True로 설정하는 것이 금지되었습니다.  BinaryField는 추가적인 optional argument를 갖고 있습니다:BinaryField.max_length필드의 최대 (문자열) 길이입니다. 이는 Django의 validation에서 MaxLengthValidator를 사용하여 검증됩니다.      Abusing BinaryField    이를 이용하여 데이터베이스 파일을 저장할 수 있다고 생각할 수 있지만, 99%의 경우 그것은 나쁜 디자인이 될 것입니다. 이 필드는 static files 처리를 위한 대체물이 아닙니다.  BooleanFieldclass BooleanField(options)**true/false 필드입니다.이 필드에 대한 기본 폼 위젯은 CheckboxInput 이거나, null=True일 경우 NullBooleanSelect입니다.Field.default가 설정되지 않는다면 BooleanField의 기본 값은 None입니다.      Changed in Django 2.1:    이전 버전에서는, 이 필드의 null=True가 불가능 했기 때문에 NullBooleanField를 사용해야 했습니다. 이제는 NullBooleanField의 사용을 권하지 않는데, 이 항목은 앞으로의 Django 버전에서 deprecated 될 것이기 때문입니다.  CharFieldclass CharField(max_length=None, **options)작은 사이즈에서 큰 사이즈의 문자열 입니다.많은 양의 텍스트에 대해서는 TextField를 사용하십시오.이 필드에 대한 기본 폼 위젯은 TextInput 입니다.CharField는 하나의 추가적인 필수 argument가 있습니다.CharField.max_length이 필드에 대한 최대 (문자열) 길이입니다. 이는 Django의 validation에서 MaxLengthValidator를 사용하여 검증됩니다.      Note    복수의 데이터베이스 backends 에서 가능한 application을 작성하고 있다면, 몇몇의 backend에서는 max_length에 제한이 있다는 것을 아셔야 합니다. 자세한 사항은 database backend notes를 참고하십시오.  DateFieldclass DateField(auto_now=False, auto_now_add=False, **options)Python datetime.date instance로 표현된 날짜입니다. 몇 가지 추가적인 optional argument가 있습니다:DateField.auto_now자동적으로 객체가 저장될 때마다 필드를 현재 시간으로 설정합니다. “last-modified” timestamps에 유용합니다. 항상 현재 시간이 사용된다는 것을 기억하십시오; 이는 override 할 수 있는 기본 값이 아닙니다.이 필드는 Model.save()를 호출할 때만 자동적으로 업데이트 됩니다. QuerySet.update()와 같이 다른 방법으로 필드를 업데이트 할 때 이 필드는 업데이트 되지 않습니다. 단, 그러한 업데이트에서도 필드에 사용자 지정 값을 받을 수 있습니다.DateField.auto_now_add객체가 처음 생성될 때 이 필드를 현재 시간으로 설정합니다. 생성에 대한 timestamps에 유용합니다. 항상 현재 시간이 사용된다는 것을 기억하십시오; 이는 override할 수 있는 기본 값이 아닙니다. 따라서 객체를 생성할 때 이 필드에 한 값을 설정해도 그것은 무시될 것입니다. 만약 이 필드를 수정하고 싶다면, auto_now_add=True라고 하는 것 대신에 다음을 설정하십시오:  DateField: from datetime.date.today(), default=date.today  DateTimeField: from django.utils.timezone.now(), default=timezone.now이 필드에 대한 기본 폼 위젯은 TextInput입니다. admin은 Javascript calendar를 추가하고, “Today”에 대한 shortcut을 제공할 것입니다. 추가적인 invalid_date 에러 메세지 key를 포함합니다.auto_now_add, auto_now 및 default는 상호 배타적입니다. 이 옵션들의 어떠한 조합도 오류를 일으킬 것입니다.      Note    현재 구현된 대로, auto_now 또는 auto_now_add를 True로 설정하면 필드의 editable=False 그리고 blank=True로 설정됩니다.        Note    auto_now와 auto_now_add options는 생성되거나 업데이트 될 때의 default timezone의 date를 항상 사용합니다. 만약 다른 것이 필요하다면, auto_now 또는 auto_now_add 대신에 callable default를 사용하거나 save()를 override하는 것을 고려해 보십시오; 또는 DateField 대신에 DateTimeField를 사용하고 디스플레이 시간에 Datetime에서 date로 변환을 처리하는 방법을 결정하십시오. ㅋ  DateTimeFieldclass DateTimeField(auto_now=False, auto_now_add=False, **options)Python datetime.datetime instance로 나타낸 날짜와 시간입니다. DateField와 같은 추가적인 arguments를 갖고 있습니다.기본적인 폼 위젯은 single TextInput입니다. admin은 Javascript shortcust와 함께 분리된 두 개의 TextInput 위젯을 사용합니다.DecimalFieldclass DecimalField(max_digits=None, deciaml_places=None, **options)Python Decimal instance로 나타낸 고정 소수점 숫자입니다. 이는 DecimalValidator를 사용하여 입력을 검증합니다.두 개의 필수 arguments를 갖고 있습니다.DecimalField.max_digits숫자에 허용되는 최대 자릿수입니다. 이 값은 decimal_places보다 크거나 같아야 한다는 점에 유의하십시오.DecimalField.decimal_places숫자의 소수점 아래 자릿수 입니다.예를 들어, 999를 소수점 아래 2자리까지 나타내기 위해서 다음과 같이 사용합니다:models.DecimalField(..., max_digits=5, decimal_places=2)약 10억의 수를 소수점 아래 10자리까지 나타내기 위해서 다음과 같이 사용합니다:models.DecimalField(..., max_digits=19, decimal_places=10)이 필드의 기본 폼 위젯은 localize가 False일 때 NumberInput이고 그렇지 않으면 TextInput입니다.      Note    FloatField와 DecimalField classes 사이의 차이점에 대한 정보는 FloatField vs DecimalField를 참고하십시오.  Duration Fieldclass DurationField(options)**Python timedelta의해 모델링 된 시간의 기간을 저장하는 필드입니다. PostgreSQL에서 사용될 경우, 데이터 타입은 interval이며 Oracle에서 사용될 경우 INTERVAL DAY(9) TO SECOND(6)입니다. 그렇지 않으면 microseconds의 bigint가 사용됩니다.      Note    대부분의 경우 DurationField와 관련된 산술은 작동합니다. 그러나 PostgreSQL이외의 모든 데이터베이스에서 DurationField의 값과 DateTimeField instance의 산술 값(숫자)을 비교하는 것은 작동하지 않을 것입니다.  EmailFieldclass EmailField(max_length=254, **options)EmailValidator를 사용하여 유효한 이메일 주소인지 확인하는 Charfield입니다.FileFieldclass FileField(upload_to=None, max_length=100, **options)파일을 업로드하는 필드입니다.      Note    primary_key argument를 지원하지 않으며, 사용시 에러가 발생합니다.  두 가지 optional argument가 있습니다:FileField.upload_to이 attribute는 업로드 디렉토리와 파일 이름을 설정하는 방법을 제공하며, 두 가지 방법으로 설정할 수 있습니다. 두 경우 모두 그 값이 Storage.save() method로 전달됩니다.문자열 값을 명시할 경우, 파일 업로드 할 때의 날짜/시간으로 대체되는 strftime() formatting을 포함할 수 있습니다. 예시를 보십시오:class MyModel(models.Model):    # file will be uploaded to MEDIA_ROOT/uploads    upload = models.FileField(upload_to='uploads/')    # or...    # file will be saved to MEDIA_ROOT/uploads/2015/01/30    upload = models.FileField(upload_to='uploads/%Y/%m/%d/')기본 FileSystemStorage를 사용하는 경우, 문자열 값은 MEDIA_ROOT 경로에 추가되어 업로드 된 파일이 저장될 로컬 파일 시스템의 위치를 형성합니다. 다른 저장소를 사용하는 경우, 해당 저장소의 설명서를 확인하여 upload_to를 처리하는 방법을 확인하십시오.upload_to는 함수와 같은 callable일 수 있습니다. 이것은 파일 이름을 포함한 업로드 경로를 얻기 위해 호출될 것입니다. 이 callable은 두 개의 arguments를 받아들이며 저장소 시스템에 전달될 (forward slashes를 갖고 있는) 유닉스 스타일의 경로를 반환해야 합니다. 두 개의 arguments는 다음과 같습니다:Untitled예시를 보십시오:def user_directory_path(instance, filename):    # file will be uploaded to MEDIA_ROOT/user_&lt;id&gt;/&lt;filename&gt;    return 'user_{0}/{1}'.format(instance.user.id, filename)class MyModel(models.Model):    upload = models.FileField(upload_to=user_directory_path)FileField.storage파일 저장 및 검색을 처리하는 저장소 객체입니다. 이 객체 제공하는 방법에 대한 자세한 내용은 Managing files를 보십시오.이 필드에 대한 기본 폼 위젯은 ClearableFileInput입니다.모델에서 FileField 또는 ImageField(아래를 보십시오)를 사용하기 위해서는 몇 가지 단계가 필요합니다:  당신의 settings file에서, Django가 업로드 된 파일들을 저장하기 원하는 디렉토리의 전체 경로로서 MEDIA_ROOT를 정의해야 합니다. (성능을 위해서 이 파일들은 데이터베이스에 저장되지 않습니다.) 해당 디렉토리의 base public URL로서 MEDIA_URL을 정의하십시오. 웹 서버의 사용자 계정이 이 디렉토리에 쓰기가 가능한지 확인하십시오.  모델에 FileField 또는 ImageField를 추가하십시오. 그리고 업로드 된 파일에 사용할 서브 디렉토리를 명시하기 위해 upload_to 옵션을 정의하십시오.  데이터 베이스에 저장될 모든 것은 (MEDIA_ROOT와 관련된) 파일에 대한 경로입니다. 아마 Django가 제공하는 편리한 url attribute를 사용하고 싶을 것입니다. 예를 들어, mug_shot이라 불리는 ImageField의 경우, 다음과 같은 템플릿을 이용하여 절대 경로를 얻을 수 있습니다: **예를 들어, 당신의 MEDIA_ROOT 가 ‘/home/media’로 설정되어 있고, upload_to가 ‘photos/%Y/%m/%d’ 로 설정되어 있다고 가정합시다. upload_to의 %Y/%m/%d’ 부분은 strftime() 포맷입니다; ‘%Y’는 네 자리의 ‘연도’, ‘%m’은 두 자리의 ‘월’, ‘%d’은 두 자리의 ‘일’입니다. 2007년 1월 15일에 파일을 업로드 할 경우, /home/media/photos/2007/01/15의 경로에 저장됩니다.업로드한 파일의 디스크에 있는 파일 이름 또는 크기를 얻으려면, 각각의 name과 size attributes를 사용할 수 있습니다; 사용 가능한 attributes와 methods에 대한 자세한 설명은 File class를 참조하시고 Managing files 가이드를 살펴보십시오.      Note    파일을 저장하는 것은 데이터베이스에 모델을 저장하는 것의 한 부분이기 때문에, 디스크에서 사용될 실제 파일 이름은 모델이 저장된 후에야 사용할 수 있습니다.  업로드한 파일의 relative URL은 url attirbute를 사용하여 얻을 수 있습니다. 이는 내부적으로 Storage class의 url() method를 호출합니다.보안상의 허점을 피하기 위해서는 업로드한 파일들을 처리할 때마다 그들의 업로드 위치와 파일 형식에 세심한 주의를 기울여야 합니다. 업로드 된 모든 파일의 유효성 검사를 진행하여 파일이 당신이 생각하는 그대로 있는지 확인하십시오. 예를 들어, 유효성 검사 없이 다른 사용자들이 당신의 웹 서버 document root안의 디렉토리에 파일을 업로드하게 한다면, 누군가가 당신의 사이트의 URL을 방문해서 CGI나 PHP 스크립트를 업로드하고 그 스크립트를 실행할 수 있게 됩니다. 이를 허용하지 마십시오.또한 업로드한 HTML 파일들도 (서버를 통해서가 아니라) 브라우저에 의해 실행될 수 있기 때문에, XSS 또는 CSRF 공격에 준하는 보안 위협을 가할 수 있다는 점에 주의하십시오.FileField instance는 기본 최대 길이(default maximum length)가 100자인 varchar column으로서 데이터베이스에 생성됩니다. 다른 필드와 마찬가지로 max_length argument를 사용하여 이를 바꿀 수 있습니다.FileField and FieldFileclass FieldFile모델의 FileField에 엑세스할 때, 기본 파일에 엑세스하기 위한 proxy로서 FieldFile instance가 주어집니다.FieldFile의 API는 File의 API을 반영하지만, 한 개의 주요 차이가 있습니다; 클래스에 의해 wrap 된 object가 반드시 Python의 built-in file object의 wrapper는 아닙니다. 대신, Storage.open() method의 결과로 둘러싸인 wrapper인데, 이는 File object일 수 있고 또는 File API의 custom storage’s implementation일 수 있습니다.File에서 상속받은 read(), write()와 같은 API 이외에도, FieldFile은 기본 파일들과 상호작용할 수 있는 몇 가지 methods가 있습니다.      Warning    이 클래스의 두 methods인 save()와 delete()는 데이터베이스에 FieldFile과 연관된 모델 개체를 저장하는데 기본적으로 사용됩니다.  FieldFile.name관련 FileField의 Storage의 root로부터의 상대 경로를 포함한 파일 이름.FieldFile.url기본 Stroage class의 url() method를 호출하여 파일의 상대적 URL에 엑세스하는 읽기 전용 속성.FieldFile.open(mode=’rb’)특정 mode로 이 instance와 관련된 파일을 열거나 다시 열어줍니다. 표준 Python open() method와 달리, 이는 파일 설명자를 반환하지 않습니다.FieldFile.close()Python file.close()와 같이 작동하며 이 instance와 관련된 파일을 닫습니다.FieldFile.save(name, content, save=True)이 method는 파일 이름과 내용을 인자로 받으며 이들을 필드에 대한 storage class로 전달합니다. 그리고 저장된 파일과 모델 필드를 연결 짓습니다. 모델의 FileField instance와 직접 파일 데이터를 연결하고 싶은 경우, save() method를 사용하여 해당 파일 데이터를 유지하십시오.….FloatFieldclass FloatField(options)**Python float instance에 의해 표현된 부동소수점입니다.이 필드의 기본 폼 위젯은 localize가 False일 경우 NumberInput이고 아닐 경우 TextInput입니다.      FloatField vs. DecimalField    FloatField class는 가끔 DecimalField class와 혼용됩니다. 이들 모두 실수를 나타내지만, 그들은 다르게 숫자를 표현합니다. FloatField는 내부적으로 Python의 float type을 사용하는 반면, DecimalField는 Python의 Decimal type을 사용합니다. 더 자세한 차이를 알고 싶다면, decimal module에 대한 Python documentation을 보십시오.  ImageFieldclass ImageField(upload_to=None, height_field=None, width_field=None, max_length=100, **options)…IntegerFieldclass IntegerField(options)**정수입니다. -2147483648부터 2147483647까지의 값은 Django가 지원하는 모든 데이터베이스에서 안전합니다.MinValueValidator와 MaxValueValidator를 사용하여 기본 데이터베이스가 지원하는 값을 기반으로 입력을 검증한다.이 필드에 대한 기본 폼 위젯은 localize일 때 False이고, 그렇지 않으면 TextInput입니다.GenericIPAddressFieldclass GenericIPAddressField(protoco=’both’, unpack_ipv4=False, **options)문자열 형식(e.g. 192.0.2.30 or 2a02:42fe::4)의 IPv4 또는 IPv6 주소입니다. 이 필드의 기본 폼 위젯은 TextInput입니다.IPv6 주소 normalization은 RFC 4291#section-2.2를 따릅니다. 여기에는 ::ffff:192.0.2.0 와 같은 해당 섹션의 제 3문단에서 제시한 IPv4 포맷이 포함됩니다. 예를 들어 2001:0::0:01는 2001::1으로 normalize되고,  ::ffff:0a0a:0a0a는 ::ffff:10.10.10.10으로 됩니다. 모든 문자는 소문자로 변환됩니다.GenericIPAddressField.protocol특정 프로토콜로 유효한 입력을 제한합니다. 가능한 값은 ‘both’(default)이거나 ‘IPv4’ 또는 ‘IPv6’입니다. 매칭은 대소문자를 구분하지 않습니다.GenericIPAddressField.unpack_ipv4::ffffff:192.0.2.1과 같은 매핑된 IPv4 주소를 풉니다. 이 옵션을 활성화하면 해당 주소가 192.0.2.1로 풀리게 됩니다.Default는 비활성화됩니다. protocol이 ‘both’로 설정되어 있을 때만 사용할 수 있다.NullBooleanFieldclass NullBooleanField(options)**null=True인 BooleanField와 같습니다. Django 미래 버전에서 이 필드는 deprecated 될 것이므로 BooleanField를 사용하십시오.PositiveIntegerFieldclass PositiveIntegerField(options)**IntegerField와 같지만, 0 이거나 양수여야 합니다. 0부터 2147483647까지의 값은 Django가 지원하는 모든 데이터베이스에서 안전합니다. 0의 값은 역호환성 이유로 허가됩니다(The value 0 is accepted for backward compatibility reasons).PositiveSmallIntegerFieldclass PositiveSmallIntegerField(options)**PositiveIntegerField와 비슷하지만, 특정 (데이터베이스에 따라 달라지는) 포인트 이하의 값만 허용한다. 0에서 32767까지의 값은 Django가 지원하는 모든 데이터베이스에서 안전하다.SlugFieldclass SlugField(max_length=50, **options)Slug는 신문용어입니다. slug는 글자, 숫자, 밑줄 또는 하이픈만 포함하는 어떤 것의 짧은 꼬리표입니다. 이들은 일반적으로 URL에서 사용됩니다.CharField처럼 max_length를 지정할 수 있습니다(CharField에 있는 데이터베이스 호환성에 대한 note와 max_length에 대하여 읽어보십시오). max_length이 명시되지 않은 경우 Django는 기본적으로 50으로 설정합니다.이는 Field.db_index를 True로 설정하는 것을 암시합니다.몇몇 다른 값에 기초해 자동으로 SlugField를 미리 생성하여 사용하는 것이 종종 유용합니다. 이를 admin에서 prepopuluate_fields를 사용하여 자동적으로 할 수 있습니다.SlugField.allow_unicodeTrue일 경우 이 필드는 ASCII 문자 외에 Unicode 문자를 허용합니다. 기본값은 False입니다.SmallIntegerFieldclass SmallIntegerField(options)**IntegerField와 비슷하지만, 특정 (데이터베이스에 따라 달라지는) 포인트 이하의 값만 허용한다. -32768 ~ 32767의 값은 장고에서 지원하는 모든 데이터베이스에서 안전하다.TextFieldclass TextField(options)**큰 텍스트 필드입니다. 이 필드에 대한 기본 폼 위젯은 Textarea입니다.만약 max_length attribute를 지정하면 자동으로 생성되는 폼 필드의 Textarea 위젯에 반영됩니다. 그러나 이는 모델이나 데이터베이스 레벨에서 시행되지는 않습니다. 그것을 위해서는 CharField를 사용하십시오.TimeFieldclass TimeField(auto_now=False, auto_now_add=False, **options)Python의 datetime.time instance로 표현된 시간입니다. DateField와 같은 auto와 관련된 옵션이 있습니다.이 필드에 대한 기본 폼 위젯은 TextInput입니다. admin은 몇개의 Javascript shortcut을 추가합니다.URLFieldclass URLField(max_length=200, **options)URL에 대한 CharField입니다. URLValidator에 의해 검사됩니다.이 필드에 대한 기본 폼 위젯은 TextInput입니다.CharField의 자식클래스와 같이, URLField 역시 optional max_length argument를 받아들입니다.이를 명시하지 않을 경우 기본적으로 200이 사용됩니다.UUIDFieldclass UUIDField(options)**보편적으로 고유한 식별자(identifiers)를 저장하기 위한 필드입니다. Python의 UUID class를 사용합니다. PostgreSQL에서 사용할 때, 이 데이터 유형은 uuid 데이터 형식으로 저장되며, 그렇지 않을 경우 char(32) 형식입니다.일반적으로 고유한 식별자는 primary_key의 AutoField에 대한 좋은 대안입니다. 데이터베이스가 UUID를 자동으로 생성하지 않으므로, default을 사용하는 것을 추천합니다:import uuidfrom django.db import modelsclass MyUUIDModel(models.Model):    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)    # other fieldsUUID instance가 아니라 (괄호가 생략된 상태의) callable이 default로 전달되었다는 점에 유의하십시오.",
        "url": "/2019/02/01/Field-types.html"
      }
      ,
    
      "2019-01-18-making-queries-html": {
        "title": "Making Queries",
        "date": "Jan 18, 2019",
        "author": "김선규(Kim,seon-kyu)",
        "category": "",
        "content": "Making queries너가 data models를 만들고 나면, Django는 create, retrieve, update 그리고 delete object를 할 수 있는 database-abstraction API를 자동적으로 제공할 것이다. 이 문서는 이 API를 어떻게 사용하는지를 알려준다. 모든 다양한 model lookup options에 대한 자세한 내용은 data model reference를 참조하여라.이 가이드를 설명하는 동안, 우리는 다음과 같이 Weblog application을 구성하는 models를 사용할 것이다:from django.db import models    class Blog(models.Model):    name = models.CharField(max_length=100)    tagline = models.TextField()    \t    def __str__(self):        return self.name    class Author(models.Model):    name = models.CharField(max_length=200)    email = models.EmailField()        def __str__(self):        return self.name    class Entry(models.Model):    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)    headline = models.CharField(max_length=255)    body_text = models.TextField()    pub_date = models.DateField()    mod_date = models.DateField()    authors = models.ManyToManyField(Author)    n_comments = models.IntegerField()    n_pingbacks = models.IntegerField()    rating = models.IntegerField()        def __str__(self):        return self.headlineCreating objectsPython object의 database-table data를 나타내기 위해, Django는 직관적인 시스템을 사용한다: database class를 나타내는 model class, 그리고 그 class의 instance는 database table 안의 특정 기록들을 나타낸다.object를 생성하기 위해, model class의 keyword arguments를 사용하여 그것을 instantiate 한 뒤, database에 저장하기 위해 save()를 호출해라.models가 mysite/blog/models.py 파일 안에 있다고 가정하자. 예시는 다음과 같다:&gt;&gt;&gt; from blog.models import Blog&gt;&gt;&gt; b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')&gt;&gt;&gt; b.save()이는 뒤에서 INSERT SQL statement를 실행한다. Django는 너가 명시적으로 save()를 호출하기 전까지 database를 건드리지 않는다.save() method는 return 값이 없다.      See also    save()는 여기에서 설명하지 않은 다수의 advanced option들이 있다. 모든 세부 사항을 위해서 save() 문서를 참조하라    object를 생성하고 저장하는 것을 한 번에 하기 위해서는 create() method를 사용하여라.  Saving changes to objectsdatabse 에 이미 있는 object의 변경 사항을 저장하기 위해서는 save()를 사용해라.주어진 Blog instance b5는 이미 database에 저장되어 있다. 이 예시는 그것의 이름을 바꾸고, database에 그것의 record를 update하는 것이다:&gt;&gt;&gt; b5.name = 'New name'&gt;&gt;&gt; b5.save()이것은 뒤에서 UPDATE SQL statement를 실행한다. Django는 너가 명시적으로 save() 호출하기 전까지 database를 건드리지 않는다.Saving ForeignKey and ManyToManyField fieldsForeignKey field를 update하는 것은 일반적인 field를 저장하는 것과 정확히 같은 방법으로 작동한다 - 단순히 옳은 타입의 object를 할당 해주는 것이다. 이 예시는 Entry instance entry의 blog attribute를 update하는 것이다. Entry와 Blog의 적당한 instances들이 이미 database에 저장되어 있다고 가정하자(따라서 우리는 다음과 같이 그들을 retrieve 할 수 있다):&gt;&gt;&gt; from blog.models import Blog, Entry&gt;&gt;&gt; entry = Entry.objects.get(pk=1)&gt;&gt;&gt; chees_blog = Blog.objects.get(name=\"Cheddar Talk\")&gt;&gt;&gt; entry.blog = cheese_blog&gt;&gt;&gt; entry.save()ManyToManyField를 updating하는 것은 약간 다르게 작동한다 - relation에 record를 추가하기 위해 field에 add() method를 사용해라. 이 예시는 Author instance joe를 entry object에 추가한 것이다:&gt;&gt;&gt; from blog.models import Author&gt;&gt;&gt; joe = Author.objects.create(name=\"Joe\")&gt;&gt;&gt; entry.authors.add(joe)ManyToManyField에 많은 수의 record를 한 번에 저장하기 위해, 많은 arguments를 add() 의 호출 안에 포함해라. 다음과 같다:&gt;&gt;&gt; john = Author.objects.create(name=\"John\")&gt;&gt;&gt; paul = Author.objects.create(name=\"Paul\")&gt;&gt;&gt; george = Author.objects.create(name=\"George\")&gt;&gt;&gt; ringo = Author.objects.create(name=\"Ringo\")&gt;&gt;&gt; entry.authors.add(john, paul, george, ringo)Django는 만약 너가 다른 종류의 object를 추가하거나 할당 할 때 error를 일으킬 것이다.Retrieving objects너의 database로부터 objects를 retrieve하기 위해, 너의 model class의 Manager를 통해 QuerySet을 구성해라.QuerySet은 너의 database의 objects의 모음을 나타낸다. 이것은 없거나 한 개일 수도 있고, 많은 filter일 수도 있다. Filters는 주어진 parmeters에 따라서 query results를 줄여 나간다. SQL 용어로는, QeurySet은 SELECT 명령어에 해당하고, filter은 제한하는 구절인 WHERE 또는 LIMIT이다.너는 너의 model Manager를 사용함으로써 QuerySet을 얻는다. 각각의 model은 적어도 한 개의 Manager를 갖고 있고, 이는 기본적으로 objects라고 불리운다. 다음와 같이 model class를 통해 직접적으로 접근할 수 있다:&gt;&gt;&gt; Blog.objects&lt;django.db.models.manager.Manager object at ...&gt;&gt;&gt;&gt; b = Blog(name='Foo', tagline='Bar')&gt;&gt;&gt; b.objectsTraceback:\t...AttributeError: \"Manager isn't accessible via Blog instances.\"      Note    Managers는 model class를 통해서만 접근할 수 있고 model instances를 통해서는 안된다. 이는 “table-level” operations와 “record-level” operations를 분리하기 위함이다.  Manager은 한 model에 대한 QuerySets의 메인 소스이다. 예를 들어, Blog.objects.all()은 database에서 모든 Blog objects를 담고 있는 QuerySet을 반환한다.Retrieving all objectstable로 부터 objects를 retrieve하는 가장 쉬운 방법은 모든 것들을 받는 것이다. 이를 하기 위해서 Manager에 all() method를 사용해라:&gt;&gt;&gt; all_entries = Entry.objects.all()all() mothod는 database에 있는 모든 objects의 QuerySets을 반환한다.Retrieving specific objects with filtersall()에 의해 반환된 QuerySet은 database table의 모든 objects를 묘사한다. 그러나 보통, 너는 완전한 objects의 집합에서 일부만 선택해야 할 필요가 있을 것이다.이러한 부분집합을 만들기 위해서, 너는 filter conditions를 추가하여 초기의 Queryset을 수정한다. 다음은 QuerySet을 refine하는 대표적인 두 가지 방법이다:filter(kwargs)**주어진 lookup parameters와 match하는exclude(kwargs)**주어진 lookup parameters와 match하지 않는 objects를 포함하고 있는 새로운 QuerySet을 반환한다.lookup parameters (위 함수의 정의에서 **kwargs)는 Field lookups 아래에 기술된 포멧을 따라야 한다.예를 들어, 2006년의 blog entries의 QuerySet을 얻고 싶다면 다음과 같이 filter()를 사용해라:Entry.objects.filter(pub_date__year=2006)기본 manager class를 사용하면 이는 다음과 같다:Entry.objects.all().filter(pub_date__year=2006)Chaining filtersQuerySet을 refine한 결과는 QuerySet 그 자신이기 때문에 연속적인 refinement을 함께 할 수 있다. 예시를 보자:&gt;&gt;&gt; Entry.objects.filter(...\t\theadline__startswith='What'...).exclude(...\t\tpub_date__gte=datetime.date.today()...).filter(...\t\tpub_date__gte=datetime.date(2005, 1, 30)...)이는 모든 database의 entries를 시작 QuerySet으로 받고, filter를 추가하고, exclusion하고, 다른 filter를 추가했다. 최종 QuerySet의 결과는 “What”으로 시작하는 headline과 현재 날짜와 2005년 1월 30일 사이에 출판된 모든 entries를 갖고 있다.Filtered QuerySets are unique너가 QuerySet을 refine할 때마다, 너는 이전의 QuerySet과 전혀 연결되지 않은 새로운 QuerySet을 을 얻는다. 각각의 refinement는 저장되고, 사용되고, 다시 쓸 수 있는 분리되고 별개의 QuerySet을 생성한다.다음은 예시이다:&gt;&gt;&gt; q1 = Entry.objects.filter(headline__startswith=\"What\")&gt;&gt;&gt; q2 = q1.exclude(pub_date__dte=datetime.date.today())&gt;&gt;&gt; q3 = q1.filter(pub_date__gte=datetime.date.today())이 세 가지 QuerySets는 각각 별개이다. 첫 번째 것은 “What”으로 시작하는 headline을 갖고 있는 모든 entries를 포함하는 QuerySet이다. 두 번째 것은 첫 번째 것의 하위 집합으로, pub_date가 오늘이거나 미래인 것들의 records를 제외하는 추가적인 기준을 갖고 있다. 세 번째 것은 첫 번째의 하위 집합으로, pub_date가 오늘이거나 미래인 것들만 고르는 추가적인 기준을 갖고 있다. 초기 QuerySet(q1)은 refinement 과정에 영향을 받지 않는다.QuerySets are lazyQuerySets는 게으르다 - QuerySet을 생성하는 작업은 어떠한 database activity도 포함하지 않는다. 너는 매우 길게 filters를 쌓을 수 있지만, Django는 QuerySet가 evaluated 되기 전까지 실제로 query를 실행하지 않는다. 다음 예시를 보자:&gt;&gt;&gt; q = Entry.objects.filter(headline__startswith=\"What\")&gt;&gt;&gt; q = q.filter(pub_date__lte=datetime.date.today())&gt;&gt;&gt; q = q.exclude(body_text__icontains=\"food\")&gt;&gt;&gt; print(q)이는 세 번의 database hit처럼 보이지만, 사실 이것은 마지막 line의 (print(q))에서 database를 단 한 번만 hit한다. 일반적으로, 너가 QuerySet의 결과를 요구하지 않는 이상, 그것들은 database로 부터 도출되지 않을 것이다. 너가 그것을 할 때, QuerySet은 database에 접근하여 evaluated된다. 언제 evaluation이 일어나는지에 대한 자세한 디테일은 When QuerySets are evalutated를 보아라.Retrieving a single object with get()filter()는 너에게 항상 QuerySet을 줄 것이다, 단 하나의 object가 query에 해당할 지라도 - 이 경우에, 이는 하나의 요소를 갖고 있는 QuerySet이 될 것이다.만약 너가 query에 해당하는 하나의 object가 있다는 것을 안다면, 그 object를 직접적으로 반환하는 Manager의 get() mehtod를 사용해라:&gt;&gt;&gt; one_entry = Entry.objects.get(pk=1)너는 마치 filter()처럼 어떠한 query expression과도 함께 get()을 사용할 수 있다 - 다시 말하지만, Field looups 아래를 참고해라.get()을 사용하는 것과 [0] 슬라이싱과 함께 filter()를 사용하는 것에 차이가 있다는 점을 알고 있어라. 만약 query와 맞는 결과가 없다면, get()은 DoesNotExist exception을 일으킬 것이다. 이 exception은 query가 수행되고 있는 model class의 attribute이다 - 따라서 위의 코드에서 만약 primary key가 1인 Entry object가 없다면, Django는 Entry.DoesNotExist를 일으킬 것이다.비슷하게, Django는 get() query에 한 개 이상의 해당하는 것이 있을 경우 에러를 일으킬 것이다. 이 경우, 그것은 MultipleObjectsReturned를 일으킬 것이고, 이 역시 model class 자체의 attribute이다.Other QuerySet methods너가 all(), get(), filter(), 그리고 exclude()를 사용할 대부분의 경우는 너가 database로부터 objects를 찾아볼 필요가 있을 때이다. 그러나 이 외에도 많은 것이 있다; 다양한 QuerySet method의 전체 리스트를 보기 위해서는 QuerySet API Reference를 보아라.Limiting QuerySets너의 QuerySet이 특정 개수의 결과를 갖게 제한하고 싶다면 Python의 array-slicing syntax를 이용해라. 이는 SQL의 LIMIT 과 OFFSET clauses와 같다.예를 들어 다음은 첫 5개의 objects를 반환한다(LIMIT 5):&gt;&gt;&gt; Entry.objects.all()[:5]다음은 6번째 부터 10번째 objects를 반환한다(OFFSET 5 LIMIT 5):&gt;&gt;&gt; Entry.objects.all()[5:10]Negative indexing(i.e. Entry.objects.all()[-1])은 지원되지 않는다.일반적으로, slicing QuerySet은 새로운 QuerySet을 반환한다 - 이것은 query를 evaluate하지 않는다. 예외는 너가 Python slice syntax에서 “step” parameter를 사용할 경우이다. 예를 들어, 이것은 첫 10개의 매 두 번째 objects를 반환하기 위해 query를 실행한다:&gt;&gt;&gt; Entry.objects.all()[:10:2]sliced queryset에 filtering을 추가하거나 순서를 매기는 것은 그것이 어떻게 작동할지에 대한 모호성 때문에 금지된다.리스트가 아니라 하나의 단일 object를 얻고 싶다면(e.g. SELECT foo FROM bar LIMIT 1), slice 대신에 간단한 index를 사용해라. 예를 들어, 이는 headline을 알파벳 순서로 정렬한 후, database의 첫 번째 Entry를 반환할 것이다.&gt;&gt;&gt; Entry.objects.order_by('headline')[0] 이것은 대략 다음과 같다:&gt;&gt;&gt; Entry.objects.order_by('headline')[0:1].get()그러나, 만약 기준에 합당한 objects가 없다면 첫 번째 것은 IndexError를 일으키는 반면, 두 번째 것은 DoesNotExist를 일으킬 것이다. 자세한 사항은 get()을 보아라.Field lookupsField lookups는 SQL WHERE clause의 항목을 지정하는 방법이다. 그들은 QuerySet method인 filter(), exclude(), 그리고 get()에 keyword arguments로 명시돼 있다.기본 lookups keyword arguments들은 field__lookuptype=value와 같은 형식을 취한다. (두 개의 underscore이다). 예시를 보자:&gt;&gt;&gt; Entry.objects.filter(pub_date__lte='2006-01-01')대략 다음과 같은 SQL로 바뀐다:SELECT * FROM blog_entry WHERE pub_date &lt;= '2006-01-01';      How this is possible    Python은 runtime에 names와 values가 evalutated되는 임의의 name-value arguments를 허용하는 함수를 정의 할 수 있다. 자세한 내용은 공식 Python 튜토리얼의 Keyword Arguments를 참조하여라.  lookup에 명시된 field는 model field의 이름이어야 한다. 한 가지 예외가 있는데, ForeignKey의 경우, 너는 접미사로 _id가 추가된 field name을 명시할 수 있다. 이 경우에 value parameter는 foreign model의 primary key의 raw value를 포함할 것을 기대된다. 예시를 보자:&gt;&gt;&gt; Entry.objects.filter(blog_id=4)만약 너가 유효하지 않은 keyword argument를 넘겨준다면, lookup 함수는 TypeError를 일으킬 것이다.datase API는 약 24개의 lookup type들을 소개한다; 완전한 reference는 field lookup reference를 참조하여라. 무엇이 가능한지 잠깐 소개를 하기 위해 여기에는 너가 자주 사용하게 될 몇 가지를 소개하겠다:exact'’exact’’ match이다. 예시를 보자:&gt;&gt;&gt; Entry.objects.get(headline__exact=\"Cat bites dog\")이는 다음과 같은 SQL lines이다:SELECT ... WHERE headline = 'Cat bites dog';만약 너가 lookup type을 제공하지 않는다면 - 즉, 너의 keyword argument가 double underscore을 포함하지 않는다면 - lookup type은 exact라고 가정된다.예를 들어, 다음 두 문장은 동일하다:&gt;&gt;&gt; Blog.objects.get(id__exact=14)   # Explicit form&gt;&gt;&gt; Blog.objects.get(id=14           # __exact is impliedexact lookups는 일반적인 경우이므로, 이는 편의를 위한 것이다.iexactcase-insensitive match이다. 따라서 다음 query:&gt;&gt;&gt; Blog.objects.get(name__iexact=\"beatles blog\")는 “Beatles Blog”, “beatles blog”, 또는 심지어 “BeAtlES blOG”의 제목을 가진 Blog를 match한다.containscase-sensitive한 포함 테스트이다. 예시를 보자:Entry.objects.get(haadline__contains='Lennon')이는 대략 다음 SQL과 같다:SELECT ... WHERE headline LIKE '%Lennon%';이는 ‘Today Lennon honored’ 의 headline을 match하지만, ‘today lennon honored’는 match하지 않는다는 점을 주의해라.또한 case-insensitive 버전인 icontains가 있다.startswith, endswith각각 Starts-with와 ends-with search이다. 또한 case-insensitive 버전인 istartswith와 iendswith가 있다.다시 말하지만, 이는 오직 표면만 다룬 것이다. 전체 reference는 field lookup reference에서 볼 수 있다.Lookups that span relationshipsDjango는 뒤에서 자동으로 SQL JOINs를 다루면서, lookups에서 relatioships를 “follow”할 수 있는 강력하고 직관적인 방법을 제공한다. relationship을 확장하기 위해, 너가 원하는 field에 도달할 때까지, double underscore으로 분리하여, model 사이의 related fields의 이름을 사용해라.다음 예시는 Blog의 name이 ‘Beatles Blog’인 모든 Entry objects를 받는다:&gt;&gt;&gt; Entry.objects.filter(blog__name='Beatles Blog')이런 확장은 너가 원하는 만큼 깊이 할 수 있다.이는 또한 뒤 방향으로도 진행 가능하다. “reverse” relationship을 참조하고 싶다면, 단지 model의 소문자 이름을 사용해라.다음 예시는 headline이 ‘Lennon’을 포함하고 있는 Entry가 적어도 하나 있는 모든 Blog objects를 받는다:&gt;&gt;&gt; Blog.objects.filter(entry__headline__contains='Lennon')만약 너가 multiple relationships를 가로질러 filtering하고 있고 중간 model이 filter 조건에 맞는 value를 갖고 있지 않다면, Django는 그것을 거기에 마치 유효하지만 비어있는(모든 values가 NULL) object가 있다고 다룰 것이다. 즉, error가 발생하지 않을 것이라는 의미이다. 예를 들어, 다음 filter를 보자:Blog.objects.filter(entry__authors__name='Lennon')(만약, 연관된 Author model이 있고), 만약 한 entry와 연관된 author이 없다면, error를 일으키는 대신에 그것은 연관된 name 또한 없다고 다뤄진다. 보통 이는 너가 원하는 것일 것이다. 헷갈리는 유일한 경우는 만약 너가 isnull을 사용할 경우이다. 즉:Blog.objects.filter(entry__authors__name__isnull=True)은 author에 비어있는 name을 갖고 있는 Blog objects 뿐만 아니라, entry에 비어있는 author을 갖고 있는 Blog objects 또한 반환할 것이다. 만약 너가 후자를 원하지 않는다면 이렇게 써야 한다:Blog.objects.filter(entry__authors__isnull=False,entry__authors__name__isnull=True)Spanning multi-valued relationships이 파트는 글로는 어렵게 써 있지만, 실행 과정과 결과를 보면 당연하다고 여겨질 것이다. 따라서 글이 헷갈리게 써 있더라도 코드를 보면서 읽으면 어렵지 않게 이해할 수 있을 것이다.너가 ManyToManyField 혹은 reverse ForeignKey에 기초하여 object를 filtering할 때, 두 가지 흥미있는 filter의 종류가 있다. Blog/Entry의 relationship을 생각해 보아라(Blog에서 Entry 관계는 one-to-many relationship이다). 우리는 headline에 “Lennon”이 포함되어 있고 2008년에 출판된 entry를 갖고 있는 blog를 찾고 싶을 수 있다. 한 Blog에 연관된 많은 entries가 있기 때문에, 이 두 개의 queries는 모두 사용 가능하고 몇 가지 상황에서 합당하다.ManyToManyField에서도 비슷한 종류의 상황이 발생한다. 예를 들어, Entry가 tags에 ManyToManyField를 갖고 있다면, 우리는 “music”과 “band” tags 에 연결된 entries를 찾고 싶을 수 있고, 아니면 “music” tag와 “public” 상태의 entries를 찾고 싶을 수 있다.이와 같은 상황들을 모두 다루기 위해, Django는 filter() 호출을 가공하는 일관된 방법을 갖고 있다. 하나의 filter()안에 있는 모든 것은 동시에 적용되는데 이런 요구사항에 맞는 모든 items를 filter out하기 위함이다. 연속적인 filter() 호출들은 objects의 집합을 점점 제한하지만, multi-valued relations에서는 앞의 filter() 호출에 의한 objects일 필요 없이 primary model에 연결된 모든 object에게 적용된다.살짝 헷갈리게 들릴 수 있지만, 다음 예시가 명확하게 해주길 바란다. headline에 “Lennon”이 포함되어 있고 2008년에 출판된 entry(두 개의 조건을 모두 만족하는 같은 entry)를 선택하기 위해 우리는 다음과 같이 쓴다:Blog.objects.filter(entry__headline__contains='Lennon', entry__pub_date__year=2008)headline에 “Lennon”을 포함하고 있는 entry 뿐만 아니라 2008년에 출판된 entry도 갖고 있는 모든 blog를 갖기 위해서는 다음과 같이 쓴다:Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)headline에 “Lennon”을 포함하고 있는 entries와 2008년에 나온 entries 둘 다 갖고 있는 blog가 한 개만 있고, “Lennon”을 포함하고 있는 2008년에 나온 entries를 갖고 있는 블로그는 없다고 가정하자. 첫 번째 query는 아무런 blogs를 반환하지 않지만, 두 번째 query는 그 한 개의 blog를 반환한다.두 번째 예시에서 첫 번째 filter는 headline에 “Lennon”을 포함하고 있는 entries와 연결된 blogs의 queryset으로 제한한다. 두 번째 filter는 그 blogs의 집합을 2008년에 출판된 entries도 연결된 blogs들로 더 제한한다. 두 번째 filter에서 선택된 entires는 첫 번째 filter에서 선택된 entries와 같을 수도 있고 같지 않을 수도 있다. 우리는 각 filter statement에서 Blog items를 filtering했지, Entry items를 filtering 하지 않았다.      Note    multi-value relations를 확장한 queries에 대한 filter()의 행동은, 위에 기술된 대로, exclude()와 동일하게 implemented되지 않는다. 대신에, 하나의 exclude() 호출에 있는 조건이 반드시 같은 item를 참조하지는 않는다.    예를 들어, 다음 query는 headline에 “Lennon”을 포함하고 있는 entries와 2008년에 출판된 entries를 모두 갖고 있는 blogs를 exclude할 것이다:      Blog.objects.exclude(  \tentry__headline__contains='Lennon',  \tentry__pub_date__year=2008,  )        그러나, filter()를 사용할 때와는 달리, 이것은 두 개의 조건을 모두 만족시키는 entries에 기초하여 blogs를 제한하지 않는다. 이를 하기 위해서, 즉 “Lennon”을 포함하고 2008년에 출판된 entries를 갖고 있지 않은 모든 blogs를 선택하기 위해서는 다음과 같이 두 개의 query를 만들어야 한다:      Blog.objects.exclude(  \tentry__in=Entry.objects.filter(  \t\theadline__contains='Lennon',  \t\tpub_date__year=2008,  \t),  )      Filters can reference fields on the model지금까지 주어진 모든 예시에서, 우리는 model filed 값을 상수와 비교하는 filter들만 만들었었다. 그러나, 한 field의 값과 같은 model에 있는 다른 field의 값을 비교하고 싶으면 어떡할까?Django는 이와 같은 비교를 가능하게 하기 위해 F expressions를 제공한다. F()의 instances는 query 안에서 model field를 참조하는 역할을 한다. 이 references는 같은 model instance에 있는 다른 두 개의 fields 값들을 비교하기 위해 query filters에서 사용될 수 있다.예를 들어, pingbacks보다 많은 수의 comments를 갖고 있는 blog entries의 list를 찾기 위해, 우리는 pingback 수를 reference하기 위한 F() object를 구성하고, query에서 그 F() object를 사용한다:&gt;&gt;&gt; from django.db.models import F&gt;&gt;&gt; Entry.objects.filter(n_comments__gt=F('n_pingbacks'))Django는 F() objects와 상수들에게 모두 적용 가능한 addition, subtraction, multiplication, division, modulo, 그리고 power arithmetic의 사용을 지원한다. pingbacks보다 두 배 많은 comments를 갖고 있는 모든 blog entries를 찾기 위해, 우리는 다음과 같이 query를 수정한다:&gt;&gt;&gt; Entry.objects.filter(n_comments__gt=F('n_pingbacks')*2)entry의 rating이 pingback 수와 comment 수의 합보다 적은 모든 entries를 찾기 위해, 우리는 다음과 같이 query를 만든다:&gt;&gt;&gt; Entry.objects.filter(rating__lt=F('n_commnets') + F('n_pingbacks'))너는 또한 F() object에서 relationship을 확장하기 위해 double underscore 표기를 사용할 수 있다. double underscore을 갖는 F() object는 연결된 object에 접근할 수 있는 모든 연결을 제공한다. 예를 들어, author의 이름이 blog의 이름과 같은 모든 entries를 받기 위해, 우리는 다음과 같이 query를 만든다:&gt;&gt;&gt; Entry.objects.filter(authors__name=F('blog_name'))date와 date/time fields에 대하여, 너는 timedelta object를 더하거나 뺄 수 있다. 다음은 출판된 후 3일 이상 수정된 모든 entries를 반환한다.&gt;&gt;&gt; from datetime import timedelta&gt;&gt;&gt; Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))F() object는 .bitand(), .bitor(), .bitrightshift(), 그리고 .bitleftshift()와 같은 bitwise operations를 지원한다. 다음과 같이 사용한다:&gt;&gt;&gt; F('somefield').bitand(16)The pk lookup shortcut편의를 위해서, Django는 “primary key”를 나타내는 pk lookup shortcut을 제공한다.Blog model 예시에서, primary key는 id field이기 때문에, 다음과 같은 세 개의 statements가 있다:&gt;&gt;&gt; Blog.objects.get(id__exact=14) # Explicit form&gt;&gt;&gt; Blog.objects.get(id=14) # __exact is implied&gt;&gt;&gt; Blog.objects.get(pk=14) # pk implies id__exactpk의 사용은 __exact queries로 제한되어 있지 않다 - 어떠한 query term이라도 pk와 결합되어 model의 primary key에 대한 query를 진행할 수 있다:# Get blogs entries with id 1, 4 and 7&gt;&gt;&gt; Blog.objects.filter(pk__in=[1,4,7])# Get all blog entries with id &gt; 14&gt;&gt;&gt; Blog.objects.filter(pk__gt=14)pk lookups는 또한 joins에 걸쳐 적용된다. 예를 들어, 다음 세 가지 statements는 동일하다:&gt;&gt;&gt; Entry.objects.filter(blog__id__exact=3) # Explicit form&gt;&gt;&gt; Entry.objects.filter(blog__id=3)        # __exact is implied&gt;&gt;&gt; Entry.objects.filter(blog__pk=3)        # __pk implies __id__exactEscaping percent signs and underscores in LIKE statementsLIKE SQL statements와 같은 field lookups(iexact, contains, icontains, startswith, istartswith, endswith, 그리고 iendswith)는 LIKE statements에서 특별하게 사용되는 문자들을 자동적으로 escape할 것이다 - percent sign과 underscore 문자이다. (LIKE statement에서, percent sign은 multiple character wildcard를, underscore은 single-character wildcard를 의미한다)이것은 작업들을 직관적으로 만들기 위함이고, 추상화 과정에서 새는 부분이 없다. 예를 들어, percent sign을 갖고 있는 모든 요소들을 받기 위해, 어느 다른 문자들처럼 percent sign을 사용해라:&gt;&gt;&gt; Entry.objects.filter(headline__contains='%')Django는 너를 위해 quoting을 신경 써 줄 것이다; 최종 SQL은 이와 비슷하다:SELECT ... WHERE headline LIKE '%\\%%';underscores에 대해서도 똑같이 적용된다. percent sign과 underscore은 너를 위해 투명하게 다뤄질 것이다.Caching and QuerySets각각의 QuerySets은 database access를 최소화하기 위해 cache를 갖고 있다. 이 작업을 이해하고 있는 것은 더 효율적인 코드 작성을 도와줄 것이다.새롭게 생긴 QuerySet의 cache는 비어 있다. QuerySet이 처음으로 evalutate될 때 - 그리고, 그래서, database query가 발생하고 - Django는 query 결과를 QuerySet의 cache에 저장하고 명시적으로 요구 될 때 그 값을 반환한다(e.g. QuerySet이 iterate 되는 경우, 다음 요소). QuerySet의 연속적인 evaluation은 cache된 결과를 재사용 할 것이다.이 caching 동작을 명심해 두어라. 왜냐하면 너가 QuerySets을 정확히 사용하지 않을 경우 해가 될 것이다. 예를 들어, 다음은 두 개의 QuerySets를 만들 것이고, 그들을 evaluate하고 버릴 것이다:&gt;&gt;&gt; print([e.headline for e in Entry.objects.all()])&gt;&gt;&gt; print([e.pub_date for e in Entry.objects.all()])이는 똑같은 database query가 두 번 실행될 것이므로, database 부하가 두 배 될 것을 의미한다. 또한 두 개의 list가 같은 database record를 갖고 있지 않을 가능성도 있다. 왜냐하면 Entry가 두 개의 요청 사이의 몇 초 사이에 추가되거나 삭제될 수 있기 때문이다.이 문제를 피하기 위해, QuerySet을 저장하고 그것을 재사용하라.&gt;&gt;&gt; queryset = Entry.objects.all()&gt;&gt;&gt; print([p.headline for p in queryset]) # Evaluate the query set.&gt;&gt;&gt; print([p.pub_date for p in queryset]) # Re-use the cache from the evaluation.When QuerySets are not cachedQuerySets가 항상 그들의 결과를 cache하는 것은 아니다. queryset의 단지 일부분을 evalutate할 때, cache가 있는지 없는지는 검사되지만, 만약 없을 경우 subsequent query에 의해 반환된 item들은 cache 되지 않는다. 특히, 이것은 array slice나 index를 사용하여 limiting the queryset을 한 것은 cache를 발생하지 않는다는 뜻이다.예를 들어, 특정 index를 qeuryset object에서 반복적으로 얻는 것은 database를 각각 query하게 될 것이다:&gt;&gt;&gt; queryset = Entry.objects.all()&gt;&gt;&gt; print(queryset[5]) # Queries the database&gt;&gt;&gt; print(queryset[5]) # Queries the database again그러나 만약 전체 queryset이 이미 evaluated 되었었다면, cache를 대신 사용할 것이다:&gt;&gt;&gt; [entry for entry in queryset]&gt;&gt;&gt; bool(queryset)&gt;&gt;&gt; entry in queryset&gt;&gt;&gt; list(queryset)      Note    단지 queryset을 출력하는 것은 cache를 발생시키지 않는다. 이것은 왜냐하면 __repr__() 의 호출은 전체 queryset의 slice만 반환할 것이기 때문이다.  Related objects만약 너가 model에 relationship을 정의하고 싶다면(i.e. ForeignKey, OneToOneField, 또는 ManyToManyField), model의 instances는 related object에 접근할 수 있는 편리한 API를 갖고 있다.이 페이지의 맨 위에 있는 model들을 예시로 삼는다면, Entry object인 e는 그것과 연관된 Blog obejct를 blog attribute를 통해서 얻을 수 있다: e.blog.(배후에서 이 기능은 Python descriptors에 의해 구현된다. 이 내용은 사용자에게 중요하지는 않지만 호기심을 유발하기 위해 여기에서 설명한다.)Django는 또한 API accessors를 relationship의 다른 쪽에 생성한다 - related model에서 그 relationship을 정의한 모델로의 link이다. 예를 들어 Blog object b는 모든 related Entry objects의 리스트를 entry_set attribute를 이용하여 접근할 수 있다:b.entry_set.all().One-to-many relationshipsForward만약 model이 ForeignKey를 갖고 있다면, 그 model의 instances는 간단히 그 model의 attribute를 통하여 related (foreign) object에 접근할 수 있다.예시를 보자:&gt;&gt;&gt; e = Entry.objects.get(id=2)&gt;&gt;&gt; e.blog # Returns the related Blog object.너는 foreign-key attribute를 통해 가져오고 설정할 수 있다. 너가 예상한 대로, foreign key의 변화는 save()를 호출하기 전까지 너의 database에 저장되지 않는다. 예시를 보자:&gt;&gt;&gt; e = Entry.objects.get(id=2)&gt;&gt;&gt; e.blog = some_blog&gt;&gt;&gt; e.save()만약 ForeignKey field가 null=True 설정을 갖고 있다면(i.e. 그것이 NULL 값을 허락한다면), 너는 None을 설정하여 relation을 제거할 수 있다. 예시이다:&gt;&gt;&gt; e = Entry.objects.get(id=2)&gt;&gt;&gt; e.blog = None&gt;&gt;&gt; e.save() # \"UPDATE blog_entry SET blog_id = NULL...;\"one-to-many relationships에서 forward access는 related object에 처음 접근할 때 cached된다. 같은 object instance에 있는 foreign key로의 후속 접근들은 cached된다. 예시이다:&gt;&gt;&gt; e = Entry.objects.get(id=2)&gt;&gt;&gt; print(e.blog) # Hits the database to retrieve the associated Blog.&gt;&gt;&gt; print(e.blog) # Doesn't hit the database; use cached version.**select_related() QuerySet** method 모든 one-to-many relationships의 cache를 미리 recursive하게 미리 채운다. 예시이다:&gt;&gt;&gt; e = Entry.objects.selected_related().get(id=2)&gt;&gt;&gt; print(e.blog) # Doesn't hit the database; uses cached version.&gt;&gt;&gt; print(e.blog) # Doesn't hit the database; uses cached version.Following relationships “backward”만약 model이 ForeignKey를 갖고 있다면, foreign-key model의 instances는 첫 번째 model(ForeignKey를 갖고 있는 앞의 model)의 모든 instances를 반환하는 Manager에 접근할 수 있다. 기본적으로, 이 Manager의 이름은 F00_set인데, F00는 source model의 소문자 이름이다. 이 Manager는 QuerySets를 반환하는데, 이것은 위의 “Retrieving objects” 부문에 기술되어 있는 대로 filtered 되고 manipulated 될 수 있다.다음은 예시이다:&gt;&gt;&gt; b = Blog.objects.get(id=1)&gt;&gt;&gt; b.entry_set.all() # Returns all Entry objects related to Blog.# b.entry_set is a Manager that returns QuerySets.&gt;&gt;&gt; b.entry_set.filter(headline__conatains='Lennon')&gt;&gt;&gt; b.entry_set.count()F00_set 이름을 ForeignKey 정의에 있는 related_name parameter를 설정함으로써 override할 수 있다. 예를 들어, 만약 Entry model이 blog = ForeignKey(Blog, on_delete=models.CASCADE, related_name=’entries’)로 바뀌었을 경우, 위의 코드는 다음과 같이 바뀐다:&gt;&gt;&gt; b = Blog.objects.get(id=1)&gt;&gt;&gt; b.entries.all() # Returns all Entry objects related to Blog.# b.entries is a Manager that returns QuerySets.&gt;&gt;&gt; b.entries.filter(headline__contains='Lennon')&gt;&gt;&gt; b.entries.count()Using a custom reverse manager기본적으로 reverse relations로 사용되는 RelatedManager는 해당 model의 default manager의 하위 class이다. 만약 너가 주어진 query에 대하여 다른 manager를 사용하고 싶다면 너는 다음과 같은 syntax를 사용하면 된다:from django.db import modelsclass Entry(models.Model):\t# ...\tobjects = models.Manager() # Default Manager\tentries = EntryManager()   # Custom Managerb = Blog.objects.get(id=1)b.entry_set(manager='entries').all()만약 EntryManager의 해당 get_queryset() method에서 기본 filtering을 수행하면 해당 filtering이 all() 호출에 적용된다.물론, custom reverse manager를 명시하는 것은 너가 그것의 custom method의 사용도 가능하게 한다.b.entry_set(manager='entries').is_published()",
        "url": "/2019/01/18/Making-queries.html"
      }
      ,
    
      "2019-01-14-models-html": {
        "title": "Models",
        "date": "Jan 14, 2019",
        "author": "김선규(Kim,seon-kyu)",
        "category": "",
        "content": "  원본 링크: https://docs.djangoproject.com/en/2.1/topics/db/models/Models모델은 데이터에 대한 하나의, 결정적인 정보입니다. 모델은 필수적인 필드들과 저장하고 있는 데이터들의 행동을 결정합니다. 일반적으로, 각각의 모델은 하나의 데이터베이스 테이블로 매핑됩니다.기초 사항:  각각의 모델은 django.db.models.Model의 하위 파이썬 클래스입니다.  모델 클래스의 각각의 attribute는 데이터베이스 필드를 나타냅니다.  이것들과 함께, 장고는 기본적인 데이터베이스 접근 API를 제공합니다; Making queries참고하십시오.Quick example다음 예시는 first_name과 last_name을 갖고 있는 Person 모델입니다:from django.db import models    class Person(models.Model):    first_name = models.CharField(max_length=30)    last_name = models.CharField(max_length=30)first_name과 last_name은 모델의 필드입니다. 각각의 필드는 클래스 attribute로 구체화되며, 각각의 attribute는 하나의 데이터베이스 칼럼으로 매핑됩니다.위의 Person 모델은 다음과 같은 데이터베이스 테이블을 생성합니다:CREATE TABLE myapp_person (    \"id\" serial NOT NULL PRIMARY KEY,    \"first_name\" varchar(30) NOT NULL,    \"last_name\" varchar(30) NOT NULL);Some technical notes:  테이블의 이름인 myapp_person은 모델 메타데이터로부터 자동적으로 생성되지만, 오버라이드할 수 있습니다. 자세한 사항은 Table names를 참조하십시오.  id 필드는 자동적으로 추가되지만 이 역시 오버라이드할 수 있습니다. Automatic primary key fields를 참조하십시오.  위 예시의 CREATE TABLE은 PostgreSQL 문법으로 쓰여 있는데, 장고가  settings file에 명시된 데이터베이스 백앤드 맞춤 SQL 을 사용한다는 것을 기억하십시오.Using models모델들을 정의한 후, 장고의 settings file을 수정하여 앞으로 그 모델들을 사용할 것이라고 알려주어야 합니다. 이를 위해 INSTALLED_APPS파일에 models.py를 포함하고 있는 모듈의 이름을 추가하십시오.예를 들어, 만약 당신의 애플리케이션의 모델들이 myapp.models 모듈 안에 있다면 (manage.py startapp 명령어를 사용하여 만든 application package structure 안에 있다면), INSTALLED_APPS는 다음과 같습니다:INSTALLED_APPS = [    #...    'myapp',    #...]새로운 앱들을 INSTALLED_APPS에 추가한 뒤, manage.py makemigrations를 이용하여 부분적 migrations를 만든 후, manage.py migrate를 꼭 실행하도록 하십시오.Fields이미 정의된 데이터베이스 필드들의 목록을 아는 것은 모델에서 가장 중요한 부분입니다 (또한 모델에서 신경써야 할 유일한 부분입니다). 필드는 클래스 attirbute에 의해 명시됩니다. clean, save 또는 delete와 같은 모델 API와 필드의 이름이 충돌하지 않도록 주의하십시오.예시 :from django.db import models    class Musician(models.Model):    first_name = models.CharField(max_length=50)    last_name = models.CharField(max_length=50)    instrument = models.CharField(max_length=100)      class Album(models.Model):    artist = models.ForeignKey(Musician, on_delete=models.CASCADE)    name = models.CharField(max_length=100)    release_date = models.DateField()    num_starts = models.IntegerField()Field types모델 안의 각각의 필드는 적당한 Field 클래스 안의 인스턴스여야 합니다. 장고는 다음 몇 가지를 결정하기 위해 필드 클래스 타입들을 사용합니다:  칼럼 타입은 어떤 종류의 데이터베이스를 저장할지 알려 줍니다.(e.g.INTEGER, VARCHAR, TEXT)  디폴트 HTML 위젯은 폼 필드들을 렌더링 할 때 사용됩니다.(e.g. &lt;input type=\"text\"&gt;&lt;select&gt;)  최소한의 유효성검사(minimal validation)는 장고의 admin과 자동적으로 생성되는 폼에서 사용됩니다.장고는 수십 개의 내장 필드 타입들을 갖고 있습니다; 그 전체 목록을 model field reference에서 확인할 수 있다. 만약 장고의 내장 필드가 제 기능을 못 할 경우, 당신만의 필드를 쉽게 작성할 수 있습니다; Writing custom model fields를 참조하십시오.Field options각각의 필드는 해당 필드에 필수 arguments를 갖고 있습니다(model field reference에 표시되어 있습니다). 예를 들어, CharField(그리고 그것의 하위클래스)는 데이터를 저장하는데 사용되는 VARCHAR 데이터베이스 필드의 사이즈를 명시해주는 max_length argument를 필요로 합니다.또한 모든 필드 타입에 적용되는 공통 argument들이 있습니다. 모두 선택적입니다. 이들은 reference에서 전부 설명되어 있지만, 여기에서는 가장 많이 사용하는 몇 가지만 요약을 하겠습니다.  Field options를 참고하시면 좋을 것 같습니다.nullTrue일 경우, 장고는 데이터베이스에 빈 값인 NULL값을 저장할 수 있습니다. 초기 값은 False입니다.blankTrue일 경우, 필드는 빈 칸이 있을 수 있습니다. 초기 값은 False입니다.blank는 null과 다릅니다. null은 database-related인 반면, blank는 validation-related입니다. 만약 필드에서 blank=True라면, form validation은 entry의 비어있는 값을 허락합니다. 만약 필드에서 blank=False라면, 그 필드의 값은 항상 요구됩니다.choices2-tuples로 구성된 iteralbe(e.g. list or tuple)을 이 필드의 choices로 사용할 수 있습니다. 만약 choices가 주어지면, 디폴트 폼 위젯은 기본적인 text field가 아니라 select box가 될 것이고, 주어진 choices로 선택권이 제한될 것입니다.choices list의 예시는 다음과 같습니다:YEAR_IN_SCHOOL_CHOICES = (    \t('FR', 'Freshman'),    \t('SO', 'Sophomore'),    \t('JR', 'Junior'),    \t('SR', 'Senior'),    \t('GR', 'Graduate'),)각각의 튜플의 첫 번째 요소는 데이터베이스에 저장되는 값입니다. 두 번째 요소는 필드의 폼 위젯에 나타나는 값(display value)입니다.모델 인스턴스가 주어졌을 때, choices를 갖고 있는 필드에서 표시되는 값은 get_F00_display() 메소드를 이용하여 알 수 있습니다. 예시를 보십시오:from django.db import models    class Person(models.Model):    SHIRT_SIZES = (        ('S', 'Small'),        ('M', 'Medium'),        ('L', 'Large'),    )    name = models.CharField(max_length=60)    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)&gt;&gt;&gt; p = Person(name=\"Fred Flintsone\", shirt_size='L')&gt;&gt;&gt; p.save()&gt;&gt;&gt; p.shirt_size'L'&gt;&gt;&gt; p.get_shirt_size_display()'Large'default필드의 초기 값 입니다. 하나의 값이나 callable 객체가 될 수 있습니다. 만약 callable하다면 이는 새로운 객체가 생성될 때마다 실행될 것입니다.help_text폼 위젯에 표시될 추가적인 도움말 입니다. 만약 폼에서 해당 필드를 사용하지 않더라도 설명을 표기하는데 유용합니다primary_keyTrue일 경우, 이 필드는 모델의 primary key가 됩니다.만약 모델에서 어떤 필드에도 primary_key=True로 설정해 두지 않았다면, 장고는 자동적으로 primary key로 사용할 IntegerField를 추가합니다. 따라서 이와 같은 기본 primary-key를 오버라이드하고 싶지 않은 이상 어떤 필드에 primary_key=True를 설정할 필요 없습니다. Automatic primary key fields에 더 자세히 기술되어 있습니다.primary key 필드는 읽을 수만 있습니다. 만약 기존 객체의 primary key 값을 변경한다면, 기존 객체 옆에 새로운 객체가 생성될 것입니다. 예시를 보십시오:from django.db import models    class Fruit(models.Model):    name = models.CharField(max_length=100, primary_key=True)&gt;&gt;&gt; fruit = Fruit.objects.create(name='Apple')&gt;&gt;&gt; fruit.name = 'Pear'&gt;&gt;&gt; fruit.save()&gt;&gt;&gt; Fruit.objects.values_list('name', flat=True)&lt;QuerySet ['Apple', 'Pear']&gt;uniqueTrue일 경우, 이 필드는 테이블 전체에서 유일해야 합니다.다시 한 번 말하지만, 이들은 모두 공통된 필드 옵션들에 대한 짧은 설명일 뿐입니다. 자세한 내용은 common model field option reference에 기술되어 있습니다.Automatic primary key fields초기 값으로, 장고는 각각의 모델에 다음과 같은 필드를 생성합니다:id = models.AutoField(primary_key=True)이는 자동적으로 증가하는 (auto-incrementing) primary key입니다.만약 커스텀 primary key를 사용하고 싶다면, 모델의 필드들 중 하나에 primary_key=True를 명시하십시오. 만약 명시적으로 Field.primary_key를 설정 했다면, 장고는 위의 자동적으로 생성된 id 칼럼을 추가하지 않을 것입니다.각각의 모델은 (명시적으로 추가 되었든지 아니면 자동적으로 추가 되었든지간에) 오직 하나의 필드만이 primary_key=True를 갖고 있어야 합니다.Verbose field names  Verbose name을 직역하면 장황한 이름입니다.ForeignKey, ManyToManyField와 OneToOneField를 제외하고, 각각의 필드 타입들은 선택적인 첫 번째 argument로 verbose name을 갖습니다. 만약 verbose name이 주어지지 않았다면, 장고는 자동적으로 필드의 attribute 이름의 언더바를 띄어쓰기로 바꾸어 verbose name을 생성합니다.이 예시에서 verbose name은 “person’s first name“입니다:first_name = models.CharField(\"person's first name\", max_length=30)이 예시에서 verbose name은 “first name“입니다:first_name = models.CharField(max_length=30)ForeignKey, ManyToManyField와 OneToOneField는 첫 번째 argument로 모델 클래스가 필요하기 때문에 verbose_name keyword argument를 사용합니다.poll = models.ForeignKey(    Poll,    on_delete=models.CASCADE,    verbose_name=\"the related poll\",)sites = models.ManyToManyField(Site, verbose_name=\"list of sites\")place = models.OneToOneField(    Place,    on_delete=models.CASCADE,    verbose_name=\"related place\",)관습적으로 verbose_name의 첫 글자는 대문자를 쓰지 않습니다. 장고가 자동적으로 첫 번째 글자를 대문자로 바꾸어주기 때문입니다.Relationships명확하게, 관계형 데이터베이스의 강점은 테이블간에 관계가 있다는 점입니다. 장고는 가장 많이 사용되는 세 가지 데이터베이스 관계를 정의해 줍니다: 다대일, 다대다 그리고 일대일 관계입니다.Many-to-one relationshipsM:1 관계를 정의하기 위해, django.db.models.ForeignKey를 사용합니다. 이것을 다른 필드 타입처럼 사용하면 됩니다: 모델에 클래스 attribute로 추가하십시오.ForeignKey는 정해진 위치의 필수적 argument를 요구합니다: 모델과 관계된 클래스를 지정합니다.예를 들어, Car 모델이 Manufacturer을 갖고 있다면 - 즉, Manufacturer은 다양한 cars를 만들지만 각각의 Car는 단 하나의 Manufacturer를 갖고 있다면 - 다음과 같이 할 수 있습니다:from django.db import models    class Manufacturer(models.Model):    # ...    pass    class Car(models.Model):    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)    # ...또한 재귀적 관계(자기 자신에게 다대일 관계를 갖고 있는 객체)을 만들 수 있고 아직 정의되지 않은 모델과의 관계를 만들 수 있습니다; 자세한 사항은 model field reference를 참고하십시오.필수적인 것은 아니지만, ForeignKey field의 이름(위의 예에서는 manufacturer)은 소문자의 모델 이름을 사용하는 것이 좋습니다. 물론, 원하는 대로 필드 이름을 정해도 됩니다. 예시를 보십시오:class Car(models.Model):    company_that_makes_it = models.ForeignKey(        Manufacturer,        on_delete=models.CASCADE,    )See alsoForeignKey 필드는 model field references에 설명되어 있는 다른 arguements도 사용할 수 있습니다. 이 옵션들은 관계가 어떻게 작동할지를 규정해 줍니다; 모두 선택적입니다.backward-related 객체에 접근하는 방법에 대해서는 Following relationships backward example을 참고하십시오.sample code를 보고 싶다면 Many-to-one relationship model example을 참고하십시오.Many-to-many relationships다대다 관계를 사용하기 위해서는, ManyToManyField를 사용하십시오. 이것을 다른 필드 타입처럼 사용하시면 됩니다: 모델에 클래스 attribute로 추가하십시오.ManyToManyField는 지정된 위치의 필수적 argument를 요구합니다: 관계를 맺을 클래스를 지정합니다.예를 들어, Pizza 가 다양한 Topping 객체를 갖고 있다면 - 즉, 한 Topping이 다양한 pizzas에 있을 수 있고 각각의 Pizza도 다양한 toppings를 가질 수 있다면 - 다음과 같이 이를 나타낼 수 있습니다:from django.db import models    class Topping(models.Model):    # ...    pass    class Pizza(models.Model):    # ...    toppings = models.ManyToManyField(Topping)ForeignKey와 마찬가지로, 재귀적 관계(자기 자신에게 다대다 관계를 갖고 있는 객체)를 만들 수 있고 아직 정의되지 않은 model에게 relationship을 만들 수 있습니다.필수적인 것은 아니지만, 관계된 모델을 나타내는 ManyToManyField의 이름은 복수형을 하는 것이 좋습니다(위 예에서는 toppings).어떤 모델이 ManyToManyField를 갖고 있는지는 상관 없지만, 두 모델 모두가 아니라 한 쪽에만 설정해야 합니다.위의 예시에서는 폼에서 Pizza의 toppings를 선택할 수 있게 해줍니다(Topping이 많은 pizzas를 갖고 있는 것이 아닙니다). 이는 pizza가 많은 topping들이 갖고 있다고 생각하는 것이 topping이 많은 pizza들 위에 있다고 생각하는 것보다 자연스럽기 때문입니다. 이와 같이 일반적으로 ManyToManyField instance는 폼에서 수정되어야 하는 객체 안에 있어야 합니다.See also전체 예시를 보기 위해서는 Many-to-many relationship model example을 참조하십시오.ManyToManyField field는 model field references에 설명되어 있는 다른 arguements도 사용할 수 있습니다. 이 옵션들은 관계가 어떻게 작동할지 규정합니다; 모두 선택적입니다.Extra fields on many-to-many relationshipspizza와 topping과 같은 단순한 many-to-many relationship을 다루고 있다면, ManyToManyField만 사용하시면 됩니다. 하지만, 때때로 relationship이 있는 두 models간의 데이터들을 연결지어야 할 것입니다.예를 들어 musicians이 속해있는 musical group이 있는 경우를 생각해보십시오. 여기에는 person과 그들이 멤버로서 속해있는 group들 간의 many-to-many relationship이 있고, 이 관계를 나타내기 위해 ManyToManyField를 사용할 수 있습니다. 그러나, membership과 관련된 세부 사항들, 예를 들어 person들이 group에 들어간 날짜 등이 많이 있다고 가정합시다.이러한 상황에서, Django에서는 many-to-many relationship을 관리하는 model을 명시할 수 있습니다. 또한 이 intermidate model에 추가적인 field들을 넣을 수 있습니다. 중간 테이블 역할을 할 model을 알려주는  through argument를 이용하여 중간 model은 ManyToManyField와 연결될 수 있습니다. 우리의 musician 예시는 다음 코드와 같이 쓸 수 있습니다:from django.db import models    class Person(models.Model):    name = models.CharField(max_length=128)    \t    def __str__(self):        return self.name    class Group(models.Model):    name = models.CharField(max_length=128)    members = models.ManyToManyField(Person, through='Membership')    \t    def __str__(self):        return self.name    class Membership(models.Model):    person = models.ForeignKey(Person, on_delete=models.CASCADE)    group = models.ForeignKey(Group, on_delete=models.CASCADE)    date_joined = models.DateField()    invite_reason = models.CharField(max_length=64)중간 model을 만들 때는 foreign key를 이용하여 many-to-many relationship에 포함될 model들을 명시적으로 지정해주어야 합니다. 이 명시적 선언은 두 model들이 어떻게 relate되는지 정의합니다.다음은 중간 model에서 몇 가지 제약 사항들입니다:  intermediate model은 source model(우리의 예에서는 Group)로 향하는 foreign key는 단 하나만 갖고 있어야 합니다. 또는 ManyToManyField.through_fields를 사용하여 Django가 relationship을 위해 사용해야 하는 foreign key를 명시적으로 지정해 주어야 합니다. 만약 한 개 이상의 foreign key를 갖고 있거나 through_fields가 명시되어 있지 않으면 validation error가 발생할 것입니다. 비슷한 제약은 target model(우리의 예에서는 Person)에서도 적용됩니다.          through_fields의 내용은 model field reference를 참고해주세요.        중간 model을 이용하여 자기 자신에게 many-to-many relationship을 갖는 model에 대해서는, 같은 model을 향한 두 개의 foreign key가 있을 수 있습니다. 하지만 그들은 many-to-many relationship에서 서로 다른 측면에 있는 것으로 간주됩니다. 만약 두 개 이상의 foreign key가 있다면, 역시 through_fields를 위와 같이 명시해 주어야 validation error가 발생하지 않을 것입니다.  중간 model을 이용하여 자기 자신에게 many-to-many relationship을 정의할 때, symmetrical=False 를 사용해야 합니다(model field reference를 참조하십시오).이제 중간 model(예시의 경우 Membership)을 이용하기 위한 ManyToManyField 준비 작업을 마쳤고, many-to-many relationship을 사용할 준비가 되었습니다. intermediate model의 instances를 만들어 사용할 수 있습니다:&gt;&gt;&gt; ringo = Person.objects.create(name=\"Ringo Starr\")&gt;&gt;&gt; paul = Person.objects.create(name=\"Paul McCartney\")&gt;&gt;&gt; beatles = Group.objects.create(name=\"The Beatles\")&gt;&gt;&gt; m1 = Membership(person=ringo, group=beatles,...\t\t\tdate_joined=date(1962, 8, 16),...\t \t \tinvite_reason=\"Needed a new drummer.\")&gt;&gt;&gt; m1.save()&gt;&gt;&gt; beatles.members.all()&lt;QuerySet [&lt;Person: ringo Starr&gt;]&gt;&gt;&gt;&gt; ringo.group_set.all()&lt;QuerySet [&lt;Group: The Beatles&gt;]&gt;&gt;&gt;&gt; m2 = Membership.objects.create(person=paul, group=beatles,...\t\t\tdate_joined=date(1960, 8, 1),...\t\t\tinvite_reason=\"Wanted to form a band.\")&gt;&gt;&gt; beatles.memebers.all()&lt;QuerySet [&lt;Person: Ringo starr&gt;, &lt;Person: Paul McCartney&gt;]&gt;보통의 many-to-many field과는 다르게, relationship을 만들기 위해서 add(), create(), 또는 set() 을  사용할 수 없습니다.&gt;&gt;&gt; # The following statements will not work&gt;&gt;&gt; beatles.members.add(john)&gt;&gt;&gt; beatles.members.create(name=\"George Harrison\")&gt;&gt;&gt; beatles.members.set([john, paul, ringo, george])왜 그럴까요? 단순히 Person과 Group사이의 relationship을 만들 수 없습니다 - 왜냐하면 Membership model이 필요로 하는 모든 세부 사항들을 명시해 주어야 하기 때문입니다. 단순히 add, create 그리고 assignment call으로는 이러한 추가적인 세부 사항들을 알려줄 방법이 없습니다. 결과적으로, 이들 함수는 중간 model을 이용하는 many-to-many relationship에서 사용 불가능합니다. 이런 종류의 relationship을 만드는 유일한 방법은 intermeidate model의 instance들을 생성하는 것입니다.remove() method도 비슷한 이유로 사용 불가능합니다. 예를 들어, 만약 중간 model의  (model1, model2)의 유일성이 보장되지 않는다면, remove() 호출은 중간 model의 어떤 instance를 삭제해야 하는지 충분한 정보를 제공하지 않기 때문입니다:&gt;&gt;&gt; Membership.objects.create(person=ringo, group=beatles,...\t\t\tdate_joined=date(1968, 9, 4),...\t\t\tinvite_reason=\"You've been gone for a month and we miss you.\")&gt;&gt;&gt; beatles.members.all()&lt;QuerySet [&lt;Person: Ringo Starr&gt;, &lt;Person: Paul McCartney&gt;, &lt;Person: Ringo Starr&gt;]&gt;&gt;&gt;&gt; # This will not work because it cannot tell which membership to remove&gt;&gt;&gt; beatles.members.remove(ringo)그러나 clear() method는 모든 many-to-many relationships의 instance들을 삭제하기 위해 사용할 수 있습니다:&gt;&gt;&gt; # Beatles have broken up&gt;&gt;&gt; beatles.members.clear()&gt;&gt;&gt; # Note that this deletes the intermediate model instances&gt;&gt;&gt; Membership.objects.all()&lt;QuerySet []&gt;일단 중간 model의 instance를 생성하여 many-to-many relationship을 형성했다면, queries를 통해 볼 수 있습니다. 평범한 many-to-many relationship과 마찬가지로, many-to-many로 연결된 model들의 attribute들을 이용하여 query할 수 있습니다.# Find all the groups with a member whose name starts with 'Paul'&gt;&gt;&gt; Group.objects.filter(members__name__startswith='Paul')&lt;QuerySet [&lt;Group: The Beatles&gt;]&gt;또한 중간 model들의 attributes들을 이용하여 query 할 수 있다.# Find all the members of the Beatles that joined after 1 Jan 1961&gt;&gt;&gt; Person.objects.filter(...\t\t\tgroup__name='The Beatles',...\t\t\tmembership__date_joined__gt=date(1961,1,1))&lt;QuerySet [&lt;Person: Ringo Starr]&gt;만약 membership의 정보들에 접근해야 한다면 Membership model을 직접적으로 query 할 수 있습니다:&gt;&gt;&gt; ringos_membership = Membership.objects.get(group=beatles, person=ringo)&gt;&gt;&gt; ringos_membership.date_joineddatetime.date(1962, 8, 16)&gt;&gt;&gt; ringos_membership.invite_reason'Needed a new drummer.'같은 정보에 접근할 수 있는 또 다른 방법은 Person object로부터 many-to-many reverse relationship을 querying하는 것이다.&gt;&gt;&gt; ringos_membership = ringo.membership_set.get(group=beatles)&gt;&gt;&gt; ringos_membership.date_joineddatetime.date(1962, 8, 16)&gt;&gt;&gt; ringos_membership.invite_reason'Needed a new drummer.'One-to-one relationshipsone-to-one relationship을 정의하기 위해, OneToOneField를 사용하십시오. 어느 다른 Field type처럼 이용하면 됩니다: model의 class attribute로 추가하십시오.이것은 한 객체가 다른 객체를 “extends” 하고 있을 때 객체의 primary key에서 사용하면 가장 유용합니다.OneToOneField는 지정된 위치의 필수 argument를 요구합니다: 모델과 relate된 class를 지정합니다.예를 들어, 만약 “places”라는 데이터베이스를 만들고 있다면, address, phone number 등과 같이 평범한 내용들을 데이터 베이스에 포함할 것이다. 그리고 나서, 그 place들 위에 restaurant들의 데이터 베이스를 세우고 싶다면, Restaurant model에 그 fields들을 붙여넣는 것 대신에, Restaurant가 Place로 OneToOneField를 갖게 만들어 주면 됩니다(왜냐하면 reataurant “is a” place이기 때문이다; 사실, 이을 위해 전형적으로 상속을 사용하는데, 이것은 암묵적으로 one-to-one relation을 갖습니다).ForeignKey 와 함께 recursive relationship은 정의될 수 있고 references to as-yet undefined model도 만들어 질 수 있습니다.See also전체 예시를 보기 위해 One-to-one relationship model example을 참고하십시오.OneToOneField는 또한 optional parent_link argument를 사용할 수 있습니다.OneToOneField class들은 자동적으로 model의 primary key에 연결되곤 했습니다. 하지만 더 이상 그렇지 않습니다(직접 primary_key argument들을 넘겨주어도 말입니다). 그러므로, 이제 하나의 model에서 OneToOneField type의 다양한 field를 갖는 것이 가능합니다.Models across files한 model에서 다른 app에 있는 model로 relate를 할 수 있습니다. 이를 위해 당신의 모델이 정의되어 있는 파일 가장 위에 related model을 import해야 합니다. 이후, 필요한 곳 어디든지 그 다른 model class를 참조하면 됩니다. 예를 보십시오:from django.db import modelsfrom geography.models import ZipCode    class Restaurant(models.Model):    # ...    zipe_code = models.ForeignKey(        ZipCode,        on_delete=models.SET_NULL,        blank=True,        null=True,    )Field name restrictionsDjango는 model field 이름에 단 두 가지 제약만이 있습니다.      field name은 Python reserved word가 될 수 없습니다. 왜냐하면 이는 Python syntax error를 발생시킬 것입니다. 예시를 보십시오:     class Example(models.Model):     pass = models.IntegerField() # 'pass' is a reserved word!            field name은 두 개 이상의 underscore을 가질 수 없는데, 이는 Django의 query lookup syntax words이기 때문입니다. 예시를 보십시오:     class Example(models.Model):     foo__bar = models.IntegerField() # 'foo__bar' has two underscores!      이러한 제약 사항들은 피해갈 수 있습니다. 왜냐하면 field name은 database column 이름과 꼭 같을 필요가 없기 때문입니다. db_column option을 참조하십시오.SQL reserved words, 예를 들어 join, where 또는 select는 model field name으로 사용할 수 있는데, 왜냐하면 Django는 기본 SQL query에 있는 모든 database table 이름과 column 이름들을 직접적으로 사용하지 않기 때문입니다. 그것은 너의 특정 database 엔진의 quoting syntax를 사용합니다.Custom field types만약 기존의 model fields들을 목적에 맞게 사용할 수 없다면, 또는 일반적으로 사용되지 않는 database column type을 이용하려면 자체적인 field class를 만들 수 있다. 고유의 field를 만드는 전체 방법은 Writing custom model fields에 나와 있습니다.Meta optionsinner class Meta를 다음과 같이 사용하여 model에게 metadata를 줄 수 있습니다:from django.db import models    class Ox(models.Model):    horn_length = models.IntegerField()           class Meta:        ordering = [\"horn_length\"]        verbose_name_plural = \"oxen\"Model의 metadata는 “field가 아닌 모든 것”입니다. 예를 들어 ordering options(ordering), database table name(db_table), 또는 사람이 읽을 수 있는 복수형 또는 단수형 이름들(verbose_name 그리고 verbose_name_plural)이 있습니다. 모두 필수는 아니고 class Meta를 model에 추가하는 것은 전적으로 optional입니다.Meta option에 대한 전체 목록은 model option reference에서 확인 할 수 있습니다.Model attributesobjectsmodel의 가장 중요한 attribute는 Manager입니다. 이는 interface인데 database query operation들이 이를 통해 Django model로 제공되고 database로부터 retrieve the instances 하는데 사용됩니다. 만약 custom Manager가 정의되지 않는다면, 초기 이름은 objects입니다. Managers은 model instance가 아니라, 단지 model class를 통해서만 접근 할 수 있습니다.Model methods객체를 위한 custom “row-level” 기능을 model에 추가하기 위해 custom method를 정의하십시오. Manager mehods들은 “table-wide” 관련 작업들을 하기 위해 만들어진 반면, model methods는 특정 model instance에 대해 작동합니다.이는 business logic을 한 곳(model)에 유지하기 위한 값진 기술입니다.예를 들어, 다음 model은 몇 개의 custom method를 갖고 있습니다:from django.db import models    class Person(models.Model):    first_name = models.CharField(max_length=50)    last_name = models.CharField(max_length=50)    birth_date = models.DateField()        def baby_boomer_status(self):        \"Returns the person's baby-boomer status.\"        import datetime        if self.birth_date &lt; datetime.date(1945, 8, 1):            return \"Pre-boomer\"        elif self.birth_date &lt; datetime.date(1965, 1, 1):            return \"Baby boomer\"        else:            return \"Post-boomer\"        @property    def full_name(self):        \"Returns the person's full name.\"        return '%s %s' % (self.first_name, self.last_name)이 예시의 마지막 method는 property입니다.model instance reference에는 각각의 model에게 자동적으로 주어진 mothod들의 전체 리스트가 있습니다. 이들을 override할 수 있습니다 - overriding predefined model methods를 참고하십시오 - 그러나 거의 항상 정의해야 할 몇 가지 method들이 있습니다:__str__()모든 object의 문자 표현을 반환하는 Python의 “magic method”이다. model instance가 순수 string으로 표현되어야 할 때마다 Python과 Django이 이를 호출할 것입니다. 제일 알아 두어야 할 것은, 이는 대화형 console이나 admin에 obejct를 표시해야 할 때 일어납니다.항상 이 mothod를 정의하고 싶어할 것입니다; 초기 값이 전혀 도움이 되지 않기 때문입니다.get_absolute_url()이는 Django에게 한 object에 대해 URL을 어떻게 계산할지 알려줍니다. Django는 이를 그것의 admin interface 안에서 사용하거나 한 객체의 URL을 알아내야 할 때 필요합니다.object를 고유하게 식별하는 URL을 가진 object는 이 method를 정의해야 합니다.Overriding predefined model methods데이터 베이스 동작을 encapsulate하고 있는 또 다른 종류의 model method 집합이 있고, 이를 customize하고 싶을 것입니다. 특히 save()와 delete()가 동작하는 방법을 종종 바꾸고 싶을 것입니다.자유롭게 이 methods(그리고 다른 model methods) 역시 override할 수 있고 동작을 바꿀 수 있습니다.내장 method들을 override하는 전형적인 경우는 object를 저장할 때마다 어떤 일이 일어나게 하고 싶을 때 입니다. 예시를 보십시오( save()에서 받아들이는 parameter의 문서를 참조하십시오):from django.db import models    class Blog(models.Model):    name = models.CharField(max_length=100)    tagline = models.TextFeild()        def save(self, *args, **kwargs):        do_something()        super().save(*args, **kwargs)        do_something_else()또한 잘못된 저장을 방지할 수 있습니다:from django.db import models    class Blog(models.Model):    name = models.CharField(max_length=100)    tagline = models.TextField()        def save(self, *args, **kwargs):        if self.name == \"Yoko One's blog\":            return # Yoko shall never have her own blog!        else:            super().save(*args, **kwargs) # Call the \"real\" save() methoddatabase에 object가 저장되는 것을 확실히 하기 위해 superclass의 method를 호출해야 하는 것을 기억하십시오 - 바로 super.save(*args, **kwargs) 입니다. 만약 superclass의 method를 호출하는 것을 잊는다면, default behavior은 발생하지 않을 것이고 database는 변하지 않을 것입니다.또한 model method 에 사용되는 parameter를 전달하는 것이 중요합니다 - 바로 args, **kwargs**들이 그렇게 해줍니다. Django는 수시로 새로운 argument를 추가하면서 내장된 model method 기능들을 확장합니다. 만약 method를 정의할 때 **args, **kwargs를 사용한다면, 당신의 코드는 argument들이 추가될 때 자동적으로 이들을 지원할 것입니다.Overriden model methods are not called on bulk operations   deleting objects in bulk using a QuerySet을 하거나 cascading delete의 결과로 삭제 될 때 객체의 delete() method는 항상 호출되지는 않습니다. customized delete logic이 실행 되었는지 확인하고 싶다면, pre_delete 또는 post_delete를 사용할 수 있습니다.  불행히도 bulk로 객체를 생성하거나 업데이트 할 때는 해결할 수 있는 방법이 없습니다. 왜냐하면 save(), pre_save, 그리고 post_save 그 어느 것도 호출되지 않기 때문입니다.Executing custom SQL다른 일반적인 패턴은 custom SQL statements를 model method와 module-level method에 작성하는 것입니다. raw SQL을 사용하는데 더 세부적인 사항은 using raw SQL 을 참조하십시오.Model inheritanceDjango에서의 model inheritance는 Python에서 일반적인 class inheritance와 거의 동일하게 작동하지만, Introduction-to-models-1의 시작 부분 기초 사항들은 따라야 합니다. 즉, base class 역시 django.db.models.Model의 하위 클래스여야 합니다.당신은 부모 모델이 (자신의 데이터베이스 테이블을 갖고 있는) 고유의 모델이 될 것인지, 아니면 부모 모델이 단지 자식 class들을 통해서만 볼 수 있는 공통된 정보들을 담고 있을 것인지만 결정하면 됩니다.다음은 Django에서 가능한 세 가지 유형의 inheritance입니다.  종종 부모 클래스가 각 하위 모델에 입력하고 싶지 않은 정보들을 보유하기를 원할 것입니다. 이 class는 따로 분리하여 사용하지 않으므로 Abstract base classes 를 보시면 됩니다.  (아마 완전히 다른 application으로 부터) 이미 존재하는 모델을 상속 받기 원하고 각각의 model이 그들의 database table을 갖고 있기를 원하는 경우, Multi-table inheritnace를 살펴보십시오.  마지막으로 model field를 수정하지 않고 단지 model의 Python-level behavior를 수정하기 원하는 경우, Proxy models를 사용할 수 있다.Abstract base classesabstract base classes는 다수의 다른 모델들에게 공통된 정보들을 담고 싶을 때 유용합니다. base class를 작성하고 Meta class에 abstract=True라고 설정하면 됩니다. 그러면 이 모델은 데이터베이스를 만드는데 사용되지 않습니다. 대신에 이것이 다른 모델들을 위한 base class로 사용될 때, 이것의 field들이 child class의 필드에 추가됩니다.다음 예시를 보십시오 :from django.db import models    class CommonInfo(models.Model):    name = models.CharField(max_length=100)    age = models.PositiveIntegerField()        class Meta:            abstract= True    class Student(CommonInfo):    home_group = models.CharField(max_length=5)Student 모델은 세 가지 필드를 갖게 될 것입니다: name, age, 그리고 home_group입니다. CommonInfo 모델은 abstract base class이기 때문에 보통의 장고 모델처럼 사용될 수 없습니다.  이 모델은 데이터베이스 테이블을 생성하지 않고 manager를 갖고 있지 않으며 instantiated 될 수 없고 직접적으로 저장 될 수 없습니다.abstract base classes로부터 상속된 필드들은 또 다른 필드나 값으로 override 할 수 있고 None으로 제거 할 수 있습니다.많은 용도로 이런 종류의 model inheritance 원하실 것입니다. 이것은 Python level에서 공통 정보를 분석하는 방법을 제공하면서 동시에 database level에서는 자식 모델 당 하나의 데이터베이스 테이블을 만듭니다.Meta inheritanceabstract base class가 생성될 때, Django는 base class에서 선언 한 Meta inner class를 attribute로 사용할 수 있게 합니다. 만약 자식 class가 그것 고유의 Meta class를 선언하지 않았을 경우, 그것은 부모의 Meta를 상속받습니다. 만약 자식이 부모의 Meta class를 extend하고 싶다면, 상속받으면 됩니다. 예시를 보십시오:from django.db import models    class CommonInfo(models.Model):    # ...    class Meta:        abstract = True        ordering = ['name']    class Student(CommonInfo):    # ...    class Meta(CommonInfo.Meta):        db_table = 'student_info'Django는 abstract base class의 Meta class에 단 하나의 값을 조정합니다: Meta attribute를 installing하기 전에, abstract=False로 설정합니다. 이것은 abstract base classes의 자식들이 자동적으로 abstract class가 되지 않는다는 것을 의미합니다. 물론, 다른 abstract base class로부터 상속받는 또 다른 abstract base class를 만들 수 있습니다. 매번 명시적으로 abstract=True라고 설정해야 한다는 것을 기억하십시오.몇몇 attribute들은 abstract base class의 Meta class 안에 있기에 부적합합니다. 예를 들어 db_table가  Meta class 안에 있을 경우, (그들 고유의 Meta를 명시하지 않은) 모든 자식 class들이 모두 같은 데치터베이스 테이블을 이용한다는 것인데, 이것은 원하는 작업 아닐 것입니다.Be careful with related_name and related_query_nameForeignKey 또는 ManyToManyField에서 related_name 또는 related_query_name을 사용할 경우, 항상 필드에 대한 unique reverse name과 query name을 반드시 명시해 주어야 합니다. 이것은 보통 abstract base class에서 문제를 유발합니다. 왜냐하면 이 class에 있는 필드들이 각각의 자식 클래스에 포함되는데, 매번 같은 값의 (related_name과 related_query_name을 포함하는) attribute를 갖게 되기 때문입니다..abstract base class에서 related_name 또는 related_query_name을 사용할 때 이 문제를 해결하기 위해서는, value의 일부분이 %(app_label)s와 %(class)s를 포함하고 있어야 합니다.  %(class)s는 필드가 사용되는 자식 class의 소문자 이름으로 대체됩니다.  %(app_label)s는 자식 class가 포함되어 있는 app의 소문자 이름으로 대체됩니다. 각각의 installed applicatoin은 유일하고 app 안에 있는 model class 이름도 유일하기 때문에, 최종 이름은 서로 다르게 될 것입니다.예를 들어 comon/models.py에 다음과 같은 app이 있습니다:from django.db import models    class Base(models.Model):    m2m = models.ManyToManyField(        OtherModel,        related_name=\"%(app_label)s_%(class)s_related\",        related_query_name=\"%(app_label)s_%(class)ss\",    )    \t    class Meta:        abstract = True    class ChildA(Base):    pass    class ChildB(Base):    passrare/models.py에도 다음 app이 있습니다:from common.models import Base    class ChildB(Base):    passcommon.ChildA.m2m 필드의 reverse name은 common_childa_related가 될 것이고 reverse query name은 common_childas가 될 것입니다. common.childB.m2m 필드의 reverse name은 common_childb_related가 될 것이고 reverse query name은 common_chlidbs가 될 것입니다. 마지막으로 rare.ChildB.m2m 필드의 reverse name은 rare_childb_related가 될 것이고 reverse query name은 rare_childbs가 될 것이다. related name이나 related query name을 구성하기 위해 %(class)s와 %(app_label)s 부분들을 어떻게 사용하는지는 당신에게 달려있지만, 이것을 사용하지 않을 경우, Django는 system check(또는 migrate)를 사용할 때 error를 일으킬 것입니다.abstract base class의 필드에 대한 related_name attribute를 명시하지 않은 경우, default reverse name은 child class 이름 뒤에 _set이 붙은 것이 될 것이고, child class에 직접적으로 선언한 것처럼 정상적으로 작동할 것입니다. 예를 들어 위의 코드에서, related_name attribute가 생략 되었다면, m2m 필드의 reverse name은 ChildA의 경우 childa_set이 될 것이고 ChildB의 경우 childb_set이 될 것입니다.Multi-table inheritanceDjango에서 지원하는 두 번째 타입의 model inheritance는 계층 구조의 각 모델이 모두 그것 고유의 모델일 때입니다. 각각의 모델은 그들 고유의 데이터베이스 테이블에 대응되고 독립적으로 queried 되고 생성될 수 있습니다. inheritance relationship은 자식 모델과 그들의 부모 사이의 links를 (자동적으로 생성되는 OneToOneField를 통해서) 줍니다. 예시를 보십시오:from django.db import models    class Place(models.Model):    name = models.CharField(max_length=50)    address = models.CharField(max_length=80)    class Restaurant(Place):    serves_hot_dogs = models.BooleanField(default=False)    serves_pizza = models.BooleanField(default=False)데이터들은 서로 다른 데이터베이스 테이블에 있음에도 불구하고 Place의 모든 필드들은 Restaurant에서도 모두 이용 가능합니다. 따라서 다음 두 가지가 모두 가능합니다:&gt;&gt;&gt; Place.objects.filter(name=\"Bob's Cafe\")&gt;&gt;&gt; Restaurant.objects.filter(name=\"Bob's Cafe\")Restaurant 이기도 한 Place를 갖고 있을 경우, Place 객체로부터 소문자 모델 이름을 이용하여 Restaurant 객체를 얻을 수 있습니다:&gt;&gt;&gt; p = Place.objects.get(id=12)# If p is a Restaurant object, this will give the child class:&gt;&gt;&gt; p.restaurant&lt;Restaurant: ...&gt;그러나 위 예시에서의 p가 Restaurant이 아닐 경우(그것이 Place 객체로부터 직접적으로 생성되었거나 다른 class의 부모였다면), p.restaurant를 호출하는 것은 Restaurant.DoesNotExist exception을 일으킬 것입니다.Restaurant에 자동적으로 생성된 Place로 link해주는 OneToOneField는 다음과 같이 생겼습니다:place_ptr = models.OneToOneField(    Place, on_delete=models.CASCADE,    parent_link=True,)해당 필드를 Restaurant에 parent_link=True 와 함께 고유의 OneToOneField를 선언함으로써 override할 수 있습니다.Meta and multi-table inheritancemulti-table inheritance의 경우에, 자식 class에서 부모의 Meta class를 상속받는 것은 말이 되지 않습니다. 모든 Meta option들은 이미 부모 class에 적용되었고, 그들을 다시 적용하는 것은 보통 모순적인 행동입니다(abstract base class와는 반대인데, base class는 그들 스스로는 존재하지 않습니다).따라서 자식 model은 그들 부모의 Meta class에 접근할 수 없다. 그러나 부모로부터 몇 가지 행동을 상속받는 경우가 있다: 만약 자식이 ordering attribute 또는 get_latest_by attribute를 명시하지 않는다면, 자식은 부모로부터 이들을 상속받을 것이다.만약 부모가 ordering을 갖고 있고 너는 자식이 아무런 ordering을 갖지 않기를 원하면, 명시적으로 사용을 중단 할 수 있다:class ChildModel(ParentModel):\t# ...\tclass Meta:\t\t# Remove parent's ordering effect\t\tordering = []Inheritance and reverse relationsmulti-table inheritance가 자식과 부모를 link하기 위해 암묵적인 OneToOneField를 사용했기 때문에, 위의 예시처럼 부모에서 자식으로 내려가는 것이 가능하다. 하지만, 이는 ForeignKey 와 ManyToManyField의 default related_name 값을 사용해 나간다. 만약 너가 부모의 자식 class에 이런 종류의 relations를 둔다면, 너는 반드시 각각의 field에 related_name attribute를 명시해야 한다. 만약 그렇지 않으면, Django는 validation error를 일으킬 것이다.예를 들어, 위의 Place class 를 다시 사용하여 ManyToManyField를 이용한 다른 자식 class를 만들자:class Supplier(Place):\tcustomers = models.ManyToManyField(Place)다음은 error 결과이다:Reverse query name for 'Supplier.customers'clashes with reverse queryname for 'Supplier.place_ptr'.HINT: Add or Change a related_name argument to the fefinition for'Supplier.customers' or 'Supplier.place_ptr'.다음과 같이 customers field에 related_name을 추가 해주는 것은 error를 해결할 수 있다: models.ManyToManyField(Place, related_name=’provider’).Specifying the parent link field위에서 말했듯이, Django는 너의 자식 class와 그 어떤 non-abstract parent model과 연결해주는 OneToOneField를 자동적으로 생성할 것이다. 만약 다시 부모로 연결해주는 attribute 이름을 제어하고 싶은 경우, 너는 너만의 OneToOneField를 생성하고 너의 field가 부모 class를 다시 가리키도록 parent_link=True라고 설정하면 된다.Proxy modelsmulti-table inheritance를 사용할 때, 새로운 database table은 한 model의 각각의 하위 class에 대해 생긴다. 이는 보통 이상적인 행동인데, 이는 하위 class가 base class에 존재하지 않는 추가적인 data field를 저장할 공간을 필요로 하기 때문이다. 하지만 때때로, 너는 단지 한 model의 Python 동작을 바꾸고 싶을 것이다 - 아마 default manager를 바꾸거나 새로운 method를 추가할 것이다.이는 proxy model inheritance을 위한 것이다: 원래 model에 proxy를 생성하는 것이다. 너는 proxy model의 instances를 생성하고 삭제하고 업데이트 할 수 있으며, 모든 data들은 너가 원래의 (non-proxied) model을 사용하는 것과 같이 저장된다. 차이점은 원래의 것을 변경하지 않고, proxy에서 default model ordering 또는 default manager과 같은 것들을 바꿀 수 있다는 점이다.Proxy model들은 보통의 model들과 같이 선언될 수 있다. 너는 Django에게 Meta class의 proxy attribute을 True로 설정함으로써 알려줄 수 있다.예를 들어, Person model에 method를 추가하고 싶다고 가정하자. 너는 다음과 같이 할 수 있다:from django.db import modelsclass Person(models.Model):\tfirst_name = models.CharField(max_length=30)\tlast_name = models.CharField(max_length=30)class MyPerson(Person):\tclass Meta:\t\tproxy = True\tdef do_something(self):\t\t# ...\t\tpassMyPerson class는 그것의 부모 Person class와 같은 database table에서 작동한다. 특히, 모든 새로운 Person instance들 또한 MyPerson을 통해 접근 가능하고, 반대의 경우도 가능하다:&gt;&gt;&gt; p = Person.objects.create(first_name=\"foobar\")&gt;&gt;&gt; MyPerson.objects.get(first_name=\"foobar\")&lt;MyPerson: foobar&gt;너는 또한 model에서 다른 default ordering을 정의하기 위해 proxy model을 사용할 수 있다. 너는 아마 항상 Person model을 정렬하고 싶지 않을 수 있지만, proxy를 사용할 때 규칙적으로 last_name attribute를 이용하여 정렬할 수 있다. 이것은 쉽다:class OrderedPerson(Person):\tclass Meta:\t\tordering = [\"last_name\"]\t\tproxy = True이제 보통의 Person queries는 정렬되지 않지만, OrderedPerson queries는 last_name에 의해 정렬될 것이다.Proxy model은 보통의 model들과 같은 방법으로 Meta attribute를 상속 받는다.QuerySets still return the model that was requested말하자면, 너가 Person objects를 query 할 때마다 Django가 MyPerson object를 반환하게 하는 방법은 없다. Person objects의 queryset은 그 타입의 objects를 반환할 것이다. proxy objects의 요점은 원래의 Person에 의존적인 코드는 proxy objects를 사용할 것이라는 점과 너 고유의 코드는 너가 추가한 extension들을 사용할 수 있다는 점이다(다른 코드는 그다지 의존적이지 않다). 이는 Person (또는 어떠한 다른) model을 너가 만든 다른 것으로 대체할 수 있는 것이 아니다.Base class restrictionsproxy model은 반드시 하나의non-abstract model class로 부터 상속을 받아야 한다. 너는 여러 개의 non-abstract models로부터 상속받을 수 없는데, 이는 proxy model은 다른 database table에 있는 rows들 간의 어떤 연결도 제공하지 않기 때문이다. abstract model classes이 어떠한 model fields도 정의하지 않았다면, proxy model은 많은 수의 abstract model classes을 상속할 수 있다. 한 proxy model은 공통의 한 non-abstract 부모 class를 공유하고 있는 여러 proxy models로부터 상속 받을 수 있다.Proxy model managers만약 너가 한 proxy model에 어떠한 model manager도 명시하지 않는다면, 그것은 그것의 model parents로부터 managers를 상속한다. 만약 너가 proxy model에 manager를 정의한다면, 그것은 default가 될 것이지만,  부모 classes에 정의된 어떠한 manager도 여전히 사용 가능하다.위의 예시를 이어 가자면, 너는 다음과 같이 Person model을 query할 때 default manager를 바꿀 수 있다:from django.db import modelsclass NewManager(models.Manager):\t# ...\tpassclass MyPerson(Person):\tobjects = NewManager()\tclass Meta:\t\tproxy = True만약 proxy에 이미 존재하는 default를 대체하지 않고 새로운 manager를 추가하고 싶다면, 너는 custom manager 문서에 기술된 방법들을 사용할 수 있다: 새로운 manager를 갖고 있는 base class를 생성한 뒤에 primary base class 이후에 상속 받아라.# Create an abstract class for the new manager.class ExtraManagers(models.Model):\tsecondary = NewManager()\t\tclass Meta:\t\tabstract = Trueclass MyPerson(Person, ExtraManagers):\tclass Meta:\t\tproxy = True너는 이를 자주 필요로 하지는 않을 것이지만, 너가 하고 싶을 때 이는 가능하다.Differences between proxy inheritance and unmanaged modelsproxy model inheritance는 model의 Meta class에 managed attribute를 사용하여 unmanaged model을 생성하는 것과 비슷하게 보인다.조심스럽게 Meta.db_table를 설정하여 너는 기존의 model을 가리고 Python method를 거기에 추가할 수 있는 unmanaged model을 생성할 수 있다. 그러나 변경 작업을 수행하면 두 복사본을 동기화 된 상태로 유지해야 하므로 반복적이고 오류가 발생할 수 있다.다른 한편으로는 proxy model은 proxing 하고 있는 모델과 똑같이 행동하도록 만들어졌다. 그들은 부모 model과 항상 동기화 되어 있는데 그들이 직접적으로 그들의 field와 manager를 상속 받았기 때문이다.일반적인 규칙은 다음과 같다:  만약 기존의 model과 database table을 mirroring하고 기존의 모든 database table column들을 원하지 않는다면, Meta.managed=False를 써라. 이 option은 Django가 제어하지 않는 database view와 table을 modeling 할 때 유용하다.  만약 너가 model의 Python-only 동작을 변경하고 싶지만, 기존 model의 field를 유지하고 싶다면, Meta.proxy=True를 사용해라. 이는 data가 저장될 때 proxy model의 저장소 구조와 정확히 일치하도록 설정된다.Multiple inheritancePython의 하위 class와 마찬가지로, Django model이 여러 개의 부모 model로부터 상속 받는 것이 가능하다. 일반적인 Python name resolution rule이 적용된다는 것을 명심해라. 특정 이름(e.g. Meta)가 나타나는 첫 base class가 사용될 것이다. 예를 들어, 이것은 만약 여러 부모 class가 Meta class를 포함하고 있다면, 첫 번째 것이 사용될 것이며 다른 것들은 모두 무시될 것이다.일반적으로, 너는 다수의 부모로부터 상속 받을 필요가 없다. 일반적으로 유용하게 사용되는 경우는 “mix-in” class를 사용할 때이다: mix-in을 상속하고 있는 모든 class에 특정 추가적 field와 method를 추가하는 것이다. 너의 inheritance hierarchies를 가능한 간단하고 직관적으로 유지하여 특정 정보가 어디로부터 왔는지 헷갈리지 않게 해라.공통된 id primary key field를 갖고 있는 다양한 model로부터 상속을 받는 것은 error를 일으킬 것이다. 올바르게 multiple inheritance를 사용하기 위해, 너는 base model에 명시적으로 AutoField를 쓸 수 있다:class Article(models.Model):\tarticle_id = models.AutoField(primary_key=True)\t...class Book(models.Model):\tbook_id = models.AutoField(primary_key=True)\t...class BookReview(Book, Article):\tpass또는 AutoField를 갖고 있는 공통의 ancestor를 사용해라. 이는 각각의 부모 model에서 공통의 ancestor로의 OneToOneField를 명시적으로 사용하는 것을 요구하는데, 자동으로 생성되고 자식으로부터 상속받는 field들 간의 충돌을 피하기 위해서이다:class Piece(models.Model):\tpassclass Article(Piece):\tarticle_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)\t...class Book(Piece):\tbook_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)\t...class BookReivew(Book, Article):\tpassField name “hiding” is not permitted보통의 Python inheritance에서, 자식 class는 부모 class로부터 어떠한 attribute를 override하는 것이 허용된다. Django에서 이것은 model fields에 대하여 주로 허락되지 않는다. 만약 non-abstract class가 author이라 된 field를 갖고 있다면, 너는 그 base class로부터 상속 받은 다른 class에 author이라 불리는 다른 model field나 attribute를 생성할 수 없다.이 제약은 abstract model로부터 상속 받은 model field에는 적용되지 않는다. 이러한 field들을 다른 field나 값으로 override 할 수 있고, field_nam = None으로 설정하여 제거 할 수 있다.      Warning    model manager는 abstract base class로 부터 상속된다. 상속된 Manager에 의해 참조되는 상속된 field를 override하는 것은 미묘한 bug를 일으킬 수 있다. custom managers and model inheritance를 보아라.        Note    몇몇의 fields들은 model에 추가적인 attribute를 정의한다. 예를 들어 ForeignKey는 field 이름에 _id가 추가된 별도의 attribute를 정의할 뿐만 아니라 related_name 과 relate_query_name 을 foreign model에 정의한다.    이런 추가적인 attributes들은 그것을 정의한 field가 바뀌거나 제거되어 더 이상 추가적인 attribute를 정의하지 않는 이상 override할 수 없다.  부모 model의 field를 override하는 것은 (Model.__init__에서 어떤 field가 initialized 될지를 명시하는) 새로운 instance를 initializing 하는 것과 serialization과 같은 영역에 어려움이 있다. 이것들은 Python class inheritance가 똑같은 방식으로 처리 할 필요가 없는 기능이므로, Django model inheritance와 Python class inheritance는 임의적이지 않다.이런 제약은 단지 Field instances인 attribute에만 적용된다. 보통의 Python attribute는 너가 원한다면 Override할 수 있다. 또한 이것은 Python 이 인식하는 attribute 이름에만 적용된다: 만약 너가 직접 database column 이름을 설정한다면, 너는 mutli-table inheritance의 child와 ancestor model에 나타나는 같은 column name을 가질 수 있다(이들은 서로 다른 database table의 column들이다).Django는 만약 너가 ancestor model에 있는 어떠한 model field를 override하면 FieldError를 일으킬 것이다.Organizing models in a packagemanage.py startapp command는 models.py 파일을 갖고 있는 application 구조를 생성한다. 만약 너가 많은 models을 갖고 있다면, 그들을 다른 파일에 구성하는 것이 효과적일 것이다.이렇게 하기 위해서는 models package를 만들어라. models.py를 삭제하고 myapp/models/ directory를 __init__.py 파일과 너의 models를 저장할 파일들과 함께 만들어라. 너는 model들을 __init__.py 파일에 import 해야 한다.예를 들어, 만약 너가 models directory에 organic.py와 synthetic.py를 갖고 있다면 다음과 같다:myapp/models/init.pyfrom .organic import Personfrom .synthetic import Robotfrom .models import *를 사용하는 것보다 명시적으로 각각의 model을 import하는 것이 namespace를 어질러놓지 않을 수 있고, 코드를 더욱 읽기 쉽게 만들어주며, code analysis tools를 효과적으로 만들어준다.      See also    The Models Reference    model fields, related objects, 그리고 QuerySet을 포함해서 모든 model 관련 API를 다루고 있다.  ",
        "url": "/2019/01/14/Models.html"
      }
      
    
  };
</script>
<script src="/js/lunr.min.js" charset="utf-8"></script>
<script src="/js/search.js" charset="utf-8"></script>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Imformal refs</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Imformal refs</li>
          <li><a href="mailto:omnyx2@gmail.com">omnyx2@gmail.com</a></li>
          <li><a href="mailto:hopsprings2ternal@gmail.com">hopsprings2ternal@gmail.com</a></li>
          <li>
              <div class="middle">
                  <a class="btn" href="https://www.facebook.com/">
                    <i class="fab fa-facebook-f"></i>
                  </a>
                  <a class="btn" href="https://www.twitter.com">
                    <i class="fab fa-twitter"></i>
                  </a>
                  <a class="btn" href="https://www.google.com">
                    <i class="fab fa-google"></i>
                  </a>
                  <a class="btn" href="https://github.com/">
                    <i class="fab fa-github"></i>
                  </a>
                  <a class="btn" href="https://www.youtube.com">
                    <i class="fab fa-youtube"></i>
                  </a>
                </div>
          </li>
        </ul>
      </div>
    
     
      

      <div class="footer-col footer-col-3">
        <p>Imformal django references translation to korean, this project starts from Gangju, South, Korea. GIST college. 
</p>
      </div>
      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
        </ul>
      </div>
    </div>
  </div>

</footer>

    <script id="dsq-count-scr" src="//imformal-refs.disqus.com/count.js" async></script>
  </body>

</html>