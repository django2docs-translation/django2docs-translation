<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Imformal refs</title>
    <description>Imformal django references translation to korean, this project starts from Gangju, South, Korea. GIST college. 
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 30 Mar 2019 14:46:31 +0900</pubDate>
    <lastBuildDate>Sat, 30 Mar 2019 14:46:31 +0900</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>Working With Forms</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;원본 링크: &lt;a href=&quot;https://docs.djangoproject.com/en/2.1/topics/forms/&quot;&gt;https://docs.djangoproject.com/en/2.1/topics/forms/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;working-with-forms&quot;&gt;Working with forms&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;About this Document&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 문서는 웹 폼의 기본 사항과 장고에서 그것을 어떻게 핸들링하는지 소개합니다. 폼 API의 특정 영역에 대한 자세한 내용은 &lt;code class=&quot;highlighter-rouge&quot;&gt;The Forms API&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Form fields&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Form and field validation&lt;/code&gt;을 참고하십시오.&lt;/p&gt;

&lt;p&gt;만약 다른 기능 없이 컨텐츠를 출판하거나 혹은 방문자로부터 아무런 입력을 받지 않아도 되는 웹사이트 혹은 애플리케이션만들지 않는 이상, 당신은 폼의 사용에 대해 이해해야 합니다.&lt;/p&gt;

&lt;p&gt;장고는 사이트 방문자로부터 입력을 받을 수 있는 폼을 만들고, 그것을 처리하고 응답하는 것을 도와주기 위해 다양한 도구와 라이브러리를 제공합니다.&lt;/p&gt;

&lt;h1 id=&quot;html-forms&quot;&gt;HTML forms&lt;/h1&gt;

&lt;p&gt;HTML에서, 폼은 &lt;strong&gt;&amp;lt;form&amp;gt; … &amp;lt;/form&amp;gt;&lt;/strong&gt; 사이의 요소들의 집합입니다. 그리고 폼은 방문자들이 문자를 입력하고, 옵션을 선택하고, 객체나 제어장치 조작 등의 작업을 할 수 있게 해주고, 그 정보들을 서버로 다시 보냅니다.&lt;/p&gt;

&lt;p&gt;이러한 텍스트 인풋 또는 체크박스와 같은 폼 인터페이스 요소들 중 일부는 매우 간단하며 HTML 자체에 내장되어 있습니다. 다른 것들은 더 복잡합니다; 날짜 선택 팝업창이 뜨거나 슬라이더를 이동하거나 제어장치를 조절할 수 있는 인터페이스는 일반적으로 HTML 폼 &lt;strong&gt;&lt;input /&gt;&lt;/strong&gt; 요소뿐만 아니라 JavaScript와 CSS를 이용하여 이러한 효과를 얻습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;input /&gt;&lt;/strong&gt; 요소뿐만 아니라 폼은 다음 두 가지를 지정해야 합니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;어디에&lt;/em&gt;: 사용자 입력에 해당하는 데이터를 반환해야 하는 URL&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;어떻게&lt;/em&gt;: 데이터를 반환하는 HTTP 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어, 장고 admin 로그인 폼에는 몇 가지 &lt;input /&gt; 요소가 포함되어 있습니다: 사용자 이름은 &lt;strong&gt;type=”text”&lt;/strong&gt;, 패스워드는 &lt;strong&gt;type=”password”&lt;/strong&gt;, 로그인 버튼은 &lt;strong&gt;type=”submit”&lt;/strong&gt;입니다. 그것은 또한 사용자가 보지 못하는 숨겨진 텍스트 필드를 포함하고 있는데, 이 필드들은 다음에 무엇을 해야 할지 결정하기 위해 사용합니다.&lt;/p&gt;

&lt;p&gt;또한 폼 데이터는 &lt;strong&gt;&lt;input /&gt;&lt;/strong&gt;의 &lt;strong&gt;action&lt;/strong&gt; attribute에 명시된 URL로 전송되어야 하며 (예를 들어 &lt;strong&gt;/admin/&lt;/strong&gt;), 그리고 &lt;strong&gt;method&lt;/strong&gt; attribute에 명시된 HTTP 방법으로 전송되어야 한다(예를 들어 &lt;strong&gt;post&lt;/strong&gt;)고 브라우저에게 알려주어야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;input type=&quot;submit&quot; value=&quot;Log in&quot; /&gt;&lt;/strong&gt; 요소가 발생할 경우, 데이터는 &lt;strong&gt;/admin/&lt;/strong&gt;으로 전달됩니다.&lt;/p&gt;

&lt;h2 id=&quot;get-and-post&quot;&gt;GET and POST&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt;과 &lt;strong&gt;POST&lt;/strong&gt;만이 폼을 다룰 때 사용되는 HTTP method입니다.&lt;/p&gt;

&lt;p&gt;장고의 로그인 폼은 POST 방식을 이용해 반환되는데, POST 방식은 브라우저가 폼 데이터를 일괄적으로 암호화하여 전송하고, 서버로 전송한 다음 응답을 수신하는 방식입니다.&lt;/p&gt;

&lt;p&gt;GET은 반대로 제출된 데이터를 문자열로 묶고 URL을 구성하는데 사용됩니다. URL에는 데이터 키 값뿐만 아니라 데이터를 전송해야 하는 주소가 포함되어 있습니다. 당신은 이 액션을 장고 문서 검색창에서 확인할 수 있습니다. 이는 &lt;strong&gt;https://docs.djangoproject.com/search/?q=forms&amp;amp;release=1&lt;/strong&gt;와 같은 형식의 URL을 반환합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt;과 &lt;strong&gt;POST&lt;/strong&gt;는 일반적으로 다른 목적으로 사용됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;번역 생략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;djangos-role-in-forms&quot;&gt;Django’s role in forms&lt;/h1&gt;

&lt;p&gt;폼을 처리하는 것은 복잡한 일입니다. 여러 가지 다른 유형의 수많은 데이터 항목이 폼에서 표시되어야 하고, HTML로 렌더링되며, 편리한 인터페이스를 사용하여 편집되고, 서버로 반환되고, 유효성 검사 또는 정리를 한 다음, 저장하거나 추가 처리를 할 수 있는 장고 admin을 고려해보십시오.&lt;/p&gt;

&lt;p&gt;장고의 폼 기능은 이 작업의 상당 부분을 단순화하고 자동화할 수 있으며, 대부분의 프로그래머들이 스스로 작성한 코드로 할 수 있는 것보다 더 안전하게 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;장고는 폼과 관련된 세 개의 뚜렷한 부분을 처리합니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;렌더링 준비를 위해 데이터를 준비하고 reconstruct합니다.&lt;/li&gt;
  &lt;li&gt;데이터에 대한 HTML 폼을 생성합니다.&lt;/li&gt;
  &lt;li&gt;클라이언트로부터 제출된 폼과 데이터를 수신하고 처리합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 모든 것을 수동으로 하는 코드를 쓰는 것은 가능하지만, 장고는 당신을 위해 모든 것을 처리할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;번역 생략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;building-a-form&quot;&gt;Building a form&lt;/h1&gt;

&lt;h2 id=&quot;the-work-that-needs-to-be-done&quot;&gt;The work that needs to be done&lt;/h2&gt;

&lt;p&gt;유저 이름을 얻기 위해 웹 사이트에 간단한 폼을 만들고자 한다고 가정해봅시다. 당신은 템플릿에 다음과 같은 것들이 필요할 것입니다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;form action=&quot;/your-name/&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;label for=&quot;your_name&quot;&amp;gt;Your name: &amp;lt;/label&amp;gt;
    &amp;lt;input id=&quot;your_name&quot; type=&quot;text&quot; name=&quot;your_name&quot; value=&quot;&quot;&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;OK&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 브라우저에게 &lt;strong&gt;POST&lt;/strong&gt; 방법을 사용하여 폼 데이터를 &lt;strong&gt;/your-name/&lt;/strong&gt; URL에 반환하도록 지시합니다. 이것은 “Your name:”의 텍스트 필드를 보여주고, OK라 표시된 버튼을 보여줍니다. 템플릿 context에 &lt;strong&gt;current_name&lt;/strong&gt; 변수가 포함되어 있는 경우, 이 변수는 &lt;strong&gt;your_name&lt;/strong&gt; 필드를 미리 채우는데 사용됩니다.&lt;/p&gt;

&lt;p&gt;HTML 폼을 포함하는 템플릿을 렌더링할 수 있는 뷰가 필요하고, 적절한 경우에 뷰는 &lt;strong&gt;current_name&lt;/strong&gt; 필드를 제공할 수 있어야 합니다.&lt;/p&gt;

&lt;p&gt;폼이 제출될 때, 서버로 전송되는 &lt;strong&gt;POST&lt;/strong&gt; 요청에는 폼 데이터가 포함됩니다.&lt;/p&gt;

&lt;p&gt;이제 요청에서 적절한 키/값 쌍을 찾은 다음 이를 처리하는 &lt;strong&gt;/your-name/&lt;/strong&gt; URL에 해당하는 뷰도 필요합니다.&lt;/p&gt;

&lt;p&gt;이는 매우 간단한 폼입니다. 실제로 폼에서는 수십 개 또는 수백 개의 필드가 포함될 수 있으며, 이 중 많은 필드를 미리 입력할 수 있으며, 사용자가 작업을 마무리하기 전에 편집-제출 사이클을 여러번 거치게 될 것으로 예상할 수 있습니다.&lt;/p&gt;

&lt;p&gt;양식을 제출하기 전이라도 브라우저에서 검증이 필요할 수 있습니다; 사용자가 일정관리에서 날짜 선택 등과 같은 작업을 할 수 있도록 훨씬 더 복잡한 필드를 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;building-a-form-in-django&quot;&gt;Building a form in Django&lt;/h2&gt;

&lt;h3 id=&quot;the-form-class&quot;&gt;The Form class&lt;/h3&gt;

&lt;p&gt;우리는 이미 우리의 HTML 양식이 어떻게 보이길 원하는지 알고 있습니다. 우리의 장고에서 출발점은 다음과 같습니다:&lt;/p&gt;

&lt;p&gt;forms.py&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django import forms

class NameForm(forms.Form):
    your_name = forms.CharField(label='Your name', max_length=100)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이것은 하나의 필드(&lt;strong&gt;your_name&lt;/strong&gt;)을 갖는 &lt;strong&gt;Form&lt;/strong&gt; 클래스를 정의합니다. 우리는 필드에 인간 친화적인 레이블을 적용했고, 이것이 렌더링 되면 **&lt;label&gt;&lt;strong&gt;과 같이 나타날 것입니다. (이 경우, 우리가 지정한 **label&lt;/strong&gt;은 자동으로 생성될 label과 동일합니다.)&lt;/label&gt;&lt;/p&gt;

&lt;p&gt;필드의 최대 허용 길이는 &lt;strong&gt;max_length&lt;/strong&gt;로 정의됩니다. 이는 두 가지 일을 합니다. HMLT &lt;strong&gt;&lt;input /&gt;&lt;/strong&gt;에 &lt;strong&gt;maxlength=”100”&lt;/strong&gt;을 설정합니다. (그래서 브라우저는 유저가 애당초 그 수 이상의 문자를 입력하는 것을 방지해야 합니다). 이것은 또한 장고가 브라우저로부터 폼을 다시 수신할 때, 길이를 검증하는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Form&lt;/strong&gt; 인스턴스는 &lt;strong&gt;is_valid()&lt;/strong&gt; 메소드를 갖고 있고, 이는 그것의 모든 필드에 대해 유효성 검사를 실행합니다. 이 메소드가 호출될 때, 만약 모든 필드가 유효한 데이터를 포함하고 있다면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;True&lt;/strong&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;폼의 데이터를 &lt;strong&gt;cleaned_data&lt;/strong&gt; attribute 안에 위치시킵니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;전체 폼은, 처음에 랜더링 되고 나서 다음과 같이 생겼습니다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;label for=&quot;your_name&quot;&amp;gt;Your name: &amp;lt;/label&amp;gt;
&amp;lt;input id=&quot;your_name&quot; type=&quot;text&quot; name=&quot;your_name&quot; maxlength=&quot;100&quot; required&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이것이 &lt;strong&gt;&amp;lt;form&amp;gt;&lt;/strong&gt; 태그나 submit 버튼이 없다는 것에 유의하십시오. 우리는 이들은 템플릿에서 추가해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;the-view&quot;&gt;The view&lt;/h3&gt;

&lt;p&gt;장고 웹사이트로 다시 전송된 폼 데이터는 일반적으로 폼을 게시한 것과 동일한 뷰에 의해서 처리됩니다. 이것은 우리가 같은 로직의 일부를 재사용 할 수 있게 해줍니다.&lt;/p&gt;

&lt;p&gt;폼을 처리하기 위해서는 폼을 게시하고자 하는 URL의 뷰에서 폼을 인스턴스화 할 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;views.py&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.http import HttpResponseRedirect
from django.shortcuts import render

from .forms import NameForm

def get_name(request):
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = NameForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            # process the data in form.cleaned_data as required
            # ...
            # redirect to a new URL:
            return HttpResponseRedirect('/thanks/')

    # if a GET (or any other method) we'll create a blank form
    else:
        form = NameForm()

    return render(request, 'name.html', {'form': form})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 우리가 &lt;strong&gt;GET&lt;/strong&gt; 요청으로 이 뷰에 도착한다면, 이것은 빈 폼 인스턴스를 생성하고, 그것을 렌더링 할 템플릿 context에 배치할 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;POST&lt;/strong&gt; 요청을 사용해 폼을 제출할 경우, 뷰는 다시 한 번 폼 인스턴스를 만들어 요청 요청으로부터 데이터를 받습니다: &lt;strong&gt;form = NameForm(request.POST)&lt;/strong&gt; 이것은 “binding data to the form” 이라 부르고 이제 그것은 bound된 폼입니다.&lt;/p&gt;

&lt;p&gt;우리는 이 폼의 &lt;strong&gt;is_valid()&lt;/strong&gt; 메서드를 호출합니다; 만약 &lt;strong&gt;True&lt;/strong&gt;가 아니라면, 우리는 폼을 갖고 있는 템플릿으로 되돌아갑니다. 이번에는 폼이 더 이상 비어있지 않으므로 HTML 폼이 이전에 제출한 데이터로 채워져 필요에 따라 편집하고 수정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 is_valid() 가 True라면, 이제 clean_data attribute에서 모든 검증된 폼 데이터를 찾을 수 있습니다. 우리는 이 데이터를 사용하여 데이터베이스를 업데이트하거나 다른 처리를 한 후에 브라우저로 다음 위치를 알려주는 HTTP 리디렉션을 전송할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;the-template&quot;&gt;The template&lt;/h3&gt;

&lt;p&gt;우리의 name.html 템플릿에서 많은 것을 할 필요 없습니다. 가장 간단한 예시입니다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;form action=&quot;/your-name/&quot; method=&quot;post&quot;&amp;gt;
    { csrf_token %}
    
    &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;모든 폼의 필드와 attributes는 장고 템플릿 언어에 의해 &lt;em&gt;**&lt;/em&gt; 인 HTML 마크업 폼으로 생길 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;생략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;more-about-django-form-classes&quot;&gt;More about Django Form classes&lt;/h1&gt;

&lt;p&gt;모든 폼 클래스는 django.forms.Form 또는 django.forms.ModelForm의 하위 클래스입니다. ModelForm은 Form의 하위클래스라고 생각하시면 됩니다. Form과 ModelForm은 실제로 (private) BaseForm 클래스의 공통 기능을 상속하지만, 이 구현의 세부사항은 거의 중요하지 않습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Models and Forms&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;만약 당신의 폼이 장고 모델을 직접 추가하거나 편집하는데 사용될 것이라면, ModelForm은 많은 시간과 노력, 코드를 절약해 줍니다. 왜냐하면 이것은 모델 클래스에서 적절한 필드 및 그 attribute와 함께 폼을 만들 것이기 때문입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bound-and-unbound-form-instances&quot;&gt;Bound and unbound form instances&lt;/h2&gt;

&lt;p&gt;Bound 폼과 unbound 폼을 구분하는 것은 매우 중요합니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;unbound 폼은 그것과 관련된 데이터가 없습니다. 유저에게 렌더링 될 때, 이는 비어 있거나 디폴트 값을 갖고 있습니다.&lt;/li&gt;
  &lt;li&gt;bound 폼은 제출된 데이터를 갖고 있기 때문에, 그 데이터가 유효한지를 말하는데 사용될 수 있습니다. 유효하지 않은 bound 폼이 렌더링 될 때, 이는 유저에게 수정해야 할 데이터를 알려주는 인라인 에러 메세지를 갖고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;폼의 &lt;strong&gt;is_bound&lt;/strong&gt; attribute가 폼이 &lt;strong&gt;bound&lt;/strong&gt;된 데이터를 갖고 있는지 아닌지를 말해줍니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;생략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;working-with-form-templates&quot;&gt;Working with form templates&lt;/h1&gt;

&lt;p&gt;당신의 폼을 템플릿으로 만들기 위해 해야 할 일은 폼 인스턴스를 템플릿 컨텍스트에 배치하는 것입니다. 따라서 폼이 context 안에 있는 &lt;strong&gt;form&lt;/strong&gt;으로부터 호출되었을 경우, &lt;em&gt;**&lt;/em&gt;은 **&lt;label&gt;&lt;strong&gt;과 **&lt;input /&gt;&lt;/strong&gt; 요소를 적절하게 렌더링 합니다.&lt;/label&gt;&lt;/p&gt;

&lt;h2 id=&quot;form-rendering-options&quot;&gt;Form rendering options&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Additional form template furniture&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;폼의 출력은 그것을 감싸고 있는 &amp;lt;form&amp;gt; 태그나, 폼의 submit 제어를 포함하지 않습니다. 이들을 직접 제공해야 합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;**&lt;label&gt;/&lt;input /&gt;** 쌍에 대한 다른 출력 옵션이 있습니다:&lt;/label&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;**은 **&amp;lt;tr&amp;gt;&lt;/strong&gt; 태그로 감싸면서 그들을 렌더링 할 것입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;**는 **&amp;lt;p&amp;gt;&lt;/strong&gt; 태그로 감싸면서 그들을 렌더링 할 것입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;**는 **&amp;lt;li&amp;gt;&lt;/strong&gt; 태그로 감싸면서 그들을 렌더링 할 것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;감싸주는 &lt;strong&gt;&amp;lt;table&amp;gt;&lt;/strong&gt;이나 &lt;strong&gt;&amp;lt;ul&amp;gt;&lt;/strong&gt; 요소를 직접 제공해야 한다는 점에 유의하십시오.&lt;/p&gt;

&lt;p&gt;ContactForm 인스턴스에 대한  출력 입니다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;label for=&quot;id_subject&quot;&amp;gt;Subject:&amp;lt;/label&amp;gt;
    &amp;lt;input id=&quot;id_subject&quot; type=&quot;text&quot; name=&quot;subject&quot; maxlength=&quot;100&quot; required&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;label for=&quot;id_message&quot;&amp;gt;Message:&amp;lt;/label&amp;gt;
    &amp;lt;textarea name=&quot;message&quot; id=&quot;id_message&quot; required&amp;gt;&amp;lt;/textarea&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;label for=&quot;id_sender&quot;&amp;gt;Sender:&amp;lt;/label&amp;gt;
    &amp;lt;input type=&quot;email&quot; name=&quot;sender&quot; id=&quot;id_sender&quot; required&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;label for=&quot;id_cc_myself&quot;&amp;gt;Cc myself:&amp;lt;/label&amp;gt;
    &amp;lt;input type=&quot;checkbox&quot; name=&quot;cc_myself&quot; id=&quot;id_cc_myself&quot;&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;생략&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 10 Mar 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/03/10/Working-with-forms.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/10/Working-with-forms.html</guid>
        
        
      </item>
    
      <item>
        <title>Model Field Reference</title>
        <description>&lt;h1 id=&quot;model-field-referenceh&quot;&gt;Model field referenceh&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;원본 링크: &lt;a href=&quot;https://docs.djangoproject.com/en/2.1/ref/models/fields/&quot;&gt;https://docs.djangoproject.com/en/2.1/ref/models/fields/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 문서는 장고가 제공하는 모든 &lt;code class=&quot;highlighter-rouge&quot;&gt;field options&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;field types&lt;/code&gt;을 포함한 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;&lt;/strong&gt;에 대해 설명하고 있습니다.&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;만약 내장된 field가 작동하지 않으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;django-localflavor&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;documentation&lt;/code&gt;)를 시도해 보십시오. 이는 특별한 국가와 문화에 대해서 갖가지 유용한 code의 조각을 가지고 있습니다.&lt;br /&gt;또한 당신은 쉽게 당신만의 &lt;code class=&quot;highlighter-rouge&quot;&gt;custom model fields&lt;/code&gt;를 만들 수 있습니다.&lt;/p&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;기술적으로, 이런 모델들은 &lt;strong&gt;django.db.models.fields&lt;/strong&gt;에 저장되어 있으나 편리함을 위해 그들은 &lt;strong&gt;django.db.models&lt;/strong&gt;안에 imported 되어있습니다. 기본적인 명명 관습은 &lt;strong&gt;from django.go import models&lt;/strong&gt;를 사용하는 것이며, fields는 **models.&lt;Foo&gt;Field**로 나타나는 것입니다.&lt;/Foo&gt;&lt;/p&gt;

&lt;h1 id=&quot;field-options&quot;&gt;Field options&lt;/h1&gt;

&lt;p&gt;아래의 arguments는 모두 field의 타입들입니다. 모든 것은 선택적입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Field options는 Field type안에 포함되는 설정입니다. 예시: name = CharField(max_length=150, null=False). null은 field option이고, max_length는 필수 arguement입니다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;null&quot;&gt;null&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.null&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;strong&gt;True&lt;/strong&gt;라면, 장고는 데이터 베이스에 비어 있는 값으로 &lt;strong&gt;NULL&lt;/strong&gt;을 저장할 것입니다. 기본적으로 &lt;strong&gt;False&lt;/strong&gt;로 설정 되어있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CharField&lt;/strong&gt; 와 &lt;strong&gt;TextField&lt;/strong&gt;와 같은 문자열 기반 field의 경우는 &lt;strong&gt;null&lt;/strong&gt;의 사용을 피하는 것이 좋습니다. 문자열을 저장하는 field에 &lt;strong&gt;null=True&lt;/strong&gt; 라면, 데이터가 없을 경우 field에는 &lt;strong&gt;NULL&lt;/strong&gt;과 빈 문자열 두 값이 모두 저장될 수 있습니다. 같은 값에 대해 두 가지 가능한 값을 갖는 것은 지양해야 합니다. 장고의 관습은 빈 문자열을 저장하는 것입니다.&lt;/p&gt;

&lt;p&gt;한 가지 예외는 &lt;strong&gt;CharField&lt;/strong&gt;가 &lt;strong&gt;unique=True&lt;/strong&gt;와 &lt;strong&gt;blank=True&lt;/strong&gt;를 전부 가지고 있는 때입니다. 이는 복수의 객체에서 blank value를 저장할 때 &lt;strong&gt;unique&lt;/strong&gt; 조건에 위배되는 것을 피하기 위함입니다. (NULL은 여러 개 가질 수 있고, 빈 문자열은 하나의 값으로 인식되어 unique 때문에 하나만 가질 수 있는 것 같습니다.)&lt;/p&gt;

&lt;p&gt;string-based 와 non-string-based field 에서 forms에 빈값을 넣는 것을 원한다면 &lt;strong&gt;blank=True&lt;/strong&gt;로 설정해 주어야 합니다. &lt;strong&gt;null&lt;/strong&gt; 값은 단지 database storage에 영향을 미치기 때문입니다(&lt;strong&gt;blank&lt;/strong&gt;를 보십시오).&lt;/p&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;Oracle database backend를 사용할 때, &lt;strong&gt;NULL&lt;/strong&gt;은 이 attribute와 상관없이 빈 값을 나타내는 것으로 저장될 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;blank&quot;&gt;blank&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.blank&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;strong&gt;True&lt;/strong&gt; 라면 field는 blank를 허용합니다. 기본적으로 &lt;strong&gt;Flase&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;은 순수하게 database-related 인 반면에 &lt;code class=&quot;highlighter-rouge&quot;&gt;blank&lt;/code&gt;는 validation-related 입니다. 만약 field가 &lt;strong&gt;blank=True&lt;/strong&gt;를 가진다면 form validation은 empty value의 입력을 허용 해줄 것입니다. 만약 field가 &lt;strong&gt;blank=False&lt;/strong&gt; 라면 field는 반드시 채워져야 합니다&lt;/p&gt;

&lt;h2 id=&quot;choices&quot;&gt;choices&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.choices&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;field에 choices로 사용하기 위해서는 두 items의 iterables 이거나 이를 포함하고 있는 iterable이어야 합니다(e.g. [(A, B), (A, B), …]). 만약 choice가 주어진다면, 그들은 &lt;a href=&quot;https://docs.djangoproject.com/en/2.1/ref/models/instances/#validating-objects&quot;&gt;model validation&lt;/a&gt;에 의해 실행되고, text field가 아닌, select box에 선택지가 담긴 기본 위젯 form이 실행 될 것입니다.&lt;/p&gt;

&lt;p&gt;각 튜플에서 첫번째 요소는 model에 저장되는 실질적 값이고, 두 번째 요소(element)는 사람이 읽게 되는 이름입니다. 예시:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;YEAR_IN_SCHOOL_CHOICES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'FR'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Freshman'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'SO'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Sophomore'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'JR'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Junior'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'SR'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Senior'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반적으로 model class 안에 choices를 각 값에 대해서 변함 없게 알맞은 이름을 정의하는 가장 좋은 방법은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FRESHMAN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'FR'&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SOPHOMORE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'SO'&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;JUNIOR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'JR'&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SENIOR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'SR'&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;YEAR_IN_SCHOOL_CHOICES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FRESHMAN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Freshman'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOPHOMORE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Sophomore'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JUNIOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Junior'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SENIOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Senior'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;year_in_school&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;choices&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;YEAR_IN_SCHOOL_CHOICES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FRESHMAN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_upperclass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;year_in_school&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JUNIOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SENIOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;choices list를 model class의 외부에 정의하여 참조하게 할 수 있지만, model class 내부에 각 choice를 정의하는 것은 이것을 사용한 class에 모든 정보를 보관할 수 있다는 장점이 있습니다. 그리고 choices를 쉽게 참조 할 수 있게 합니다.(e.g. &lt;strong&gt;Student&lt;/strong&gt; 모델이 import 된 어느 곳에서라도 &lt;strong&gt;Student.SOPHOMORE&lt;/strong&gt;이 작동할 것입니다)&lt;/p&gt;

&lt;p&gt;사용 가능한 choices를 체계화 하기 위한 목적으로 그룹에 이름을 지을 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MEDIA_CHOICES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Audio'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'vinyl'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Vinyl'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'cd'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'CD'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Video'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'vhs'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'VHS Tape'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'dvd'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'DVD'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'unknown'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Unknown'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;각 tuple의 첫 번째 요소는 그룹을 나타낼 이름입니다. 두 번째 요소는 두 값의 iterable로, 저장되는 값과 사람이 읽을 수 있는 값으로 묶여진 tuple입니다. 하나의 list를 사용하여 그룹화 된 선택지들과 그룹화 되지 않은 선택지들을 합칠 수 있습니다.(예를 들면, 위에서의 unknown option들은 그룹화 되지 않은 선택지입니다)&lt;/p&gt;

&lt;p&gt;choices 을 가진 model field 별로, field의 현재 값에 대응되는 사람에게 보여지는 이름을 받아오는 method를 추가합니다. 더 자세한 것은 database API documentation 안에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_FOO_display()&lt;/code&gt;를 참고하십시오.&lt;/p&gt;

&lt;p&gt;choices는 그 어떤 iterable object로도 받을 수 있다는 것을 기억하십시오. 굳이 list나 tuple 로 구성할 필요가 없습니다. 이것은 choices를 dynamically하게 만들 수 있다는 의미입니다. 어쩌면 choices를 dynamic 하게 만들 방법을 찾아낼 수도 있지만, 아마 적절한 데이터베이스 테이블을 foreignkey와 함께 사용하는 것이 더 좋을 것입니다. choices는 어차피 크게 바꾸지 않을 정적 데이터이기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;default&lt;/strong&gt;로 &lt;strong&gt;blank=False&lt;/strong&gt;가 field에 설정되지 않는 이상 select box label에는 “——————————”가 담겨 제공될 것이다. 이를 override 하기 위해서는 &lt;strong&gt;None&lt;/strong&gt;을 가진 choices tuple을 추가하십시오; e.g. &lt;strong&gt;(None, ‘Your String For Dispay’).&lt;/strong&gt; 대안으로 예를 들어 CharField와 같이 적절한 곳에서는 empty string 대신 &lt;strong&gt;None&lt;/strong&gt;을 자주 쓸 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;db_colum&quot;&gt;db_colum&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.db_column&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;field에 사용할 database column의 이름입니다. 만약 주어지지 않았다면, 장고는 field의 이름을 사용할 것이다.&lt;/p&gt;

&lt;p&gt;만약 database column name 이 SQL reserved word, 또는 파이썬 변수이름에서는 사용할 수 없는 문자열을 포함하고 있어도 - 예를 들어 하이픈 - 장고에서는 사용할 수 있습니다. Django quotes column and table names behind the scenes.&lt;/p&gt;

&lt;h2 id=&quot;db_index&quot;&gt;db_index&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.db_index&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 True 이면 이 field를 위해 database index가 생성될 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;db_tablespaces&quot;&gt;db_tablespaces&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.db_tablespace&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 field가 indexed 되어 있다면, 필드의 index에 대해 사용할 database tablespace의 이름입니다. 기본 값은 프로젝트의 &lt;strong&gt;DEFAULT_INDEX_TABLESPACE&lt;/strong&gt; 설정, 또는 모델의 &lt;strong&gt;db_tablespace&lt;/strong&gt;(설정된 경우)입니다. 만약 backend가 tablespace를 지원하지 않는다면 이 옵션은 무시될 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;default&quot;&gt;default&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.default&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;필드에 대한 기본 값입니다. 이는 한 값이나 callable 객체가 될 수도 있습니다. 만약 callable 객체라면 새로운 객체가 생성될 때마다 호출될 것입니다.&lt;/p&gt;

&lt;p&gt;default는 변경 가능한 객체(model instance, list, set 등)일 수 없으며, 이 객체의 동일한 인스턴스에 대한 참조는 모든 새로운 모델 인스턴스에서 기본 값으로 사용될 것입니다. 대신에, callable로 원하는 default를 wrap할 수 있습니다. 예를 들어, &lt;strong&gt;JSONField&lt;/strong&gt;에 대해 default &lt;strong&gt;dict&lt;/strong&gt;을 명시하고 싶다면, 다음 함수를 사용하십시오
:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contact_default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;email&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;to1@example.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;n&quot;&gt;contact_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FSONField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ContactInfo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contact_default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;default&lt;/strong&gt;와 같은 field option으로 &lt;strong&gt;lamda&lt;/strong&gt;는 사용할 수 없습니다. 왜냐하면 이들은 Migrations로 serialized되지 않기 때문입니다. 해당 설명서를 참고하십시오.&lt;/p&gt;

&lt;p&gt;모델 인스턴스로 매핑하는 &lt;strong&gt;ForeignKey&lt;/strong&gt;와 같은 필드에 대해서는, default는 모델 인스턴스 대신 그들이 참조하는 필드 값(&lt;strong&gt;to_field&lt;/strong&gt;가 설정되지 않은 경우 &lt;strong&gt;pk&lt;/strong&gt;)이어야 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;default 값을 모델을 설정하지 말고, 해당 모델의 primary key인 field로 설정해야 한다는 뜻 같습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;default(기본 값)은 새로운 모델 인스턴스가 생기고, 해당 필드에 대해 값이 주어지지 않을 경우 사용됩니다. 필드가 primary key일 경우, 필드가 None으로 설정되어 있어도 default를 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;editable&quot;&gt;editable&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.editable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;strong&gt;False&lt;/strong&gt;라면, 이 field는 admin이나 &lt;strong&gt;ModelForm&lt;/strong&gt;에서 표시되지 않을 것입니다. 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;validation&lt;/span&gt;&lt;/code&gt;을 생략할 것입니다. 기본적으로 &lt;strong&gt;True&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h2 id=&quot;error_messages&quot;&gt;error_messages&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Fields.error_messages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;error_messages&lt;/strong&gt; arguments는 이 field에서 에러가 발생할 때의 기본 메세지를 override합니다. override하고 싶은 에러에 대한 메세지를 dictionary로 넘겨주십시오.&lt;/p&gt;

&lt;p&gt;에러 메세지의 key는 &lt;strong&gt;null, blank, invalid, invalid_choice, unique,&lt;/strong&gt; 그리고 &lt;strong&gt;unique_for_date&lt;/strong&gt;를 포함합니다. 추가적인 error message의 key들은 Field types 섹션에 각각의 필드에 명시돼 있습니다.&lt;/p&gt;

&lt;p&gt;에러 메세지들은 종종 form으로 전달되지 않습니다. 모델의 error_messages에 대해 고려해야 할 사항에 대한 문서를 참조하십시오.&lt;/p&gt;

&lt;h2 id=&quot;help_text&quot;&gt;help_text&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.help_text&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;폼 위젯(form widget)에 표시될 추가적인 도움말입니다. 만약 폼에서 해당 필드를 사용하지 않는다 하더라도 설명하기에 유용합니다.&lt;/p&gt;

&lt;p&gt;이 값은 자동으로 생성된 폼에서 HTML을 &lt;strong&gt;help_text&lt;/strong&gt;에 원하는 대로 포함할 수 있게 해줍니다. 다음은 예시입니다:&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;help_text=&quot;Please use the following format: &lt;span class=&quot;nt&quot;&gt;&amp;lt;em&amp;gt;&lt;/span&gt;YYYY-MM-DD&lt;span class=&quot;nt&quot;&gt;&amp;lt;/em&amp;gt;&lt;/span&gt;.&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반 텍스트와 &lt;strong&gt;django.utils.html.escape()&lt;/strong&gt;를 사용하여 HTML 특수 문자를 사용하지 않을 수 있습니다. cross-site scripting attack를 피하기 위해서 신뢰할 수 없는 사용자로부터 온 help text를 확실히 escape 해야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;primary_key&quot;&gt;primary_key&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.primary_key&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;True&lt;/strong&gt;라면, 이 필드는 해당 모델에 primary key입니다.&lt;/p&gt;

&lt;p&gt;어떤 모델에도 &lt;strong&gt;primary_key=Ture&lt;/strong&gt;를 설정하지 않았다면, 장고는 자동으로 primary key 역할을 할 &lt;strong&gt;AutoField&lt;/strong&gt;를 추가할 것입니다. 따라서 기본 primary-key behavior을 override하지 않는 이상, &lt;strong&gt;primary_key=Ture&lt;/strong&gt;을 명시할 필요가 없습니다. 자세한 사항은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Automatic primary key fields&lt;/code&gt;를 보십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;primary_key=True&lt;/strong&gt;는 &lt;strong&gt;null=False&lt;/strong&gt;와 &lt;strong&gt;unique=True&lt;/strong&gt;를 암시합니다. 한 객체에 대해서는 하나의 Primary key만 허용됩니다.&lt;/p&gt;

&lt;p&gt;primary key 필드는 읽을 수만 있습니다. 만약 존재하는 객체의 primary key 값을 변경하고 저장한다면, 새로운 객체가 옛날 것 옆에 만들어질 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;unique&quot;&gt;unique&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.unique&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;True&lt;/strong&gt;라면, 이 필드는 테이블 전체에 걸쳐 고유해야 합니다.&lt;/p&gt;

&lt;p&gt;이는 데이터베이스 레벨에서, model validation에 의해 시행됩니다. 만약 unique 필드에 중복된 값의 객체를 저장하려 한다면, &lt;strong&gt;django.db.IntegrityError&lt;/strong&gt;가 모델의 &lt;strong&gt;save()&lt;/strong&gt; method에 의해 발생할 것입니다.&lt;/p&gt;

&lt;p&gt;이 옵션은 &lt;strong&gt;ManyToManyField&lt;/strong&gt;와 &lt;strong&gt;OneToOneField&lt;/strong&gt;를 제외하고 모든 필드에서 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unique&lt;/strong&gt;가 &lt;strong&gt;True&lt;/strong&gt;일 때, &lt;strong&gt;db_index&lt;/strong&gt;를 명시할 필요가 없습니다. 왜냐하면 &lt;strong&gt;unique&lt;/strong&gt;는 index의 생성을 의미합니다.&lt;/p&gt;

&lt;h2 id=&quot;unique_for_date&quot;&gt;unique_for_date&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.unique_for_date&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 필드가 date field 값에 대해 unique하게 하기 위해서 &lt;strong&gt;DateField&lt;/strong&gt; or &lt;strong&gt;DateTimeField&lt;/strong&gt;의 이름으로 이 값을 설정하십시오.&lt;/p&gt;

&lt;p&gt;예를 들어, &lt;strong&gt;unique_for_date=”pub_date”&lt;/strong&gt;를 갖고 있는 &lt;strong&gt;title&lt;/strong&gt; field를 갖고 있다고 가정하면, 장고는 &lt;strong&gt;title&lt;/strong&gt;과 &lt;strong&gt;pub_date&lt;/strong&gt;를 동시에 갖고 있는 레코드의 입력을 허락하지 않을 것입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;pub_date = models.DateField( … )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;title = models.CharField( … , unique_for_date=”pub_date”)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 설정을 &lt;strong&gt;DateTimeField&lt;/strong&gt;를 가리키도록 설정하면, 오직 필드의 날짜 부분만 고려된다는 점을 주의하십시오. 게다가 &lt;strong&gt;USE_TZ&lt;/strong&gt;가 &lt;strong&gt;True&lt;/strong&gt;라면, 객체가 저장될 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;현재 시간대&lt;/code&gt;에서 점검(check)이 수행될 것입니다.&lt;/p&gt;

&lt;p&gt;이는 &lt;strong&gt;Model.validate_unique()&lt;/strong&gt;에 의해 수행되는데, model validation 동안 시행되지만 데이터베이스 레벨에서는 시행되지 않습니다. 만약 &lt;strong&gt;unique_for_date&lt;/strong&gt; 제약 조건이 &lt;strong&gt;ModelForm&lt;/strong&gt;의 일부가 아닌 필드(예: 필드 중 하나가 제외되거나 &lt;strong&gt;editable=False&lt;/strong&gt;)라면, &lt;strong&gt;Model.validate_unique()&lt;/strong&gt;는 해당 제약 조건에 대한 유효성(validation) 검사를 생략합니다.&lt;/p&gt;

&lt;h2 id=&quot;unique_for_month&quot;&gt;unique_for_month&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.unique_for_month&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unique_for_date&lt;/strong&gt;와 비슷하지만, 달(month)에 대해서 고유한 필드를 요구합니다.&lt;/p&gt;

&lt;h2 id=&quot;unique_for_year&quot;&gt;unique_for_year&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.unique_for_year&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unique_for_date&lt;/strong&gt;와 &lt;strong&gt;unique_for_month&lt;/strong&gt;와 비슷합니다.&lt;/p&gt;

&lt;h2 id=&quot;verbose_name&quot;&gt;verbose_name&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.verbose_name&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;해당 필드에 대해 사람이 읽기 쉬운 이름입니다. 만약 verbose name이 주어지지 않는다면, 장고는 자동적으로 field의 attribute 이름에서 undersocre을 띄어쓰기로 바꾸어 사용할 것입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Verbose field names&lt;/code&gt;를 보십시오.&lt;/p&gt;

&lt;h2 id=&quot;validators&quot;&gt;validators&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.validators&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;해당 필드에 대해서 실행할 validator의 list입니다. 자세한 사항은 validator document를 보십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Registering and fetching lookups&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Field&lt;/strong&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;lookup registration API&lt;/code&gt;를 구현했습니다. API를 사용하여 필드 클래스에 사용할 수 있는 lookup과 필드에서 lookup을 가져오는 방법을 customize할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;field-types&quot;&gt;Field types&lt;/h1&gt;

&lt;h2 id=&quot;autofield&quot;&gt;AutoField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; AutoField(&lt;/strong&gt;options)**&lt;/p&gt;

&lt;p&gt;사용 가능한 ID에 따라 자동적으로 증가하는 &lt;strong&gt;IntegerField&lt;/strong&gt; 입니다. 이를 직접적으로 사용할 필요는 없습니다; 만약 primary key를 따로 명시하지 않는다면 자동으로 모델에 추가될 것입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Automatic primary key fields&lt;/code&gt;를 참고하십시오.&lt;/p&gt;

&lt;h2 id=&quot;bigautofield&quot;&gt;BigAutoField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; BigAutoField&lt;em&gt;(**options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;64bit의 정수입니다. 숫자가 &lt;strong&gt;1&lt;/strong&gt;부터 &lt;strong&gt;9223372036854775807&lt;/strong&gt; 까지 증가한다는 점을 제외하고는 &lt;strong&gt;AutoField&lt;/strong&gt;와 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;bigintegerfield&quot;&gt;BigIntegerField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; BigIntegerField(&lt;/strong&gt;&lt;em&gt;options&lt;/em&gt;)**&lt;/p&gt;

&lt;p&gt;64bit의 정수입니다. 숫자가 &lt;strong&gt;-9223372036854775808&lt;/strong&gt;에서 &lt;strong&gt;9223372036854775807&lt;/strong&gt;까지 증가한다는 점을 제외하고는 &lt;strong&gt;IntegerField&lt;/strong&gt;와 같습니다. 이 필드에 대한 기본 폼 위젯은 &lt;strong&gt;TextInput&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h2 id=&quot;binaryfield&quot;&gt;BinaryField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; BinaryField(&lt;em&gt;max_length=None, **options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;원시 바이너리 데이터를 저장하는 필드입니다. &lt;strong&gt;bytes, bytearray, memoryview&lt;/strong&gt;를 할당할 수 있습니다.&lt;/p&gt;

&lt;p&gt;기본적으로 &lt;strong&gt;BinaryField&lt;/strong&gt;는 &lt;strong&gt;eidtable&lt;/strong&gt;을 &lt;strong&gt;False&lt;/strong&gt;로 설정합니다. 이 경우 ModelForm에 추가될 수 없습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Changed in Django 2.1:&lt;/p&gt;

    &lt;p&gt;이전 버전에서는 &lt;strong&gt;editable&lt;/strong&gt;을 &lt;strong&gt;True&lt;/strong&gt;로 설정하는 것이 금지되었습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;BinaryField&lt;/strong&gt;는 추가적인 optional argument를 갖고 있습니다:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BinaryField.max_length&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;필드의 최대 (문자열) 길이입니다. 이는 Django의 validation에서 &lt;strong&gt;MaxLengthValidator&lt;/strong&gt;를 사용하여 검증됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Abusing BinaryField&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;이를 이용하여 데이터베이스 파일을 저장할 수 있다고 생각할 수 있지만, 99%의 경우 그것은 나쁜 디자인이 될 것입니다. 이 필드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;static files&lt;/code&gt; 처리를 위한 대체물이 아닙니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;booleanfield&quot;&gt;BooleanField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; BooleanField(&lt;/strong&gt;&lt;em&gt;options&lt;/em&gt;)**&lt;/p&gt;

&lt;p&gt;true/false 필드입니다.&lt;/p&gt;

&lt;p&gt;이 필드에 대한 기본 폼 위젯은 &lt;strong&gt;CheckboxInput&lt;/strong&gt; 이거나, &lt;strong&gt;null=True&lt;/strong&gt;일 경우 &lt;strong&gt;NullBooleanSelect&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Field.default&lt;/strong&gt;가 설정되지 않는다면 &lt;strong&gt;BooleanField&lt;/strong&gt;의 기본 값은 &lt;strong&gt;None&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Changed in Django 2.1:&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;이전 버전에서는, 이 필드의 &lt;strong&gt;null=True&lt;/strong&gt;가 불가능 했기 때문에 &lt;strong&gt;NullBooleanField&lt;/strong&gt;를 사용해야 했습니다. 이제는 &lt;strong&gt;NullBooleanField&lt;/strong&gt;의 사용을 권하지 않는데, 이 항목은 앞으로의 Django 버전에서 deprecated 될 것이기 때문입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;charfield&quot;&gt;CharField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; CharField(&lt;em&gt;max_length=None, **options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;작은 사이즈에서 큰 사이즈의 문자열 입니다.&lt;/p&gt;

&lt;p&gt;많은 양의 텍스트에 대해서는 &lt;strong&gt;TextField&lt;/strong&gt;를 사용하십시오.&lt;/p&gt;

&lt;p&gt;이 필드에 대한 기본 폼 위젯은 &lt;strong&gt;TextInput&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CharField&lt;/strong&gt;는 하나의 추가적인 필수 argument가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CharField.max_length&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 필드에 대한 최대 (문자열) 길이입니다. 이는 Django의 validation에서 &lt;strong&gt;MaxLengthValidator&lt;/strong&gt;를 사용하여 검증됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;복수의 데이터베이스 backends 에서 가능한 application을 작성하고 있다면, 몇몇의 backend에서는 max_length에 제한이 있다는 것을 아셔야 합니다. 자세한 사항은 &lt;code class=&quot;highlighter-rouge&quot;&gt;database backend notes&lt;/code&gt;를 참고하십시오.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;datefield&quot;&gt;DateField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; DateField(&lt;em&gt;auto_now=False, auto_now_add=False, **options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python &lt;strong&gt;datetime.date&lt;/strong&gt; instance로 표현된 날짜입니다. 몇 가지 추가적인 optional argument가 있습니다:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DateField.auto_now&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;자동적으로 객체가 저장될 때마다 필드를 현재 시간으로 설정합니다. “last-modified” timestamps에 유용합니다. &lt;em&gt;항상&lt;/em&gt; 현재 시간이 사용된다는 것을 기억하십시오; 이는 override 할 수 있는 기본 값이 아닙니다.&lt;/p&gt;

&lt;p&gt;이 필드는 &lt;strong&gt;Model.save()&lt;/strong&gt;를 호출할 때만 자동적으로 업데이트 됩니다. &lt;strong&gt;QuerySet.update()&lt;/strong&gt;와 같이 다른 방법으로 필드를 업데이트 할 때 이 필드는 업데이트 되지 않습니다. 단, 그러한 업데이트에서도 필드에 사용자 지정 값을 받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DateField.auto_now_add&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;객체가 처음 생성될 때 이 필드를 현재 시간으로 설정합니다. 생성에 대한 timestamps에 유용합니다. &lt;em&gt;항상&lt;/em&gt; 현재 시간이 사용된다는 것을 기억하십시오; 이는 override할 수 있는 기본 값이 아닙니다. 따라서 객체를 생성할 때 이 필드에 한 값을 설정해도 그것은 무시될 것입니다. 만약 이 필드를 수정하고 싶다면, &lt;strong&gt;auto_now_add=True&lt;/strong&gt;라고 하는 것 대신에 다음을 설정하십시오:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;DateField&lt;/strong&gt;: from &lt;strong&gt;datetime.date.today()&lt;/strong&gt;, &lt;strong&gt;default=date.today&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DateTimeField&lt;/strong&gt;: from &lt;strong&gt;django.utils.timezone.now()&lt;/strong&gt;, &lt;strong&gt;default=timezone.now&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 필드에 대한 기본 폼 위젯은 &lt;strong&gt;TextInput&lt;/strong&gt;입니다. admin은 Javascript calendar를 추가하고, “Today”에 대한 shortcut을 제공할 것입니다. 추가적인 &lt;strong&gt;invalid_date&lt;/strong&gt; 에러 메세지 key를 포함합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;auto_now_add&lt;/strong&gt;, &lt;strong&gt;auto_now&lt;/strong&gt; 및 &lt;strong&gt;default&lt;/strong&gt;는 상호 배타적입니다. 이 옵션들의 어떠한 조합도 오류를 일으킬 것입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;현재 구현된 대로, &lt;strong&gt;auto_now&lt;/strong&gt; 또는 &lt;strong&gt;auto_now_add&lt;/strong&gt;를 &lt;strong&gt;True&lt;/strong&gt;로 설정하면 필드의 &lt;strong&gt;editable=False&lt;/strong&gt; 그리고 &lt;strong&gt;blank=True&lt;/strong&gt;로 설정됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;auto_now&lt;/strong&gt;와 &lt;strong&gt;auto_now_add&lt;/strong&gt; options는 생성되거나 업데이트 될 때의 default timezone의 date를 항상 사용합니다. 만약 다른 것이 필요하다면, &lt;strong&gt;auto_now&lt;/strong&gt; 또는 &lt;strong&gt;auto_now_add&lt;/strong&gt; 대신에 callable default를 사용하거나 &lt;strong&gt;save()&lt;/strong&gt;를 override하는 것을 고려해 보십시오; 또는 &lt;strong&gt;DateField&lt;/strong&gt; 대신에 &lt;strong&gt;DateTimeField&lt;/strong&gt;를 사용하고 디스플레이 시간에 Datetime에서 date로 변환을 처리하는 방법을 결정하십시오. ㅋ&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;datetimefield&quot;&gt;DateTimeField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; DateTimeField(&lt;em&gt;auto_now=False, auto_now_add=False, **options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python &lt;strong&gt;datetime.datetime&lt;/strong&gt; instance로 나타낸 날짜와 시간입니다. &lt;strong&gt;DateField&lt;/strong&gt;와 같은 추가적인 arguments를 갖고 있습니다.&lt;/p&gt;

&lt;p&gt;기본적인 폼 위젯은 single &lt;strong&gt;TextInput&lt;/strong&gt;입니다. admin은 Javascript shortcust와 함께 분리된 두 개의 &lt;strong&gt;TextInput&lt;/strong&gt; 위젯을 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;decimalfield&quot;&gt;DecimalField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; DecimalField(&lt;em&gt;max_digits=None, deciaml_places=None, **options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python &lt;strong&gt;Decimal&lt;/strong&gt; instance로 나타낸 고정 소수점 숫자입니다. 이는 &lt;strong&gt;DecimalValidator&lt;/strong&gt;를 사용하여 입력을 검증합니다.&lt;/p&gt;

&lt;p&gt;두 개의 필수 arguments를 갖고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DecimalField.max_digits&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;숫자에 허용되는 최대 자릿수입니다. 이 값은 &lt;strong&gt;decimal_places&lt;/strong&gt;보다 크거나 같아야 한다는 점에 유의하십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DecimalField.decimal_places&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;숫자의 소수점 아래 자릿수 입니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 999를 소수점 아래 2자리까지 나타내기 위해서 다음과 같이 사용합니다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;models.DecimalField(..., max_digits=5, decimal_places=2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;약 10억의 수를 소수점 아래 10자리까지 나타내기 위해서 다음과 같이 사용합니다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;models.DecimalField(..., max_digits=19, decimal_places=10)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 필드의 기본 폼 위젯은 &lt;strong&gt;localize&lt;/strong&gt;가 &lt;strong&gt;False&lt;/strong&gt;일 때 &lt;strong&gt;NumberInput&lt;/strong&gt;이고 그렇지 않으면 &lt;strong&gt;TextInput&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;FloatField&lt;/strong&gt;와 &lt;strong&gt;DecimalField&lt;/strong&gt; classes 사이의 차이점에 대한 정보는 FloatField vs DecimalField를 참고하십시오.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;duration-field&quot;&gt;Duration Field&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; DurationField(&lt;/strong&gt;&lt;em&gt;options&lt;/em&gt;)**&lt;/p&gt;

&lt;p&gt;Python &lt;strong&gt;timedelta&lt;/strong&gt;의해 모델링 된 시간의 기간을 저장하는 필드입니다. PostgreSQL에서 사용될 경우, 데이터 타입은 &lt;strong&gt;interval&lt;/strong&gt;이며 Oracle에서 사용될 경우 &lt;strong&gt;INTERVAL DAY(9) TO SECOND(6)&lt;/strong&gt;입니다. 그렇지 않으면 microseconds의 &lt;strong&gt;bigint&lt;/strong&gt;가 사용됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;대부분의 경우 &lt;strong&gt;DurationField&lt;/strong&gt;와 관련된 산술은 작동합니다. 그러나 PostgreSQL이외의 모든 데이터베이스에서 &lt;strong&gt;DurationField&lt;/strong&gt;의 값과 &lt;strong&gt;DateTimeField&lt;/strong&gt; instance의 산술 값(숫자)을 비교하는 것은 작동하지 않을 것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;emailfield&quot;&gt;EmailField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; EmailField(&lt;em&gt;max_length=254, **options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EmailValidator&lt;/strong&gt;를 사용하여 유효한 이메일 주소인지 확인하는 &lt;strong&gt;Charfield&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h2 id=&quot;filefield&quot;&gt;FileField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; FileField(&lt;em&gt;upload_to=None, max_length=100, **options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;파일을 업로드하는 필드입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;primary_key&lt;/strong&gt; argument를 지원하지 않으며, 사용시 에러가 발생합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두 가지 optional argument가 있습니다:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FileField.upload_to&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 attribute는 업로드 디렉토리와 파일 이름을 설정하는 방법을 제공하며, 두 가지 방법으로 설정할 수 있습니다. 두 경우 모두 그 값이 &lt;strong&gt;Storage.save()&lt;/strong&gt; method로 전달됩니다.&lt;/p&gt;

&lt;p&gt;문자열 값을 명시할 경우, 파일 업로드 할 때의 날짜/시간으로 대체되는 &lt;strong&gt;strftime()&lt;/strong&gt; formatting을 포함할 수 있습니다. 예시를 보십시오:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyModel(models.Model):
    # file will be uploaded to MEDIA_ROOT/uploads
    upload = models.FileField(upload_to='uploads/')
    # or...
    # file will be saved to MEDIA_ROOT/uploads/2015/01/30
    upload = models.FileField(upload_to='uploads/%Y/%m/%d/')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기본 &lt;strong&gt;FileSystemStorage&lt;/strong&gt;를 사용하는 경우, 문자열 값은 &lt;strong&gt;MEDIA_ROOT&lt;/strong&gt; 경로에 추가되어 업로드 된 파일이 저장될 로컬 파일 시스템의 위치를 형성합니다. 다른 저장소를 사용하는 경우, 해당 저장소의 설명서를 확인하여 &lt;strong&gt;upload_to&lt;/strong&gt;를 처리하는 방법을 확인하십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;upload_to&lt;/strong&gt;는 함수와 같은 callable일 수 있습니다. 이것은 파일 이름을 포함한 업로드 경로를 얻기 위해 호출될 것입니다. 이 callable은 두 개의 arguments를 받아들이며 저장소 시스템에 전달될 (forward slashes를 갖고 있는) 유닉스 스타일의 경로를 반환해야 합니다. 두 개의 arguments는 다음과 같습니다:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;./-0243efdd-7bc7-49a1-9ae5-00d8b3fca68f.csv&quot;&gt;Untitled&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;예시를 보십시오:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def user_directory_path(instance, filename):
    # file will be uploaded to MEDIA_ROOT/user_&amp;lt;id&amp;gt;/&amp;lt;filename&amp;gt;
    return 'user_{0}/{1}'.format(instance.user.id, filename)

class MyModel(models.Model):
    upload = models.FileField(upload_to=user_directory_path)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;FileField.storage&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;파일 저장 및 검색을 처리하는 저장소 객체입니다. 이 객체 제공하는 방법에 대한 자세한 내용은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Managing files&lt;/code&gt;를 보십시오.&lt;/p&gt;

&lt;p&gt;이 필드에 대한 기본 폼 위젯은 &lt;strong&gt;ClearableFileInput&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;모델에서 &lt;strong&gt;FileField&lt;/strong&gt; 또는 &lt;strong&gt;ImageField&lt;/strong&gt;(아래를 보십시오)를 사용하기 위해서는 몇 가지 단계가 필요합니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;당신의 settings file에서, Django가 업로드 된 파일들을 저장하기 원하는 디렉토리의 전체 경로로서 &lt;strong&gt;MEDIA_ROOT&lt;/strong&gt;를 정의해야 합니다. (성능을 위해서 이 파일들은 데이터베이스에 저장되지 않습니다.) 해당 디렉토리의 base public URL로서 &lt;strong&gt;MEDIA_URL&lt;/strong&gt;을 정의하십시오. 웹 서버의 사용자 계정이 이 디렉토리에 쓰기가 가능한지 확인하십시오.&lt;/li&gt;
  &lt;li&gt;모델에 &lt;strong&gt;FileField&lt;/strong&gt; 또는 &lt;strong&gt;ImageField&lt;/strong&gt;를 추가하십시오. 그리고 업로드 된 파일에 사용할 서브 디렉토리를 명시하기 위해 &lt;strong&gt;upload_to&lt;/strong&gt; 옵션을 정의하십시오.&lt;/li&gt;
  &lt;li&gt;데이터 베이스에 저장될 모든 것은 (&lt;strong&gt;MEDIA_ROOT&lt;/strong&gt;와 관련된) 파일에 대한 경로입니다. 아마 Django가 제공하는 편리한 &lt;strong&gt;url&lt;/strong&gt; attribute를 사용하고 싶을 것입니다. 예를 들어, &lt;strong&gt;mug_shot&lt;/strong&gt;이라 불리는 &lt;strong&gt;ImageField&lt;/strong&gt;의 경우, 다음과 같은 템플릿을 이용하여 절대 경로를 얻을 수 있습니다: &lt;em&gt;**&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;예를 들어, 당신의 &lt;strong&gt;MEDIA_ROOT&lt;/strong&gt; 가 ‘&lt;strong&gt;/home/media’&lt;/strong&gt;로 설정되어 있고, &lt;strong&gt;upload_to&lt;/strong&gt;가 &lt;strong&gt;‘photos/%Y/%m/%d’&lt;/strong&gt; 로 설정되어 있다고 가정합시다. &lt;strong&gt;upload_to&lt;/strong&gt;의 &lt;strong&gt;%Y/%m/%d’&lt;/strong&gt; 부분은 &lt;strong&gt;strftime()&lt;/strong&gt; 포맷입니다; &lt;strong&gt;‘%Y’&lt;/strong&gt;는 네 자리의 ‘연도’, &lt;strong&gt;‘%m’&lt;/strong&gt;은 두 자리의 ‘월’, &lt;strong&gt;‘%d’&lt;/strong&gt;은 두 자리의 ‘일’입니다. 2007년 1월 15일에 파일을 업로드 할 경우, &lt;strong&gt;/home/media/photos/2007/01/15&lt;/strong&gt;의 경로에 저장됩니다.&lt;/p&gt;

&lt;p&gt;업로드한 파일의 디스크에 있는 파일 이름 또는 크기를 얻으려면, 각각의 &lt;strong&gt;name&lt;/strong&gt;과 &lt;strong&gt;size&lt;/strong&gt; attributes를 사용할 수 있습니다; 사용 가능한 attributes와 methods에 대한 자세한 설명은 &lt;strong&gt;File&lt;/strong&gt; class를 참조하시고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Managing files&lt;/code&gt; 가이드를 살펴보십시오.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;파일을 저장하는 것은 데이터베이스에 모델을 저장하는 것의 한 부분이기 때문에, 디스크에서 사용될 실제 파일 이름은 모델이 저장된 후에야 사용할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;업로드한 파일의 relative URL은 &lt;strong&gt;url&lt;/strong&gt; attirbute를 사용하여 얻을 수 있습니다. 이는 내부적으로 &lt;strong&gt;Storage&lt;/strong&gt; class의 &lt;strong&gt;url()&lt;/strong&gt; method를 호출합니다.&lt;/p&gt;

&lt;p&gt;보안상의 허점을 피하기 위해서는 업로드한 파일들을 처리할 때마다 그들의 업로드 위치와 파일 형식에 세심한 주의를 기울여야 합니다. 업로드 된 모든 파일의 유효성 검사를 진행하여 파일이 당신이 생각하는 그대로 있는지 확인하십시오. 예를 들어, 유효성 검사 없이 다른 사용자들이 당신의 웹 서버 document root안의 디렉토리에 파일을 업로드하게 한다면, 누군가가 당신의 사이트의 URL을 방문해서 CGI나 PHP 스크립트를 업로드하고 그 스크립트를 실행할 수 있게 됩니다. 이를 허용하지 마십시오.&lt;/p&gt;

&lt;p&gt;또한 업로드한 HTML 파일들도 (서버를 통해서가 아니라) 브라우저에 의해 실행될 수 있기 때문에, XSS 또는 CSRF 공격에 준하는 보안 위협을 가할 수 있다는 점에 주의하십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FileField&lt;/strong&gt; instance는 기본 최대 길이(default maximum length)가 100자인 &lt;strong&gt;varchar&lt;/strong&gt; column으로서 데이터베이스에 생성됩니다. 다른 필드와 마찬가지로 &lt;strong&gt;max_length&lt;/strong&gt; argument를 사용하여 이를 바꿀 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;filefield-and-fieldfile&quot;&gt;FileField and FieldFile&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; FieldFile&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;모델의 &lt;strong&gt;FileField&lt;/strong&gt;에 엑세스할 때, 기본 파일에 엑세스하기 위한 proxy로서 &lt;strong&gt;FieldFile&lt;/strong&gt; instance가 주어집니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FieldFile&lt;/strong&gt;의 API는 &lt;strong&gt;File&lt;/strong&gt;의 API을 반영하지만, 한 개의 주요 차이가 있습니다; 클래스에 의해 wrap 된 object가 반드시 Python의 built-in file object의 wrapper는 아닙니다. 대신, &lt;strong&gt;Storage.open()&lt;/strong&gt; method의 결과로 둘러싸인 wrapper인데, 이는 &lt;strong&gt;File&lt;/strong&gt; object일 수 있고 또는 &lt;strong&gt;File&lt;/strong&gt; API의 custom storage’s implementation일 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;File&lt;/strong&gt;에서 상속받은 &lt;strong&gt;read(), write()&lt;/strong&gt;와 같은 API 이외에도, &lt;strong&gt;FieldFile&lt;/strong&gt;은 기본 파일들과 상호작용할 수 있는 몇 가지 methods가 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;이 클래스의 두 methods인 &lt;strong&gt;save()&lt;/strong&gt;와 &lt;strong&gt;delete()&lt;/strong&gt;는 데이터베이스에 &lt;strong&gt;FieldFile&lt;/strong&gt;과 연관된 모델 개체를 저장하는데 기본적으로 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;FieldFile.name&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;관련 FileField의 Storage의 root로부터의 상대 경로를 포함한 파일 이름.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FieldFile.url&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;기본 &lt;strong&gt;Stroage&lt;/strong&gt; class의 &lt;strong&gt;url()&lt;/strong&gt; method를 호출하여 파일의 상대적 URL에 엑세스하는 읽기 전용 속성.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FieldFile.open(&lt;em&gt;mode=’rb’&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;특정 &lt;strong&gt;mode&lt;/strong&gt;로 이 instance와 관련된 파일을 열거나 다시 열어줍니다. 표준 Python &lt;strong&gt;open()&lt;/strong&gt; method와 달리, 이는 파일 설명자를 반환하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FieldFile.close()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python &lt;strong&gt;file.close()&lt;/strong&gt;와 같이 작동하며 이 instance와 관련된 파일을 닫습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FieldFile.save(&lt;em&gt;name, content, save=True&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 method는 파일 이름과 내용을 인자로 받으며 이들을 필드에 대한 storage class로 전달합니다. 그리고 저장된 파일과 모델 필드를 연결 짓습니다. 모델의 &lt;strong&gt;FileField&lt;/strong&gt; instance와 직접 파일 데이터를 연결하고 싶은 경우, &lt;strong&gt;save()&lt;/strong&gt; method를 사용하여 해당 파일 데이터를 유지하십시오.&lt;/p&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;h2 id=&quot;floatfield&quot;&gt;FloatField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; FloatField(&lt;/strong&gt;&lt;em&gt;options&lt;/em&gt;)**&lt;/p&gt;

&lt;p&gt;Python &lt;strong&gt;float&lt;/strong&gt; instance에 의해 표현된 부동소수점입니다.&lt;/p&gt;

&lt;p&gt;이 필드의 기본 폼 위젯은 &lt;strong&gt;localize&lt;/strong&gt;가 &lt;strong&gt;False&lt;/strong&gt;일 경우 &lt;strong&gt;NumberInput&lt;/strong&gt;이고 아닐 경우 &lt;strong&gt;TextInput&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FloatField vs. DecimalField&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;FloatField&lt;/strong&gt; class는 가끔 &lt;strong&gt;DecimalField&lt;/strong&gt; class와 혼용됩니다. 이들 모두 실수를 나타내지만, 그들은 다르게 숫자를 표현합니다. &lt;strong&gt;FloatField&lt;/strong&gt;는 내부적으로 Python의 &lt;strong&gt;float&lt;/strong&gt; type을 사용하는 반면, &lt;strong&gt;DecimalField&lt;/strong&gt;는 Python의 &lt;strong&gt;Decimal&lt;/strong&gt; type을 사용합니다. 더 자세한 차이를 알고 싶다면, &lt;strong&gt;decimal&lt;/strong&gt; module에 대한 Python documentation을 보십시오.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;imagefield&quot;&gt;ImageField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; ImageField(&lt;em&gt;upload_to=None, height_field=None, width_field=None, max_length=100, **options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;h2 id=&quot;integerfield&quot;&gt;IntegerField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; IntegerField(&lt;/strong&gt;&lt;em&gt;options&lt;/em&gt;)**&lt;/p&gt;

&lt;p&gt;정수입니다. &lt;strong&gt;-2147483648&lt;/strong&gt;부터 &lt;strong&gt;2147483647&lt;/strong&gt;까지의 값은 Django가 지원하는 모든 데이터베이스에서 안전합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MinValueValidator&lt;/strong&gt;와 &lt;strong&gt;MaxValueValidator&lt;/strong&gt;를 사용하여 기본 데이터베이스가 지원하는 값을 기반으로 입력을 검증한다.&lt;/p&gt;

&lt;p&gt;이 필드에 대한 기본 폼 위젯은 &lt;strong&gt;localize&lt;/strong&gt;일 때 &lt;strong&gt;False&lt;/strong&gt;이고, 그렇지 않으면 &lt;strong&gt;TextInput&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h2 id=&quot;genericipaddressfield&quot;&gt;GenericIPAddressField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; GenericIPAddressField(&lt;em&gt;protoco=’both’, unpack_ipv4=False, **options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;문자열 형식(e.g. &lt;strong&gt;192.0.2.30&lt;/strong&gt; or &lt;strong&gt;2a02:42fe::4&lt;/strong&gt;)의 IPv4 또는 IPv6 주소입니다. 이 필드의 기본 폼 위젯은 &lt;strong&gt;TextInput&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;IPv6 주소 normalization은 RFC &lt;a href=&quot;https://tools.ietf.org/html/rfc4291.html#section-2.2&quot;&gt;4291#section-2.2&lt;/a&gt;를 따릅니다. 여기에는 &lt;strong&gt;::ffff:192.0.2.0&lt;/strong&gt; 와 같은 해당 섹션의 제 3문단에서 제시한 IPv4 포맷이 포함됩니다. 예를 들어 &lt;strong&gt;2001:0::0:01&lt;/strong&gt;는 &lt;strong&gt;2001::1&lt;/strong&gt;으로 normalize되고,  &lt;strong&gt;::ffff:0a0a:0a0a&lt;/strong&gt;는 &lt;strong&gt;::ffff:10.10.10.10&lt;/strong&gt;으로 됩니다. 모든 문자는 소문자로 변환됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GenericIPAddressField.protocol&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;특정 프로토콜로 유효한 입력을 제한합니다. 가능한 값은 &lt;strong&gt;‘both’&lt;/strong&gt;(default)이거나 &lt;strong&gt;‘IPv4’&lt;/strong&gt; 또는 &lt;strong&gt;‘IPv6’&lt;/strong&gt;입니다. 매칭은 대소문자를 구분하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GenericIPAddressField.unpack_ipv4&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;::ffffff:192.0.2.1&lt;/strong&gt;과 같은 매핑된 IPv4 주소를 풉니다. 이 옵션을 활성화하면 해당 주소가 &lt;strong&gt;192.0.2.1&lt;/strong&gt;로 풀리게 됩니다.Default는 비활성화됩니다. &lt;strong&gt;protocol&lt;/strong&gt;이 &lt;strong&gt;‘both’&lt;/strong&gt;로 설정되어 있을 때만 사용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;nullbooleanfield&quot;&gt;NullBooleanField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; NullBooleanField(&lt;/strong&gt;&lt;em&gt;options&lt;/em&gt;)**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;null=True&lt;/strong&gt;인 &lt;strong&gt;BooleanField&lt;/strong&gt;와 같습니다. Django 미래 버전에서 이 필드는 deprecated 될 것이므로 &lt;strong&gt;BooleanField&lt;/strong&gt;를 사용하십시오.&lt;/p&gt;

&lt;h2 id=&quot;positiveintegerfield&quot;&gt;PositiveIntegerField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; PositiveIntegerField(&lt;/strong&gt;&lt;em&gt;options&lt;/em&gt;)**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IntegerField&lt;/strong&gt;와 같지만, &lt;strong&gt;0&lt;/strong&gt; 이거나 양수여야 합니다. &lt;strong&gt;0&lt;/strong&gt;부터 &lt;strong&gt;2147483647&lt;/strong&gt;까지의 값은 Django가 지원하는 모든 데이터베이스에서 안전합니다. &lt;strong&gt;0&lt;/strong&gt;의 값은 역호환성 이유로 허가됩니다(&lt;em&gt;The value 0 is accepted for backward compatibility reasons&lt;/em&gt;).&lt;/p&gt;

&lt;h2 id=&quot;positivesmallintegerfield&quot;&gt;PositiveSmallIntegerField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; PositiveSmallIntegerField(&lt;/strong&gt;&lt;em&gt;options&lt;/em&gt;)**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PositiveIntegerField&lt;/strong&gt;와 비슷하지만, 특정 (데이터베이스에 따라 달라지는) 포인트 이하의 값만 허용한다. &lt;strong&gt;0&lt;/strong&gt;에서 &lt;strong&gt;32767&lt;/strong&gt;까지의 값은 Django가 지원하는 모든 데이터베이스에서 안전하다.&lt;/p&gt;

&lt;h2 id=&quot;slugfield&quot;&gt;SlugField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; SlugField(&lt;em&gt;max_length=50, **options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Slug는 신문용어입니다. slug는 글자, 숫자, 밑줄 또는 하이픈만 포함하는 어떤 것의 짧은 꼬리표입니다. 이들은 일반적으로 URL에서 사용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CharField&lt;/strong&gt;처럼 &lt;strong&gt;max_length&lt;/strong&gt;를 지정할 수 있습니다(&lt;strong&gt;CharField&lt;/strong&gt;에 있는 데이터베이스 호환성에 대한 note와 &lt;strong&gt;max_length&lt;/strong&gt;에 대하여 읽어보십시오). &lt;strong&gt;max_length&lt;/strong&gt;이 명시되지 않은 경우 Django는 기본적으로 50으로 설정합니다.&lt;/p&gt;

&lt;p&gt;이는 &lt;strong&gt;Field.db_index&lt;/strong&gt;를 &lt;strong&gt;True&lt;/strong&gt;로 설정하는 것을 암시합니다.&lt;/p&gt;

&lt;p&gt;몇몇 다른 값에 기초해 자동으로 SlugField를 미리 생성하여 사용하는 것이 종종 유용합니다. 이를 admin에서 &lt;strong&gt;prepopuluate_fields&lt;/strong&gt;를 사용하여 자동적으로 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SlugField.allow_unicode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;True&lt;/strong&gt;일 경우 이 필드는 ASCII 문자 외에 Unicode 문자를 허용합니다. 기본값은 &lt;strong&gt;False&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h2 id=&quot;smallintegerfield&quot;&gt;SmallIntegerField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; SmallIntegerField(&lt;/strong&gt;&lt;em&gt;options&lt;/em&gt;)**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IntegerField&lt;/strong&gt;와 비슷하지만, 특정 (데이터베이스에 따라 달라지는) 포인트 이하의 값만 허용한다. &lt;strong&gt;-32768&lt;/strong&gt; ~ &lt;strong&gt;32767&lt;/strong&gt;의 값은 장고에서 지원하는 모든 데이터베이스에서 안전하다.&lt;/p&gt;

&lt;h2 id=&quot;textfield&quot;&gt;TextField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; TextField(&lt;/strong&gt;&lt;em&gt;options&lt;/em&gt;)**&lt;/p&gt;

&lt;p&gt;큰 텍스트 필드입니다. 이 필드에 대한 기본 폼 위젯은 &lt;strong&gt;Textarea&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;만약 &lt;strong&gt;max_length&lt;/strong&gt; attribute를 지정하면 자동으로 생성되는 폼 필드의 &lt;strong&gt;Textarea&lt;/strong&gt; 위젯에 반영됩니다. 그러나 이는 모델이나 데이터베이스 레벨에서 시행되지는 않습니다. 그것을 위해서는 &lt;strong&gt;CharField&lt;/strong&gt;를 사용하십시오.&lt;/p&gt;

&lt;h2 id=&quot;timefield&quot;&gt;TimeField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; TimeField(&lt;em&gt;auto_now=False, auto_now_add=False, **options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python의 &lt;strong&gt;datetime.time&lt;/strong&gt; instance로 표현된 시간입니다. &lt;strong&gt;DateField&lt;/strong&gt;와 같은 auto와 관련된 옵션이 있습니다.&lt;/p&gt;

&lt;p&gt;이 필드에 대한 기본 폼 위젯은 &lt;strong&gt;TextInput&lt;/strong&gt;입니다. admin은 몇개의 Javascript shortcut을 추가합니다.&lt;/p&gt;

&lt;h2 id=&quot;urlfield&quot;&gt;URLField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; URLField(&lt;em&gt;max_length=200, **options&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;URL에 대한 &lt;strong&gt;CharField&lt;/strong&gt;입니다. &lt;strong&gt;URLValidator&lt;/strong&gt;에 의해 검사됩니다.&lt;/p&gt;

&lt;p&gt;이 필드에 대한 기본 폼 위젯은 &lt;strong&gt;TextInput&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CharField&lt;/strong&gt;의 자식클래스와 같이, &lt;strong&gt;URLField&lt;/strong&gt; 역시 optional &lt;strong&gt;max_length&lt;/strong&gt; argument를 받아들입니다.
이를 명시하지 않을 경우 기본적으로 200이 사용됩니다.&lt;/p&gt;

&lt;h2 id=&quot;uuidfield&quot;&gt;UUIDField&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;class&lt;/em&gt; UUIDField(&lt;/strong&gt;&lt;em&gt;options&lt;/em&gt;)**&lt;/p&gt;

&lt;p&gt;보편적으로 고유한 식별자(&lt;em&gt;identifiers&lt;/em&gt;)를 저장하기 위한 필드입니다. Python의 &lt;strong&gt;UUID&lt;/strong&gt; class를 사용합니다. PostgreSQL에서 사용할 때, 이 데이터 유형은 &lt;strong&gt;uuid&lt;/strong&gt; 데이터 형식으로 저장되며, 그렇지 않을 경우 &lt;strong&gt;char(32)&lt;/strong&gt; 형식입니다.&lt;/p&gt;

&lt;p&gt;일반적으로 고유한 식별자는 &lt;strong&gt;primary_key의&lt;/strong&gt; &lt;strong&gt;AutoField&lt;/strong&gt;에 대한 좋은 대안입니다. 데이터베이스가 &lt;strong&gt;UUID&lt;/strong&gt;를 자동으로 생성하지 않으므로, &lt;strong&gt;default&lt;/strong&gt;을 사용하는 것을 추천합니다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import uuid
from django.db import models

class MyUUIDModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # other fields
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;UUID&lt;/strong&gt; instance가 아니라 (괄호가 생략된 상태의) callable이 &lt;strong&gt;default&lt;/strong&gt;로 전달되었다는 점에 유의하십시오.&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Feb 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/02/01/Model-field-reference.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/01/Model-field-reference.html</guid>
        
        
      </item>
    
      <item>
        <title>Making Queries</title>
        <description>&lt;h1 id=&quot;making-queries&quot;&gt;Making queries&lt;/h1&gt;

&lt;p&gt;너가 &lt;code class=&quot;highlighter-rouge&quot;&gt;data models&lt;/code&gt;를 만들고 나면, Django는 create, retrieve, update 그리고 delete object를 할 수 있는 database-abstraction API를 자동적으로 제공할 것이다. 이 문서는 이 API를 어떻게 사용하는지를 알려준다. 모든 다양한 model lookup options에 대한 자세한 내용은 &lt;code class=&quot;highlighter-rouge&quot;&gt;data model reference&lt;/code&gt;를 참조하여라.&lt;/p&gt;

&lt;p&gt;이 가이드를 설명하는 동안, 우리는 다음과 같이 Weblog application을 구성하는 models를 사용할 것이다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Blog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tagline&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TextField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    	
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EmailField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;blog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ForeignKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Blog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on_delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;headline&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;body_text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TextField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pub_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DateField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mod_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DateField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;authors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ManyToManyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n_comments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n_pingbacks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rating&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;headline&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;creating-objects&quot;&gt;Creating objects&lt;/h1&gt;

&lt;p&gt;Python object의 database-table data를 나타내기 위해, Django는 직관적인 시스템을 사용한다: database class를 나타내는 model class, 그리고 그 class의 instance는 database table 안의 특정 기록들을 나타낸다.&lt;/p&gt;

&lt;p&gt;object를 생성하기 위해, model class의 keyword arguments를 사용하여 그것을 instantiate 한 뒤, database에 저장하기 위해 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt;를 호출해라.&lt;/p&gt;

&lt;p&gt;models가 &lt;strong&gt;mysite/blog/models.py&lt;/strong&gt; 파일 안에 있다고 가정하자. 예시는 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from blog.models import Blog
&amp;gt;&amp;gt;&amp;gt; b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')
&amp;gt;&amp;gt;&amp;gt; b.save()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 뒤에서 &lt;strong&gt;INSERT&lt;/strong&gt; SQL statement를 실행한다. Django는 너가 명시적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()를&lt;/code&gt;&lt;/strong&gt; 호출하기 전까지 database를 건드리지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt; method는 return 값이 없다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt;는 여기에서 설명하지 않은 다수의 advanced option들이 있다. 모든 세부 사항을 위해서 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt; 문서를 참조하라&lt;/p&gt;

    &lt;p&gt;object를 생성하고 저장하는 것을 한 번에 하기 위해서는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;create()&lt;/code&gt;&lt;/strong&gt; method를 사용하여라.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;saving-changes-to-objects&quot;&gt;Saving changes to objects&lt;/h1&gt;

&lt;p&gt;databse 에 이미 있는 object의 변경 사항을 저장하기 위해서는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt;를 사용해라.&lt;/p&gt;

&lt;p&gt;주어진 &lt;strong&gt;Blog&lt;/strong&gt; instance &lt;strong&gt;b5&lt;/strong&gt;는 이미 database에 저장되어 있다. 이 예시는 그것의 이름을 바꾸고, database에 그것의 record를 update하는 것이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b5.name = 'New name'
&amp;gt;&amp;gt;&amp;gt; b5.save()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이것은 뒤에서 &lt;strong&gt;UPDATE&lt;/strong&gt; SQL statement를 실행한다. Django는 너가 명시적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt; 호출하기 전까지 database를 건드리지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;saving-foreignkey-and-manytomanyfield-fields&quot;&gt;Saving ForeignKey and ManyToManyField fields&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; field를 update하는 것은 일반적인 field를 저장하는 것과 정확히 같은 방법으로 작동한다 - 단순히 옳은 타입의 object를 할당 해주는 것이다. 이 예시는 &lt;strong&gt;Entry&lt;/strong&gt; instance &lt;strong&gt;entry&lt;/strong&gt;의 &lt;strong&gt;blog&lt;/strong&gt; attribute를 update하는 것이다. &lt;strong&gt;Entry&lt;/strong&gt;와 &lt;strong&gt;Blog&lt;/strong&gt;의 적당한 instances들이 이미 database에 저장되어 있다고 가정하자(따라서 우리는 다음과 같이 그들을 retrieve 할 수 있다):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from blog.models import Blog, Entry
&amp;gt;&amp;gt;&amp;gt; entry = Entry.objects.get(pk=1)
&amp;gt;&amp;gt;&amp;gt; chees_blog = Blog.objects.get(name=&quot;Cheddar Talk&quot;)
&amp;gt;&amp;gt;&amp;gt; entry.blog = cheese_blog
&amp;gt;&amp;gt;&amp;gt; entry.save()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 updating하는 것은 약간 다르게 작동한다 - relation에 record를 추가하기 위해 field에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;&lt;/strong&gt; method를 사용해라. 이 예시는 &lt;strong&gt;Author&lt;/strong&gt; instance &lt;strong&gt;joe&lt;/strong&gt;를 &lt;strong&gt;entry&lt;/strong&gt; object에 추가한 것이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from blog.models import Author
&amp;gt;&amp;gt;&amp;gt; joe = Author.objects.create(name=&quot;Joe&quot;)
&amp;gt;&amp;gt;&amp;gt; entry.authors.add(joe)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;에 많은 수의 record를 한 번에 저장하기 위해, 많은 arguments를 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;&lt;/strong&gt; 의 호출 안에 포함해라. 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; john = Author.objects.create(name=&quot;John&quot;)
&amp;gt;&amp;gt;&amp;gt; paul = Author.objects.create(name=&quot;Paul&quot;)
&amp;gt;&amp;gt;&amp;gt; george = Author.objects.create(name=&quot;George&quot;)
&amp;gt;&amp;gt;&amp;gt; ringo = Author.objects.create(name=&quot;Ringo&quot;)
&amp;gt;&amp;gt;&amp;gt; entry.authors.add(john, paul, george, ringo)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django는 만약 너가 다른 종류의 object를 추가하거나 할당 할 때 error를 일으킬 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;retrieving-objects&quot;&gt;Retrieving objects&lt;/h1&gt;

&lt;p&gt;너의 database로부터 objects를 retrieve하기 위해, 너의 model class의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;를 통해 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 구성해라.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;은 너의 database의 objects의 모음을 나타낸다. 이것은 없거나 한 개일 수도 있고, 많은 &lt;em&gt;filter&lt;/em&gt;일 수도 있다. Filters는 주어진 parmeters에 따라서 query results를 줄여 나간다. SQL 용어로는, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QeurySet&lt;/code&gt;&lt;/strong&gt;은 &lt;strong&gt;SELECT&lt;/strong&gt; 명령어에 해당하고, filter은 제한하는 구절인 &lt;strong&gt;WHERE&lt;/strong&gt; 또는 &lt;strong&gt;LIMIT&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;너는 너의 model &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;를 사용함으로써 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 얻는다. 각각의 model은 적어도 한 개의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;를 갖고 있고, 이는 기본적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt;&lt;/strong&gt;라고 불리운다. 다음와 같이 model class를 통해 직접적으로 접근할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects
&amp;lt;django.db.models.manager.Manager object at ...&amp;gt;
&amp;gt;&amp;gt;&amp;gt; b = Blog(name='Foo', tagline='Bar')
&amp;gt;&amp;gt;&amp;gt; b.objects
Traceback:
	...
AttributeError: &quot;Manager isn't accessible via Blog instances.&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Managers&lt;/code&gt;&lt;/strong&gt;는 model class를 통해서만 접근할 수 있고 model instances를 통해서는 안된다. 이는 “table-level” operations와 “record-level” operations를 분리하기 위함이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;은 한 model에 대한 &lt;strong&gt;QuerySets&lt;/strong&gt;의 메인 소스이다. 예를 들어, &lt;strong&gt;Blog.objects.all()&lt;/strong&gt;은 database에서 모든 &lt;strong&gt;Blog&lt;/strong&gt; objects를 담고 있는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 반환한다.&lt;/p&gt;

&lt;h2 id=&quot;retrieving-all-objects&quot;&gt;Retrieving all objects&lt;/h2&gt;

&lt;p&gt;table로 부터 objects를 retrieve하는 가장 쉬운 방법은 모든 것들을 받는 것이다. 이를 하기 위해서 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;&lt;/strong&gt; method를 사용해라:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; all_entries = Entry.objects.all()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;&lt;/strong&gt; mothod는 database에 있는 모든 objects의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySets&lt;/code&gt;&lt;/strong&gt;을 반환한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;retrieving-specific-objects-with-filters&quot;&gt;Retrieving specific objects with filters&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;&lt;/strong&gt;에 의해 반환된 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;은 database table의 모든 objects를 묘사한다. 그러나 보통, 너는 완전한 objects의 집합에서 일부만 선택해야 할 필요가 있을 것이다.&lt;/p&gt;

&lt;p&gt;이러한 부분집합을 만들기 위해서, 너는 filter conditions를 추가하여 초기의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Queryset&lt;/code&gt;&lt;/strong&gt;을 수정한다. 다음은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 refine하는 대표적인 두 가지 방법이다:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;filter(&lt;/strong&gt;kwargs)**&lt;/p&gt;

&lt;p&gt;주어진 lookup parameters와 match하는&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;exclude(&lt;/strong&gt;kwargs)**&lt;/p&gt;

&lt;p&gt;주어진 lookup parameters와 match하지 않는 objects를 포함하고 있는 새로운 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 반환한다.&lt;/p&gt;

&lt;p&gt;lookup parameters (위 함수의 정의에서 &lt;strong&gt;**kwargs&lt;/strong&gt;)는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Field lookups&lt;/code&gt; 아래에 기술된 포멧을 따라야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 2006년의 blog entries의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 얻고 싶다면 다음과 같이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;를 사용해라:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.filter(pub_date__year=2006)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기본 manager class를 사용하면 이는 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.all().filter(pub_date__year=2006)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Chaining filters&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 refine한 결과는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt; 그 자신이기 때문에 연속적인 refinement을 함께 할 수 있다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(
...		headline__startswith='What'
...).exclude(
...		pub_date__gte=datetime.date.today()
...).filter(
...		pub_date__gte=datetime.date(2005, 1, 30)
...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 모든 database의 entries를 시작 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;으로 받고, filter를 추가하고, exclusion하고, 다른 filter를 추가했다. 최종 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;의 결과는 “What”으로 시작하는 headline과 현재 날짜와 2005년 1월 30일 사이에 출판된 모든 entries를 갖고 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Filtered QuerySets are unique&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;너가 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 refine할 때마다, 너는 이전의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;과 전혀 연결되지 않은 새로운 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 을 얻는다. 각각의 refinement는 저장되고, 사용되고, 다시 쓸 수 있는 분리되고 별개의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 생성한다.&lt;/p&gt;

&lt;p&gt;다음은 예시이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; q1 = Entry.objects.filter(headline__startswith=&quot;What&quot;)
&amp;gt;&amp;gt;&amp;gt; q2 = q1.exclude(pub_date__dte=datetime.date.today())
&amp;gt;&amp;gt;&amp;gt; q3 = q1.filter(pub_date__gte=datetime.date.today())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 세 가지 &lt;strong&gt;QuerySets&lt;/strong&gt;는 각각 별개이다. 첫 번째 것은 “What”으로 시작하는 headline을 갖고 있는 모든 entries를 포함하는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;이다. 두 번째 것은 첫 번째 것의 하위 집합으로, &lt;strong&gt;pub_date&lt;/strong&gt;가 오늘이거나 미래인 것들의 records를 제외하는 추가적인 기준을 갖고 있다. 세 번째 것은 첫 번째의 하위 집합으로, &lt;strong&gt;pub_date&lt;/strong&gt;가 오늘이거나 미래인 것들만 고르는 추가적인 기준을 갖고 있다. 초기 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;(&lt;strong&gt;q1&lt;/strong&gt;)은 refinement 과정에 영향을 받지 않는다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;QuerySets are lazy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;QuerySets는 게으르다 - &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 생성하는 작업은 어떠한 database activity도 포함하지 않는다. 너는 매우 길게 filters를 쌓을 수 있지만, Django는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;가 &lt;em&gt;evaluated&lt;/em&gt; 되기 전까지 실제로 query를 실행하지 않는다. 다음 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; q = Entry.objects.filter(headline__startswith=&quot;What&quot;)
&amp;gt;&amp;gt;&amp;gt; q = q.filter(pub_date__lte=datetime.date.today())
&amp;gt;&amp;gt;&amp;gt; q = q.exclude(body_text__icontains=&quot;food&quot;)
&amp;gt;&amp;gt;&amp;gt; print(q)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 세 번의 database hit처럼 보이지만, 사실 이것은 마지막 line의 (print(q))에서 database를 단 한 번만 hit한다. 일반적으로, 너가 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;의 결과를 요구하지 않는 이상, 그것들은 database로 부터 도출되지 않을 것이다. 너가 그것을 할 때, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;은 database에 접근하여 &lt;em&gt;evaluated&lt;/em&gt;된다. 언제 evaluation이 일어나는지에 대한 자세한 디테일은 &lt;code class=&quot;highlighter-rouge&quot;&gt;When QuerySets are evalutated&lt;/code&gt;를 보아라.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;retrieving-a-single-object-with-get&quot;&gt;Retrieving a single object with get()&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;는 너에게 항상 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 줄 것이다, 단 하나의 object가 query에 해당할 지라도 - 이 경우에, 이는 하나의 요소를 갖고 있는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;이 될 것이다.&lt;/p&gt;

&lt;p&gt;만약 너가 query에 해당하는 하나의 object가 있다는 것을 안다면, 그 object를 직접적으로 반환하는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt; mehtod를 사용해라:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; one_entry = Entry.objects.get(pk=1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 마치 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;처럼 어떠한 query expression과도 함께 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt;을 사용할 수 있다 - 다시 말하지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;Field looups&lt;/code&gt; 아래를 참고해라.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt;을 사용하는 것과 &lt;strong&gt;[0]&lt;/strong&gt; 슬라이싱과 함께 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;를 사용하는 것에 차이가 있다는 점을 알고 있어라. 만약 query와 맞는 결과가 없다면, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt;은 &lt;strong&gt;DoesNotExist&lt;/strong&gt; exception을 일으킬 것이다. 이 exception은 query가 수행되고 있는 model class의 attribute이다 - 따라서 위의 코드에서 만약 primary key가 1인 &lt;strong&gt;Entry&lt;/strong&gt; object가 없다면, Django는 &lt;strong&gt;Entry.DoesNotExist&lt;/strong&gt;를 일으킬 것이다.&lt;/p&gt;

&lt;p&gt;비슷하게, Django는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt; query에 한 개 이상의 해당하는 것이 있을 경우 에러를 일으킬 것이다. 이 경우, 그것은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MultipleObjectsReturned&lt;/code&gt;&lt;/strong&gt;를 일으킬 것이고, 이 역시 model class 자체의 attribute이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;other-queryset-methods&quot;&gt;Other QuerySet methods&lt;/h2&gt;

&lt;p&gt;너가 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;, 그리고 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exclude()&lt;/code&gt;&lt;/strong&gt;를 사용할 대부분의 경우는 너가 database로부터 objects를 찾아볼 필요가 있을 때이다. 그러나 이 외에도 많은 것이 있다; 다양한 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt; method의 전체 리스트를 보기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet API Reference&lt;/code&gt;를 보아라.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;limiting-querysets&quot;&gt;Limiting QuerySets&lt;/h2&gt;

&lt;p&gt;너의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet이&lt;/code&gt;&lt;/strong&gt; 특정 개수의 결과를 갖게 제한하고 싶다면 Python의 array-slicing syntax를 이용해라. 이는 SQL의 &lt;strong&gt;LIMIT&lt;/strong&gt; 과 &lt;strong&gt;OFFSET&lt;/strong&gt; clauses와 같다.&lt;/p&gt;

&lt;p&gt;예를 들어 다음은 첫 5개의 objects를 반환한다(&lt;strong&gt;LIMIT 5&lt;/strong&gt;):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.all()[:5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 6번째 부터 10번째 objects를 반환한다(&lt;strong&gt;OFFSET 5 LIMIT 5&lt;/strong&gt;):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.all()[5:10]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Negative indexing(i.e. &lt;strong&gt;Entry.objects.all()[-1]&lt;/strong&gt;)은 지원되지 않는다.&lt;/p&gt;

&lt;p&gt;일반적으로, slicing QuerySet은 새로운 QuerySet을 반환한다 - 이것은 query를 evaluate하지 않는다. 예외는 너가 Python slice syntax에서 “step” parameter를 사용할 경우이다. 예를 들어, 이것은 첫 10개의 매 두 번째 objects를 반환하기 위해 query를 실행한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.all()[:10:2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;sliced queryset에 filtering을 추가하거나 순서를 매기는 것은 그것이 어떻게 작동할지에 대한 모호성 때문에 금지된다.&lt;/p&gt;

&lt;p&gt;리스트가 아니라 하나의 단일 object를 얻고 싶다면(e.g. &lt;strong&gt;SELECT foo FROM bar LIMIT 1&lt;/strong&gt;), slice 대신에 간단한 index를 사용해라. 예를 들어, 이는 headline을 알파벳 순서로 정렬한 후, database의 첫 번째 &lt;strong&gt;Entry&lt;/strong&gt;를 반환할 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.order_by('headline')[0] 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이것은 대략 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.order_by('headline')[0:1].get()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나, 만약 기준에 합당한 objects가 없다면 첫 번째 것은 &lt;strong&gt;IndexError&lt;/strong&gt;를 일으키는 반면, 두 번째 것은 &lt;strong&gt;DoesNotExist&lt;/strong&gt;를 일으킬 것이다. 자세한 사항은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt;을 보아라.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;field-lookups&quot;&gt;Field lookups&lt;/h2&gt;

&lt;p&gt;Field lookups는 SQL &lt;strong&gt;WHERE&lt;/strong&gt; clause의 항목을 지정하는 방법이다. 그들은 &lt;strong&gt;QuerySet&lt;/strong&gt; method인 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exclude()&lt;/code&gt;&lt;/strong&gt;, 그리고 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt;에 keyword arguments로 명시돼 있다.&lt;/p&gt;

&lt;p&gt;기본 lookups keyword arguments들은 &lt;strong&gt;field__lookuptype=value&lt;/strong&gt;와 같은 형식을 취한다. (두 개의 underscore이다). 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(pub_date__lte='2006-01-01')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대략 다음과 같은 SQL로 바뀐다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM blog_entry WHERE pub_date &amp;lt;= '2006-01-01';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;How this is possible&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Python은 runtime에 names와 values가 evalutated되는 임의의 name-value arguments를 허용하는 함수를 정의 할 수 있다. 자세한 내용은 공식 Python 튜토리얼의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Keyword Arguments&lt;/code&gt;를 참조하여라.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;lookup에 명시된 field는 model field의 이름이어야 한다. 한 가지 예외가 있는데, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;의 경우, 너는 접미사로 &lt;strong&gt;_id&lt;/strong&gt;가 추가된 field name을 명시할 수 있다. 이 경우에 value parameter는 foreign model의 primary key의 raw value를 포함할 것을 기대된다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog_id=4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 너가 유효하지 않은 keyword argument를 넘겨준다면, lookup 함수는 &lt;strong&gt;TypeError&lt;/strong&gt;를 일으킬 것이다.&lt;/p&gt;

&lt;p&gt;datase API는 약 24개의 lookup type들을 소개한다; 완전한 reference는 &lt;code class=&quot;highlighter-rouge&quot;&gt;field lookup reference&lt;/code&gt;를 참조하여라. 무엇이 가능한지 잠깐 소개를 하기 위해 여기에는 너가 자주 사용하게 될 몇 가지를 소개하겠다:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exact&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;'’exact’’ match이다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.get(headline__exact=&quot;Cat bites dog&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 다음과 같은 SQL lines이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ... WHERE headline = 'Cat bites dog';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 너가 lookup type을 제공하지 않는다면 - 즉, 너의 keyword argument가 double underscore을 포함하지 않는다면 - lookup type은 &lt;strong&gt;exact&lt;/strong&gt;라고 가정된다.&lt;/p&gt;

&lt;p&gt;예를 들어, 다음 두 문장은 동일하다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(id__exact=14)   # Explicit form
&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(id=14           # __exact is implied
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;exact&lt;/strong&gt; lookups는 일반적인 경우이므로, 이는 편의를 위한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iexact&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;case-insensitive match이다. 따라서 다음 query:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(name__iexact=&quot;beatles blog&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;는 “Beatles Blog”, “beatles blog”, 또는 심지어 “BeAtlES blOG”의 제목을 가진 Blog를 match한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;contains&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;case-sensitive한 포함 테스트이다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.get(haadline__contains='Lennon')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 대략 다음 SQL과 같다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ... WHERE headline LIKE '%Lennon%';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 ‘Today Lennon honored’ 의 headline을 match하지만, ‘today lennon honored’는 match하지 않는다는 점을 주의해라.&lt;/p&gt;

&lt;p&gt;또한 case-insensitive 버전인 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;icontains&lt;/code&gt;&lt;/strong&gt;가 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;startswith&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;endswith&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;각각 Starts-with와 ends-with search이다. 또한 case-insensitive 버전인 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;istartswith&lt;/code&gt;&lt;/strong&gt;와 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iendswith&lt;/code&gt;&lt;/strong&gt;가 있다.&lt;/p&gt;

&lt;p&gt;다시 말하지만, 이는 오직 표면만 다룬 것이다. 전체 reference는 &lt;code class=&quot;highlighter-rouge&quot;&gt;field lookup reference&lt;/code&gt;에서 볼 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;lookups-that-span-relationships&quot;&gt;Lookups that span relationships&lt;/h2&gt;

&lt;p&gt;Django는 뒤에서 자동으로 SQL &lt;strong&gt;JOIN&lt;/strong&gt;s를 다루면서, lookups에서 relatioships를 “follow”할 수 있는 강력하고 직관적인 방법을 제공한다. relationship을 확장하기 위해, 너가 원하는 field에 도달할 때까지, double underscore으로 분리하여, model 사이의 related fields의 이름을 사용해라.&lt;/p&gt;

&lt;p&gt;다음 예시는 &lt;strong&gt;Blog&lt;/strong&gt;의 &lt;strong&gt;name&lt;/strong&gt;이 &lt;strong&gt;‘Beatles Blog’&lt;/strong&gt;인 모든 &lt;strong&gt;Entry&lt;/strong&gt; objects를 받는다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog__name='Beatles Blog')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 확장은 너가 원하는 만큼 깊이 할 수 있다.&lt;/p&gt;

&lt;p&gt;이는 또한 뒤 방향으로도 진행 가능하다. “reverse” relationship을 참조하고 싶다면, 단지 model의 소문자 이름을 사용해라.&lt;/p&gt;

&lt;p&gt;다음 예시는 &lt;strong&gt;headline&lt;/strong&gt;이 &lt;strong&gt;‘Lennon’&lt;/strong&gt;을 포함하고 있는 &lt;strong&gt;Entry&lt;/strong&gt;가 적어도 하나 있는 모든 &lt;strong&gt;Blog&lt;/strong&gt; objects를 받는다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(entry__headline__contains='Lennon')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 너가 multiple relationships를 가로질러 filtering하고 있고 중간 model이 filter 조건에 맞는 value를 갖고 있지 않다면, Django는 그것을 거기에 마치 유효하지만 비어있는(모든 values가 &lt;strong&gt;NULL&lt;/strong&gt;) object가 있다고 다룰 것이다. 즉, error가 발생하지 않을 것이라는 의미이다. 예를 들어, 다음 filter를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Blog.objects.filter(entry__authors__name='Lennon')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(만약, 연관된 &lt;strong&gt;Author&lt;/strong&gt; model이 있고), 만약 한 entry와 연관된 &lt;strong&gt;author&lt;/strong&gt;이 없다면, error를 일으키는 대신에 그것은 연관된 &lt;strong&gt;name&lt;/strong&gt; 또한 없다고 다뤄진다. 보통 이는 너가 원하는 것일 것이다. 헷갈리는 유일한 경우는 만약 너가 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;isnull&lt;/code&gt;&lt;/strong&gt;을 사용할 경우이다. 즉:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Blog.objects.filter(entry__authors__name__isnull=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;은 &lt;strong&gt;author&lt;/strong&gt;에 비어있는 &lt;strong&gt;name&lt;/strong&gt;을 갖고 있는 &lt;strong&gt;Blog&lt;/strong&gt; objects 뿐만 아니라, &lt;strong&gt;entry&lt;/strong&gt;에 비어있는 &lt;strong&gt;author&lt;/strong&gt;을 갖고 있는 &lt;strong&gt;Blog&lt;/strong&gt; objects 또한 반환할 것이다. 만약 너가 후자를 원하지 않는다면 이렇게 써야 한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Blog.objects.filter(entry__authors__isnull=False,
entry__authors__name__isnull=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Spanning multi-valued relationships&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 파트는 글로는 어렵게 써 있지만, 실행 과정과 결과를 보면 당연하다고 여겨질 것이다. 따라서 글이 헷갈리게 써 있더라도 코드를 보면서 읽으면 어렵지 않게 이해할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;너가 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt; 혹은 reverse &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;에 기초하여 object를 filtering할 때, 두 가지 흥미있는 filter의 종류가 있다. &lt;strong&gt;Blog&lt;/strong&gt;/&lt;strong&gt;Entry&lt;/strong&gt;의 relationship을 생각해 보아라(&lt;strong&gt;Blog&lt;/strong&gt;에서 &lt;strong&gt;Entry&lt;/strong&gt; 관계는 one-to-many relationship이다). 우리는 headline에 &lt;em&gt;“Lennon”&lt;/em&gt;이 포함되어 있고 2008년에 출판된 entry를 갖고 있는 blog를 찾고 싶을 수 있다. 한 &lt;strong&gt;Blog&lt;/strong&gt;에 연관된 많은 entries가 있기 때문에, 이 두 개의 queries는 모두 사용 가능하고 몇 가지 상황에서 합당하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;에서도 비슷한 종류의 상황이 발생한다. 예를 들어, &lt;strong&gt;Entry&lt;/strong&gt;가 tags에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 갖고 있다면, 우리는 &lt;em&gt;“music”&lt;/em&gt;과 &lt;em&gt;“band”&lt;/em&gt; tags 에 연결된 entries를 찾고 싶을 수 있고, 아니면 &lt;em&gt;“music”&lt;/em&gt; tag와 &lt;em&gt;“public”&lt;/em&gt; 상태의 entries를 찾고 싶을 수 있다.&lt;/p&gt;

&lt;p&gt;이와 같은 상황들을 모두 다루기 위해, Django는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt; 호출을 가공하는 일관된 방법을 갖고 있다. 하나의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;안에 있는 모든 것은 동시에 적용되는데 이런 요구사항에 맞는 모든 items를 filter out하기 위함이다. 연속적인 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt; 호출들은 objects의 집합을 점점 제한하지만, multi-valued relations에서는 앞의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt; 호출에 의한 objects일 필요 없이 primary model에 연결된 모든 object에게 적용된다.&lt;/p&gt;

&lt;p&gt;살짝 헷갈리게 들릴 수 있지만, 다음 예시가 명확하게 해주길 바란다. headline에 &lt;em&gt;“Lennon”&lt;/em&gt;이 포함되어 있고 2008년에 출판된 entry(두 개의 조건을 모두 만족하는 같은 entry)를 선택하기 위해 우리는 다음과 같이 쓴다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Blog.objects.filter(entry__headline__contains='Lennon', entry__pub_date__year=2008)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;headline에 &lt;em&gt;“Lennon”&lt;/em&gt;을 포함하고 있는 entry &lt;strong&gt;뿐만 아니라&lt;/strong&gt; 2008년에 출판된 entry도 갖고 있는 모든 blog를 갖기 위해서는 다음과 같이 쓴다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;headline에 &lt;em&gt;“Lennon”&lt;/em&gt;을 포함하고 있는 entries와 2008년에 나온 entries 둘 다 갖고 있는 blog가 한 개만 있고, &lt;em&gt;“Lennon”&lt;/em&gt;을 포함하고 있는 2008년에 나온 entries를 갖고 있는 블로그는 없다고 가정하자. 첫 번째 query는 아무런 blogs를 반환하지 않지만, 두 번째 query는 그 한 개의 blog를 반환한다.&lt;/p&gt;

&lt;p&gt;두 번째 예시에서 첫 번째 filter는 headline에 &lt;em&gt;“Lennon”&lt;/em&gt;을 포함하고 있는 entries와 연결된 blogs의 queryset으로 제한한다. 두 번째 filter는 그 blogs의 집합을 2008년에 출판된 entries도 연결된 blogs들로 &lt;em&gt;더&lt;/em&gt; 제한한다. 두 번째 filter에서 선택된 entires는 첫 번째 filter에서 선택된 entries와 같을 수도 있고 같지 않을 수도 있다. 우리는 각 filter statement에서 &lt;strong&gt;Blog&lt;/strong&gt; items를 filtering했지, &lt;strong&gt;Entry&lt;/strong&gt; items를 filtering 하지 않았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;multi-value relations를 확장한 queries에 대한 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;의 행동은, 위에 기술된 대로, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exclude()&lt;/code&gt;&lt;/strong&gt;와 동일하게 implemented되지 않는다. 대신에, 하나의 exclude() 호출에 있는 조건이 반드시 같은 item를 참조하지는 않는다.&lt;/p&gt;

    &lt;p&gt;예를 들어, 다음 query는 headline에 &lt;em&gt;“Lennon”&lt;/em&gt;을 포함하고 있는 entries와 2008년에 출판된 entries를 모두 갖고 있는 blogs를 exclude할 것이다:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Blog.objects.exclude(
  	entry__headline__contains='Lennon',
  	entry__pub_date__year=2008,
  )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;그러나, filter()를 사용할 때와는 달리, 이것은 두 개의 조건을 모두 만족시키는 entries에 기초하여 blogs를 제한하지 않는다. 이를 하기 위해서, 즉 &lt;em&gt;“Lennon”&lt;/em&gt;을 포함하고 2008년에 출판된 entries를 갖고 있지 않은 모든 blogs를 선택하기 위해서는 다음과 같이 두 개의 query를 만들어야 한다:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Blog.objects.exclude(
  	entry__in=Entry.objects.filter(
  		headline__contains='Lennon',
  		pub_date__year=2008,
  	),
  )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;filters-can-reference-fields-on-the-model&quot;&gt;Filters can reference fields on the model&lt;/h2&gt;

&lt;p&gt;지금까지 주어진 모든 예시에서, 우리는 model filed 값을 상수와 비교하는 filter들만 만들었었다. 그러나, 한 field의 값과 같은 model에 있는 다른 field의 값을 비교하고 싶으면 어떡할까?&lt;/p&gt;

&lt;p&gt;Django는 이와 같은 비교를 가능하게 하기 위해 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;F expressions&lt;/code&gt;&lt;/strong&gt;를 제공한다. &lt;strong&gt;F()&lt;/strong&gt;의 instances는 query 안에서 model field를 참조하는 역할을 한다. 이 references는 같은 model instance에 있는 다른 두 개의 fields 값들을 비교하기 위해 query filters에서 사용될 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어, pingbacks보다 많은 수의 comments를 갖고 있는 blog entries의 list를 찾기 위해, 우리는 pingback 수를 reference하기 위한 &lt;strong&gt;F()&lt;/strong&gt; object를 구성하고, query에서 그 &lt;strong&gt;F()&lt;/strong&gt; object를 사용한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models import F
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(n_comments__gt=F('n_pingbacks'))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django는 &lt;strong&gt;F()&lt;/strong&gt; objects와 상수들에게 모두 적용 가능한 addition, subtraction, multiplication, division, modulo, 그리고 power arithmetic의 사용을 지원한다. pingbacks보다 두 배 많은 comments를 갖고 있는 모든 blog entries를 찾기 위해, 우리는 다음과 같이 query를 수정한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(n_comments__gt=F('n_pingbacks')*2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;entry의 rating이 pingback 수와 comment 수의 합보다 적은 모든 entries를 찾기 위해, 우리는 다음과 같이 query를 만든다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(rating__lt=F('n_commnets') + F('n_pingbacks'))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 또한 &lt;strong&gt;F()&lt;/strong&gt; object에서 relationship을 확장하기 위해 double underscore 표기를 사용할 수 있다. double underscore을 갖는 &lt;strong&gt;F()&lt;/strong&gt; object는 연결된 object에 접근할 수 있는 모든 연결을 제공한다. 예를 들어, author의 이름이 blog의 이름과 같은 모든 entries를 받기 위해, 우리는 다음과 같이 query를 만든다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(authors__name=F('blog_name'))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;date와 date/time fields에 대하여, 너는 timedelta object를 더하거나 뺄 수 있다. 다음은 출판된 후 3일 이상 수정된 모든 entries를 반환한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from datetime import timedelta
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;F()&lt;/strong&gt; object는 &lt;strong&gt;.bitand()&lt;/strong&gt;, &lt;strong&gt;.bitor()&lt;/strong&gt;, .&lt;strong&gt;bitrightshift()&lt;/strong&gt;, 그리고 &lt;strong&gt;.bitleftshift()&lt;/strong&gt;와 같은 bitwise operations를 지원한다. 다음과 같이 사용한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; F('somefield').bitand(16)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;the-pk-lookup-shortcut&quot;&gt;The pk lookup shortcut&lt;/h2&gt;

&lt;p&gt;편의를 위해서, Django는 “primary key”를 나타내는 &lt;strong&gt;pk&lt;/strong&gt; lookup shortcut을 제공한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Blog&lt;/strong&gt; model 예시에서, primary key는 &lt;strong&gt;id&lt;/strong&gt; field이기 때문에, 다음과 같은 세 개의 statements가 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(id__exact=14) # Explicit form
&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(id=14) # __exact is implied
&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(pk=14) # pk implies id__exact
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;pk&lt;/strong&gt;의 사용은 &lt;strong&gt;__exact&lt;/strong&gt; queries로 제한되어 있지 않다 - 어떠한 query term이라도 &lt;strong&gt;pk&lt;/strong&gt;와 결합되어 model의 primary key에 대한 query를 진행할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Get blogs entries with id 1, 4 and 7
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(pk__in=[1,4,7])

# Get all blog entries with id &amp;gt; 14
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(pk__gt=14)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;pk lookups는 또한 joins에 걸쳐 적용된다. 예를 들어, 다음 세 가지 statements는 동일하다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog__id__exact=3) # Explicit form
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog__id=3)        # __exact is implied
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog__pk=3)        # __pk implies __id__exact
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;escaping-percent-signs-and-underscores-in-like-statements&quot;&gt;Escaping percent signs and underscores in LIKE statements&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;LIKE&lt;/strong&gt; SQL statements와 같은 field lookups(&lt;strong&gt;iexact&lt;/strong&gt;, &lt;strong&gt;contains&lt;/strong&gt;, &lt;strong&gt;icontains&lt;/strong&gt;, &lt;strong&gt;startswith&lt;/strong&gt;, &lt;strong&gt;istartswith&lt;/strong&gt;, &lt;strong&gt;endswith&lt;/strong&gt;, 그리고 &lt;strong&gt;iendswith&lt;/strong&gt;)는 &lt;strong&gt;LIKE&lt;/strong&gt; statements에서 특별하게 사용되는 문자들을 자동적으로 escape할 것이다 - percent sign과 underscore 문자이다. (&lt;strong&gt;LIKE&lt;/strong&gt; statement에서, percent sign은 multiple character wildcard를, underscore은 single-character wildcard를 의미한다)&lt;/p&gt;

&lt;p&gt;이것은 작업들을 직관적으로 만들기 위함이고, 추상화 과정에서 새는 부분이 없다. 예를 들어, percent sign을 갖고 있는 모든 요소들을 받기 위해, 어느 다른 문자들처럼 percent sign을 사용해라:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(headline__contains='%')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django는 너를 위해 quoting을 신경 써 줄 것이다; 최종 SQL은 이와 비슷하다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ... WHERE headline LIKE '%\%%';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;underscores에 대해서도 똑같이 적용된다. percent sign과 underscore은 너를 위해 투명하게 다뤄질 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;caching-and-querysets&quot;&gt;Caching and QuerySets&lt;/h2&gt;

&lt;p&gt;각각의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySets&lt;/code&gt;&lt;/strong&gt;은 database access를 최소화하기 위해 cache를 갖고 있다. 이 작업을 이해하고 있는 것은 더 효율적인 코드 작성을 도와줄 것이다.&lt;/p&gt;

&lt;p&gt;새롭게 생긴 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;의 cache는 비어 있다. &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;이 처음으로 evalutate될 때 - 그리고, 그래서, database query가 발생하고 - Django는 query 결과를 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;의 cache에 저장하고 명시적으로 요구 될 때 그 값을 반환한다(e.g. &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;이 iterate 되는 경우, 다음 요소). &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;의 연속적인 evaluation은 cache된 결과를 재사용 할 것이다.&lt;/p&gt;

&lt;p&gt;이 caching 동작을 명심해 두어라. 왜냐하면 너가 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;s을 정확히 사용하지 않을 경우 해가 될 것이다. 예를 들어, 다음은 두 개의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;s를 만들 것이고, 그들을 evaluate하고 버릴 것이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print([e.headline for e in Entry.objects.all()])
&amp;gt;&amp;gt;&amp;gt; print([e.pub_date for e in Entry.objects.all()])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 똑같은 database query가 두 번 실행될 것이므로, database 부하가 두 배 될 것을 의미한다. 또한 두 개의 list가 같은 database record를 갖고 있지 않을 가능성도 있다. 왜냐하면 &lt;strong&gt;Entry&lt;/strong&gt;가 두 개의 요청 사이의 몇 초 사이에 추가되거나 삭제될 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;이 문제를 피하기 위해, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 저장하고 그것을 재사용하라.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; queryset = Entry.objects.all()
&amp;gt;&amp;gt;&amp;gt; print([p.headline for p in queryset]) # Evaluate the query set.
&amp;gt;&amp;gt;&amp;gt; print([p.pub_date for p in queryset]) # Re-use the cache from the evaluation.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;when-querysets-are-not-cached&quot;&gt;When QuerySets are not cached&lt;/h2&gt;

&lt;p&gt;QuerySets가 항상 그들의 결과를 cache하는 것은 아니다. queryset의 단지 일부분을 evalutate할 때, cache가 있는지 없는지는 검사되지만, 만약 없을 경우 subsequent query에 의해 반환된 item들은 cache 되지 않는다. 특히, 이것은 array slice나 index를 사용하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;limiting the queryset&lt;/code&gt;을 한 것은 cache를 발생하지 않는다는 뜻이다.&lt;/p&gt;

&lt;p&gt;예를 들어, 특정 index를 qeuryset object에서 반복적으로 얻는 것은 database를 각각 query하게 될 것이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; queryset = Entry.objects.all()
&amp;gt;&amp;gt;&amp;gt; print(queryset[5]) # Queries the database
&amp;gt;&amp;gt;&amp;gt; print(queryset[5]) # Queries the database again
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나 만약 전체 queryset이 이미 evaluated 되었었다면, cache를 대신 사용할 것이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [entry for entry in queryset]
&amp;gt;&amp;gt;&amp;gt; bool(queryset)
&amp;gt;&amp;gt;&amp;gt; entry in queryset
&amp;gt;&amp;gt;&amp;gt; list(queryset)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Note&lt;/p&gt;

    &lt;p&gt;단지 queryset을 출력하는 것은 cache를 발생시키지 않는다. 이것은 왜냐하면 &lt;strong&gt;__repr__()&lt;/strong&gt; 의 호출은 전체 queryset의 slice만 반환할 것이기 때문이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;related-objects&quot;&gt;Related objects&lt;/h1&gt;

&lt;p&gt;만약 너가 model에 relationship을 정의하고 싶다면(i.e. &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;, 또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;), model의 instances는 related object에 접근할 수 있는 편리한 API를 갖고 있다.&lt;/p&gt;

&lt;p&gt;이 페이지의 맨 위에 있는 model들을 예시로 삼는다면, &lt;strong&gt;Entry&lt;/strong&gt; object인 &lt;strong&gt;e&lt;/strong&gt;는 그것과 연관된 &lt;strong&gt;Blog&lt;/strong&gt; obejct를 blog attribute를 통해서 얻을 수 있다: &lt;strong&gt;e.blog.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(배후에서 이 기능은 Python &lt;code class=&quot;highlighter-rouge&quot;&gt;descriptors&lt;/code&gt;에 의해 구현된다. 이 내용은 사용자에게 중요하지는 않지만 호기심을 유발하기 위해 여기에서 설명한다.)&lt;/p&gt;

&lt;p&gt;Django는 또한 API accessors를 relationship의 다른 쪽에 생성한다 - related model에서 그 relationship을 정의한 모델로의 link이다. 예를 들어 &lt;strong&gt;Blog&lt;/strong&gt; object &lt;strong&gt;b&lt;/strong&gt;는 모든 related &lt;strong&gt;Entry&lt;/strong&gt; objects의 리스트를 &lt;strong&gt;entry_set&lt;/strong&gt; attribute를 이용하여 접근할 수 있다:&lt;strong&gt;b.entry_set.all()&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;one-to-many-relationships&quot;&gt;One-to-many relationships&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Forward&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 model이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;를 갖고 있다면, 그 model의 instances는 간단히 그 model의 attribute를 통하여 related (foreign) object에 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; e.blog # Returns the related Blog object.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 foreign-key attribute를 통해 가져오고 설정할 수 있다. 너가 예상한 대로, foreign key의 변화는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt;를 호출하기 전까지 너의 database에 저장되지 않는다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; e.blog = some_blog
&amp;gt;&amp;gt;&amp;gt; e.save()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; field가 &lt;strong&gt;null=True&lt;/strong&gt; 설정을 갖고 있다면(i.e. 그것이 &lt;strong&gt;NULL&lt;/strong&gt; 값을 허락한다면), 너는 &lt;strong&gt;None&lt;/strong&gt;을 설정하여 relation을 제거할 수 있다. 예시이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; e.blog = None
&amp;gt;&amp;gt;&amp;gt; e.save() # &quot;UPDATE blog_entry SET blog_id = NULL...;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;one-to-many relationships에서 forward access는 related object에 처음 접근할 때 cached된다. 같은 object instance에 있는 foreign key로의 후속 접근들은 cached된다. 예시이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; print(e.blog) # Hits the database to retrieve the associated Blog.
&amp;gt;&amp;gt;&amp;gt; print(e.blog) # Doesn't hit the database; use cached version.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;**select_related() QuerySet**&lt;/code&gt; method 모든 one-to-many relationships의 cache를 미리 recursive하게 미리 채운다. 예시이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.selected_related().get(id=2)
&amp;gt;&amp;gt;&amp;gt; print(e.blog) # Doesn't hit the database; uses cached version.
&amp;gt;&amp;gt;&amp;gt; print(e.blog) # Doesn't hit the database; uses cached version.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Following relationships “backward”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 model이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;를 갖고 있다면, foreign-key model의 instances는 첫 번째 model(ForeignKey를 갖고 있는 앞의 model)의 모든 instances를 반환하는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;에 접근할 수 있다. 기본적으로, 이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;의 이름은 &lt;strong&gt;F00_set&lt;/strong&gt;인데, &lt;strong&gt;F00&lt;/strong&gt;는 source model의 소문자 이름이다. 이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;는 &lt;strong&gt;QuerySets&lt;/strong&gt;를 반환하는데, 이것은 위의 “Retrieving objects” 부문에 기술되어 있는 대로 filtered 되고 manipulated 될 수 있다.&lt;/p&gt;

&lt;p&gt;다음은 예시이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b = Blog.objects.get(id=1)
&amp;gt;&amp;gt;&amp;gt; b.entry_set.all() # Returns all Entry objects related to Blog.

# b.entry_set is a Manager that returns QuerySets.
&amp;gt;&amp;gt;&amp;gt; b.entry_set.filter(headline__conatains='Lennon')
&amp;gt;&amp;gt;&amp;gt; b.entry_set.count()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;F00_set&lt;/strong&gt; 이름을 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; 정의에 있는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; parameter를 설정함으로써 override할 수 있다. 예를 들어, 만약 &lt;strong&gt;Entry&lt;/strong&gt; model이 &lt;strong&gt;blog = ForeignKey(Blog, on_delete=models.CASCADE, related_name=’entries’)&lt;/strong&gt;로 바뀌었을 경우, 위의 코드는 다음과 같이 바뀐다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b = Blog.objects.get(id=1)
&amp;gt;&amp;gt;&amp;gt; b.entries.all() # Returns all Entry objects related to Blog.

# b.entries is a Manager that returns QuerySets.
&amp;gt;&amp;gt;&amp;gt; b.entries.filter(headline__contains='Lennon')
&amp;gt;&amp;gt;&amp;gt; b.entries.count()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Using a custom reverse manager&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;기본적으로 reverse relations로 사용되는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RelatedManager&lt;/code&gt;&lt;/strong&gt;는 해당 model의 &lt;code class=&quot;highlighter-rouge&quot;&gt;default manager&lt;/code&gt;의 하위 class이다. 만약 너가 주어진 query에 대하여 다른 manager를 사용하고 싶다면 너는 다음과 같은 syntax를 사용하면 된다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Entry(models.Model):
	# ...
	objects = models.Manager() # Default Manager
	entries = EntryManager()   # Custom Manager

b = Blog.objects.get(id=1)
b.entry_set(manager='entries').all()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 &lt;strong&gt;EntryManager&lt;/strong&gt;의 해당 &lt;strong&gt;get_queryset()&lt;/strong&gt; method에서 기본 filtering을 수행하면 해당 filtering이 &lt;strong&gt;all()&lt;/strong&gt; 호출에 적용된다.&lt;/p&gt;

&lt;p&gt;물론, custom reverse manager를 명시하는 것은 너가 그것의 custom method의 사용도 가능하게 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b.entry_set(manager='entries').is_published()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
</description>
        <pubDate>Fri, 18 Jan 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/01/18/Making-queries.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/18/Making-queries.html</guid>
        
        
      </item>
    
      <item>
        <title>Models</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;원본 링크: &lt;a href=&quot;https://docs.djangoproject.com/en/2.1/topics/db/models/&quot;&gt;https://docs.djangoproject.com/en/2.1/topics/db/models/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;models&quot;&gt;Models&lt;/h1&gt;

&lt;p&gt;모델은 데이터에 대한 하나의, 결정적인 정보입니다. 모델은 필수적인 필드들과 저장하고 있는 데이터들의 행동을 결정합니다. 일반적으로, 각각의 모델은 하나의 데이터베이스 테이블로 매핑됩니다.&lt;/p&gt;

&lt;p&gt;기초 사항:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각각의 모델은 &lt;strong&gt;django.db.models.Model&lt;/strong&gt;의 하위 파이썬 클래스입니다.&lt;/li&gt;
  &lt;li&gt;모델 클래스의 각각의 attribute는 데이터베이스 필드를 나타냅니다.&lt;/li&gt;
  &lt;li&gt;이것들과 함께, 장고는 기본적인 데이터베이스 접근 API를 제공합니다; &lt;code class=&quot;highlighter-rouge&quot;&gt;Making queries&lt;/code&gt;참고하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;quick-example&quot;&gt;Quick example&lt;/h2&gt;

&lt;p&gt;다음 예시는 &lt;strong&gt;first_name&lt;/strong&gt;과 &lt;strong&gt;last_name&lt;/strong&gt;을 갖고 있는 &lt;strong&gt;Person&lt;/strong&gt; 모델입니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;first_name&lt;/strong&gt;과 &lt;strong&gt;last_name&lt;/strong&gt;은 모델의 필드입니다. 각각의 필드는 클래스 attribute로 구체화되며, 각각의 attribute는 하나의 데이터베이스 칼럼으로 매핑됩니다.&lt;/p&gt;

&lt;p&gt;위의 &lt;strong&gt;Person&lt;/strong&gt; 모델은 다음과 같은 데이터베이스 테이블을 생성합니다:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myapp_person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;&quot;id&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serial&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;&quot;first_name&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;&quot;last_name&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Some technical notes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;테이블의 이름인 &lt;strong&gt;myapp_person&lt;/strong&gt;은 모델 메타데이터로부터 자동적으로 생성되지만, 오버라이드할 수 있습니다. 자세한 사항은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Table names&lt;/code&gt;를 참조하십시오.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;id&lt;/strong&gt; 필드는 자동적으로 추가되지만 이 역시 오버라이드할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Automatic primary key fields&lt;/code&gt;를 참조하십시오.&lt;/li&gt;
  &lt;li&gt;위 예시의 &lt;strong&gt;CREATE TABLE&lt;/strong&gt;은 PostgreSQL 문법으로 쓰여 있는데, 장고가  &lt;code class=&quot;highlighter-rouge&quot;&gt;settings file&lt;/code&gt;에 명시된 데이터베이스 백앤드 맞춤 SQL 을 사용한다는 것을 기억하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;using-models&quot;&gt;Using models&lt;/h2&gt;

&lt;p&gt;모델들을 정의한 후, 장고의 settings file을 수정하여 앞으로 그 모델들을 사용할 것이라고 알려주어야 합니다. 이를 위해 &lt;strong&gt;INSTALLED_APPS&lt;/strong&gt;파일에 &lt;strong&gt;models.py&lt;/strong&gt;를 포함하고 있는 모듈의 이름을 추가하십시오.&lt;/p&gt;

&lt;p&gt;예를 들어, 만약 당신의 애플리케이션의 모델들이 &lt;strong&gt;myapp.models&lt;/strong&gt; 모듈 안에 있다면 (&lt;strong&gt;manage.py startapp&lt;/strong&gt; 명령어를 사용하여 만든 application package structure 안에 있다면), &lt;strong&gt;INSTALLED_APPS&lt;/strong&gt;는 다음과 같습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;INSTALLED_APPS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#...
&lt;/span&gt;    &lt;span class=&quot;s&quot;&gt;'myapp'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로운 앱들을 &lt;strong&gt;INSTALLED_APPS&lt;/strong&gt;에 추가한 뒤, &lt;strong&gt;manage.py makemigrations&lt;/strong&gt;를 이용하여 부분적 migrations를 만든 후, &lt;strong&gt;manage.py migrate&lt;/strong&gt;를 꼭 실행하도록 하십시오.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;fields&quot;&gt;Fields&lt;/h2&gt;

&lt;p&gt;이미 정의된 데이터베이스 필드들의 목록을 아는 것은 모델에서 가장 중요한 부분입니다 (또한 모델에서 신경써야 할 유일한 부분입니다). 필드는 클래스 attirbute에 의해 명시됩니다. &lt;strong&gt;clean, save&lt;/strong&gt; 또는 &lt;strong&gt;delete&lt;/strong&gt;와 같은 모델 API와 필드의 이름이 충돌하지 않도록 주의하십시오.&lt;/p&gt;

&lt;p&gt;예시 :&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Musician&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;instrument&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Album&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;artist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ForeignKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Musician&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on_delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;release_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DateField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num_starts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;field-types&quot;&gt;Field types&lt;/h3&gt;

&lt;p&gt;모델 안의 각각의 필드는 적당한 &lt;strong&gt;Field&lt;/strong&gt; 클래스 안의 인스턴스여야 합니다. 장고는 다음 몇 가지를 결정하기 위해 필드 클래스 타입들을 사용합니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;칼럼 타입은 어떤 종류의 데이터베이스를 저장할지 알려 줍니다.(e.g.&lt;strong&gt;INTEGER, VARCHAR, TEXT&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;디폴트 HTML 위젯은 폼 필드들을 렌더링 할 때 사용됩니다.(e.g. &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;최소한의 유효성검사(minimal validation)는 장고의 admin과 자동적으로 생성되는 폼에서 사용됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;장고는 수십 개의 내장 필드 타입들을 갖고 있습니다; 그 전체 목록을 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;&lt;/code&gt;에서 확인할 수 있다. 만약 장고의 내장 필드가 제 기능을 못 할 경우, 당신만의 필드를 쉽게 작성할 수 있습니다; &lt;code class=&quot;highlighter-rouge&quot;&gt;Writing custom model fields&lt;/code&gt;를 참조하십시오.&lt;/p&gt;

&lt;h3 id=&quot;field-options&quot;&gt;Field options&lt;/h3&gt;

&lt;p&gt;각각의 필드는 해당 필드에 필수 arguments를 갖고 있습니다(&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;&lt;/code&gt;에 표시되어 있습니다). 예를 들어, &lt;strong&gt;CharField&lt;/strong&gt;(그리고 그것의 하위클래스)는 데이터를 저장하는데 사용되는 &lt;strong&gt;VARCHAR&lt;/strong&gt; 데이터베이스 필드의 사이즈를 명시해주는 &lt;strong&gt;max_length&lt;/strong&gt; argument를 필요로 합니다.&lt;/p&gt;

&lt;p&gt;또한 모든 필드 타입에 적용되는 공통 argument들이 있습니다. 모두 선택적입니다. 이들은 &lt;code class=&quot;highlighter-rouge&quot;&gt;reference&lt;/code&gt;에서 전부 설명되어 있지만, 여기에서는 가장 많이 사용하는 몇 가지만 요약을 하겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://seonkyukim.github.io/reference/Field-options/&quot;&gt;Field options&lt;/a&gt;를 참고하시면 좋을 것 같습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;null&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;True&lt;/strong&gt;일 경우, 장고는 데이터베이스에 빈 값인 &lt;strong&gt;NULL&lt;/strong&gt;값을 저장할 수 있습니다. 초기 값은 &lt;strong&gt;False&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;blank&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;True&lt;/strong&gt;일 경우, 필드는 빈 칸이 있을 수 있습니다. 초기 값은 &lt;strong&gt;False&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;blank는 null과 다릅니다. null은 database-related인 반면, blank는 validation-related입니다. 만약 필드에서 &lt;strong&gt;blank=True&lt;/strong&gt;라면, form validation은 entry의 비어있는 값을 허락합니다. 만약 필드에서 &lt;strong&gt;blank=False&lt;/strong&gt;라면, 그 필드의 값은 항상 요구됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;choices&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2-tuples로 구성된 iteralbe(e.g. list or tuple)을 이 필드의 choices로 사용할 수 있습니다. 만약 choices가 주어지면, 디폴트 폼 위젯은 기본적인 text field가 아니라 select box가 될 것이고, 주어진 choices로 선택권이 제한될 것입니다.&lt;/p&gt;

&lt;p&gt;choices list의 예시는 다음과 같습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;YEAR_IN_SCHOOL_CHOICES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'FR'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Freshman'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'SO'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Sophomore'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'JR'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Junior'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'SR'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Senior'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'GR'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Graduate'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각각의 튜플의 첫 번째 요소는 데이터베이스에 저장되는 값입니다. 두 번째 요소는 필드의 폼 위젯에 나타나는 값(display value)입니다.&lt;/p&gt;

&lt;p&gt;모델 인스턴스가 주어졌을 때, &lt;strong&gt;choices&lt;/strong&gt;를 갖고 있는 필드에서 표시되는 값은 &lt;strong&gt;get_F00_display()&lt;/strong&gt; 메소드를 이용하여 알 수 있습니다. 예시를 보십시오:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SHIRT_SIZES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'S'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Small'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'M'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Medium'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'L'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Large'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;shirt_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;choices&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SHIRT_SIZES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; p &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Person&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Fred Flintsone&quot;&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;shirt_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'L'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; p.save&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; p.shirt_size
&lt;span class=&quot;s1&quot;&gt;'L'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; p.get_shirt_size_display&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;'Large'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;필드의 초기 값 입니다. 하나의 값이나 callable 객체가 될 수 있습니다. 만약 callable하다면 이는 새로운 객체가 생성될 때마다 실행될 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;help_text&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;폼 위젯에 표시될 추가적인 도움말 입니다. 만약 폼에서 해당 필드를 사용하지 않더라도 설명을 표기하는데 유용합니다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;primary_key&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;True&lt;/strong&gt;일 경우, 이 필드는 모델의 primary key가 됩니다.&lt;/p&gt;

&lt;p&gt;만약 모델에서 어떤 필드에도 &lt;strong&gt;primary_key=True&lt;/strong&gt;로 설정해 두지 않았다면, 장고는 자동적으로 primary key로 사용할 &lt;strong&gt;IntegerField&lt;/strong&gt;를 추가합니다. 따라서 이와 같은 기본 primary-key를 오버라이드하고 싶지 않은 이상 어떤 필드에 &lt;strong&gt;primary_key=True&lt;/strong&gt;를 설정할 필요 없습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Automatic primary key fields&lt;/code&gt;에 더 자세히 기술되어 있습니다.&lt;/p&gt;

&lt;p&gt;primary key 필드는 읽을 수만 있습니다. 만약 기존 객체의 primary key 값을 변경한다면, 기존 객체 옆에 새로운 객체가 생성될 것입니다. 예시를 보십시오:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primary_key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; fruit &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Fruit.objects.create&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Apple'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; fruit.name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Pear'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; fruit.save&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Fruit.objects.values_list&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'name'&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;flat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;True&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&amp;lt;QuerySet &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Apple'&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;'Pear'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;unique&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;True&lt;/strong&gt;일 경우, 이 필드는 테이블 전체에서 유일해야 합니다.&lt;/p&gt;

&lt;p&gt;다시 한 번 말하지만, 이들은 모두 공통된 필드 옵션들에 대한 짧은 설명일 뿐입니다. 자세한 내용은 &lt;code class=&quot;highlighter-rouge&quot;&gt;common model field option reference&lt;/code&gt;에 기술되어 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;automatic-primary-key-fields&quot;&gt;Automatic primary key fields&lt;/h3&gt;

&lt;p&gt;초기 값으로, 장고는 각각의 모델에 다음과 같은 필드를 생성합니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AutoField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;primary_key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 자동적으로 증가하는 (auto-incrementing) primary key입니다.&lt;/p&gt;

&lt;p&gt;만약 커스텀 primary key를 사용하고 싶다면, 모델의 필드들 중 하나에 &lt;strong&gt;primary_key=True&lt;/strong&gt;를 명시하십시오. 만약 명시적으로 &lt;strong&gt;Field.primary_key&lt;/strong&gt;를 설정 했다면, 장고는 위의 자동적으로 생성된 &lt;strong&gt;id&lt;/strong&gt; 칼럼을 추가하지 않을 것입니다.&lt;/p&gt;

&lt;p&gt;각각의 모델은 (명시적으로 추가 되었든지 아니면 자동적으로 추가 되었든지간에) 오직 하나의 필드만이 &lt;strong&gt;primary_key=True&lt;/strong&gt;를 갖고 있어야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;verbose-field-names&quot;&gt;Verbose field names&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Verbose name을 직역하면 장황한 이름입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;ForeignKey&lt;/strong&gt;, &lt;strong&gt;ManyToManyField&lt;/strong&gt;와 &lt;strong&gt;OneToOneField&lt;/strong&gt;를 제외하고, 각각의 필드 타입들은 선택적인 첫 번째 argument로 verbose name을 갖습니다. 만약 verbose name이 주어지지 않았다면, 장고는 자동적으로 필드의 attribute 이름의 언더바를 띄어쓰기로 바꾸어 verbose name을 생성합니다.&lt;/p&gt;

&lt;p&gt;이 예시에서 verbose name은 “&lt;strong&gt;person’s first name&lt;/strong&gt;“입니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;person's first name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예시에서 verbose name은 “&lt;strong&gt;first name&lt;/strong&gt;“입니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;ForeignKey&lt;/strong&gt;, &lt;strong&gt;ManyToManyField&lt;/strong&gt;와 &lt;strong&gt;OneToOneField&lt;/strong&gt;는 첫 번째 argument로 모델 클래스가 필요하기 때문에 &lt;strong&gt;verbose_name&lt;/strong&gt; keyword argument를 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;poll&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ForeignKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;on_delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;verbose_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;the related poll&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sites&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ManyToManyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Site&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verbose_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;list of sites&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;place&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OneToOneField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Place&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;on_delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;verbose_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;related place&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;관습적으로 &lt;strong&gt;verbose_name&lt;/strong&gt;의 첫 글자는 대문자를 쓰지 않습니다. 장고가 자동적으로 첫 번째 글자를 대문자로 바꾸어주기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;relationships&quot;&gt;Relationships&lt;/h3&gt;

&lt;p&gt;명확하게, 관계형 데이터베이스의 강점은 테이블간에 관계가 있다는 점입니다. 장고는 가장 많이 사용되는 세 가지 데이터베이스 관계를 정의해 줍니다: 다대일, 다대다 그리고 일대일 관계입니다.&lt;/p&gt;

&lt;h4 id=&quot;many-to-one-relationships&quot;&gt;Many-to-one relationships&lt;/h4&gt;

&lt;p&gt;M:1 관계를 정의하기 위해, &lt;strong&gt;django.db.models.ForeignKey&lt;/strong&gt;를 사용합니다. 이것을 다른 필드 타입처럼 사용하면 됩니다: 모델에 클래스 attribute로 추가하십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ForeignKey&lt;/strong&gt;는 정해진 위치의 필수적 argument를 요구합니다: 모델과 관계된 클래스를 지정합니다.&lt;/p&gt;

&lt;p&gt;예를 들어, &lt;strong&gt;Car&lt;/strong&gt; 모델이 &lt;strong&gt;Manufacturer&lt;/strong&gt;을 갖고 있다면 - 즉, &lt;strong&gt;Manufacturer&lt;/strong&gt;은 다양한 cars를 만들지만 각각의 &lt;strong&gt;Car&lt;/strong&gt;는 단 하나의 &lt;strong&gt;Manufacturer&lt;/strong&gt;를 갖고 있다면 - 다음과 같이 할 수 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Manufacturer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# ...
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;manufacturer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ForeignKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Manufacturer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on_delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# ...
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또한 재귀적 관계(자기 자신에게 다대일 관계를 갖고 있는 객체)을 만들 수 있고 아직 정의되지 않은 모델과의 관계를 만들 수 있습니다; 자세한 사항은 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;&lt;/code&gt;를 참고하십시오.&lt;/p&gt;

&lt;p&gt;필수적인 것은 아니지만, &lt;strong&gt;ForeignKey field&lt;/strong&gt;의 이름(위의 예에서는 &lt;strong&gt;manufacturer&lt;/strong&gt;)은 소문자의 모델 이름을 사용하는 것이 좋습니다. 물론, 원하는 대로 필드 이름을 정해도 됩니다. 예시를 보십시오:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;company_that_makes_it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ForeignKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Manufacturer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;on_delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;ForeignKey&lt;/strong&gt; 필드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;references&lt;/span&gt;&lt;/code&gt;에 설명되어 있는 다른 arguements도 사용할 수 있습니다. 이 옵션들은 관계가 어떻게 작동할지를 규정해 줍니다; 모두 선택적입니다.&lt;br /&gt;backward-related 객체에 접근하는 방법에 대해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Following relationships backward example&lt;/code&gt;을 참고하십시오.&lt;br /&gt;sample code를 보고 싶다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Many-to-one relationship model example&lt;/code&gt;을 참고하십시오.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;many-to-many-relationships&quot;&gt;Many-to-many relationships&lt;/h4&gt;

&lt;p&gt;다대다 관계를 사용하기 위해서는, &lt;strong&gt;ManyToManyField&lt;/strong&gt;를 사용하십시오. 이것을 다른 필드 타입처럼 사용하시면 됩니다: 모델에 클래스 attribute로 추가하십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ManyToManyField&lt;/strong&gt;는 지정된 위치의 필수적 argument를 요구합니다: 관계를 맺을 클래스를 지정합니다.&lt;/p&gt;

&lt;p&gt;예를 들어, &lt;strong&gt;Pizza&lt;/strong&gt; 가 다양한 &lt;strong&gt;Topping&lt;/strong&gt; 객체를 갖고 있다면 - 즉, 한 &lt;strong&gt;Topping&lt;/strong&gt;이 다양한 pizzas에 있을 수 있고 각각의 &lt;strong&gt;Pizza&lt;/strong&gt;도 다양한 toppings를 가질 수 있다면 - 다음과 같이 이를 나타낼 수 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Topping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# ...
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Pizza&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# ...
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;toppings&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ManyToManyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Topping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;ForeignKey&lt;/strong&gt;와 마찬가지로, 재귀적 관계(자기 자신에게 다대다 관계를 갖고 있는 객체)를 만들 수 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;아직 정의되지 않은 model에게 relationship&lt;/code&gt;을 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;필수적인 것은 아니지만, 관계된 모델을 나타내는 &lt;strong&gt;ManyToManyField&lt;/strong&gt;의 이름은 복수형을 하는 것이 좋습니다(위 예에서는 &lt;strong&gt;toppings&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;어떤 모델이 &lt;strong&gt;ManyToManyField&lt;/strong&gt;를 갖고 있는지는 상관 없지만, 두 모델 모두가 아니라 한 쪽에만 설정해야 합니다.&lt;/p&gt;

&lt;p&gt;위의 예시에서는 폼에서 Pizza의 toppings를 선택할 수 있게 해줍니다(&lt;strong&gt;Topping&lt;/strong&gt;이 많은 &lt;strong&gt;pizzas&lt;/strong&gt;를 갖고 있는 것이 아닙니다). 이는 pizza가 많은 topping들이 갖고 있다고 생각하는 것이 topping이 많은 pizza들 위에 있다고 생각하는 것보다 자연스럽기 때문입니다. 이와 같이 일반적으로 &lt;strong&gt;ManyToManyField&lt;/strong&gt; instance는 폼에서 수정되어야 하는 객체 안에 있어야 합니다.&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;전체 예시를 보기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Many-to-many relationship model example&lt;/code&gt;을 참조하십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ManyToManyField&lt;/strong&gt; field는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;references&lt;/span&gt;&lt;/code&gt;에 설명되어 있는 다른 arguements도 사용할 수 있습니다. 이 옵션들은 관계가 어떻게 작동할지 규정합니다; 모두 선택적입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;extra-fields-on-many-to-many-relationships&quot;&gt;Extra fields on many-to-many relationships&lt;/h4&gt;

&lt;p&gt;pizza와 topping과 같은 단순한 many-to-many relationship을 다루고 있다면, &lt;strong&gt;ManyToManyField&lt;/strong&gt;만 사용하시면 됩니다. 하지만, 때때로 relationship이 있는 두 models간의 데이터들을 연결지어야 할 것입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 musicians이 속해있는 musical group이 있는 경우를 생각해보십시오. 여기에는 person과 그들이 멤버로서 속해있는 group들 간의 many-to-many relationship이 있고, 이 관계를 나타내기 위해 &lt;strong&gt;ManyToManyField&lt;/strong&gt;를 사용할 수 있습니다. 그러나, membership과 관련된 세부 사항들, 예를 들어 person들이 group에 들어간 날짜 등이 많이 있다고 가정합시다.&lt;/p&gt;

&lt;p&gt;이러한 상황에서, Django에서는 many-to-many relationship을 관리하는 model을 명시할 수 있습니다. 또한 이 intermidate model에 추가적인 field들을 넣을 수 있습니다. 중간 테이블 역할을 할 model을 알려주는  &lt;strong&gt;through&lt;/strong&gt; argument를 이용하여 중간 model은 &lt;strong&gt;ManyToManyField&lt;/strong&gt;와 연결될 수 있습니다. 우리의 musician 예시는 다음 코드와 같이 쓸 수 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    	
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;members&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ManyToManyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;through&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Membership'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    	
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Membership&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ForeignKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on_delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ForeignKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on_delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;date_joined&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DateField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;invite_reason&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;중간 model을 만들 때는 foreign key를 이용하여 many-to-many relationship에 포함될 model들을 명시적으로 지정해주어야 합니다. 이 명시적 선언은 두 model들이 어떻게 relate되는지 정의합니다.&lt;/p&gt;

&lt;p&gt;다음은 중간 model에서 몇 가지 제약 사항들입니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;intermediate model은 source model(우리의 예에서는 &lt;strong&gt;Group&lt;/strong&gt;)로 향하는 foreign key는 단 하나만 갖고 있어야 합니다. 또는 &lt;strong&gt;ManyToManyField.through_fields&lt;/strong&gt;를 사용하여 Django가 relationship을 위해 사용해야 하는 foreign key를 명시적으로 지정해 주어야 합니다. 만약 한 개 이상의 foreign key를 갖고 있거나 through_fields가 명시되어 있지 않으면 validation error가 발생할 것입니다. 비슷한 제약은 target model(우리의 예에서는 &lt;strong&gt;Person&lt;/strong&gt;)에서도 적용됩니다.
    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;through_fields&lt;/strong&gt;의 내용은 model field reference를 참고해주세요.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;중간 model을 이용하여 자기 자신에게 many-to-many relationship을 갖는 model에 대해서는, 같은 model을 향한 두 개의 foreign key가 있을 수 있습니다. 하지만 그들은 many-to-many relationship에서 서로 다른 측면에 있는 것으로 간주됩니다. 만약 두 개 이상의 foreign key가 있다면, 역시 &lt;strong&gt;through_fields&lt;/strong&gt;를 위와 같이 명시해 주어야 validation error가 발생하지 않을 것입니다.&lt;/li&gt;
  &lt;li&gt;중간 model을 이용하여 자기 자신에게 &lt;strong&gt;many-to-many relationship&lt;/strong&gt;을 정의할 때, &lt;strong&gt;symmetrical=False&lt;/strong&gt; 를 사용해야 합니다(model field reference를 참조하십시오).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 중간 model(예시의 경우 &lt;strong&gt;Membership&lt;/strong&gt;)을 이용하기 위한 &lt;strong&gt;ManyToManyField&lt;/strong&gt; 준비 작업을 마쳤고, many-to-many relationship을 사용할 준비가 되었습니다. intermediate model의 instances를 만들어 사용할 수 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; ringo &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Person.objects.create&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Ringo Starr&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; paul &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Person.objects.create&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Paul McCartney&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; beatles &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Group.objects.create&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;The Beatles&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; m1 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Membership&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ringo, &lt;span class=&quot;nv&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;beatles,
...			&lt;span class=&quot;nv&quot;&gt;date_joined&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1962, 8, 16&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
...	 	 	&lt;span class=&quot;nv&quot;&gt;invite_reason&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Needed a new drummer.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; m1.save&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; beatles.members.all&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&amp;lt;QuerySet &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&amp;lt;Person: ringo Starr&amp;gt;]&amp;gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; ringo.group_set.all&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&amp;lt;QuerySet &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&amp;lt;Group: The Beatles&amp;gt;]&amp;gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; m2 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Membership.objects.create&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;paul, &lt;span class=&quot;nv&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;beatles,
...			&lt;span class=&quot;nv&quot;&gt;date_joined&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1960, 8, 1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
...			&lt;span class=&quot;nv&quot;&gt;invite_reason&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Wanted to form a band.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; beatles.memebers.all&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&amp;lt;QuerySet &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&amp;lt;Person: Ringo starr&amp;gt;, &amp;lt;Person: Paul McCartney&amp;gt;]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;보통의 many-to-many field과는 다르게, relationship을 만들기 위해서 &lt;strong&gt;add()&lt;/strong&gt;, &lt;strong&gt;create()&lt;/strong&gt;, 또는 &lt;strong&gt;set()&lt;/strong&gt; 을  사용할 수 없습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# The following statements will not work&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; beatles.members.add&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;john&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; beatles.members.create&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;George Harrison&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; beatles.members.set&lt;span class=&quot;o&quot;&gt;([&lt;/span&gt;john, paul, ringo, george]&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;왜 그럴까요? 단순히 &lt;strong&gt;Person&lt;/strong&gt;과 &lt;strong&gt;Group&lt;/strong&gt;사이의 relationship을 만들 수 없습니다 - 왜냐하면 &lt;strong&gt;Membership&lt;/strong&gt; model이 필요로 하는 모든 세부 사항들을 명시해 주어야 하기 때문입니다. 단순히 &lt;strong&gt;add&lt;/strong&gt;, &lt;strong&gt;create&lt;/strong&gt; 그리고 assignment call으로는 이러한 추가적인 세부 사항들을 알려줄 방법이 없습니다. 결과적으로, 이들 함수는 중간 model을 이용하는 many-to-many relationship에서 사용 불가능합니다. 이런 종류의 relationship을 만드는 유일한 방법은 intermeidate model의 instance들을 생성하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;remove()&lt;/strong&gt; method도 비슷한 이유로 사용 불가능합니다. 예를 들어, 만약 중간 model의  &lt;code class=&quot;highlighter-rouge&quot;&gt;(model1, model2)&lt;/code&gt;의 유일성이 보장되지 않는다면, &lt;strong&gt;remove()&lt;/strong&gt; 호출은 중간 model의 어떤 instance를 삭제해야 하는지 충분한 정보를 제공하지 않기 때문입니다:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Membership.objects.create&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ringo, &lt;span class=&quot;nv&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;beatles,
...			&lt;span class=&quot;nv&quot;&gt;date_joined&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1968, 9, 4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
...			&lt;span class=&quot;nv&quot;&gt;invite_reason&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;You've been gone for a month and we miss you.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; beatles.members.all&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&amp;lt;QuerySet &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&amp;lt;Person: Ringo Starr&amp;gt;, &amp;lt;Person: Paul McCartney&amp;gt;, 
&amp;lt;Person: Ringo Starr&amp;gt;]&amp;gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# This will not work because it cannot tell which membership to remove&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; beatles.members.remove&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ringo&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나 &lt;strong&gt;clear()&lt;/strong&gt; method는 모든 many-to-many relationships의 instance들을 삭제하기 위해 사용할 수 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Beatles have broken up&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; beatles.members.clear&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Note that this deletes the intermediate model instances&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Membership.objects.all&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&amp;lt;QuerySet &lt;span class=&quot;o&quot;&gt;[]&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일단 중간 model의 instance를 생성하여 many-to-many relationship을 형성했다면, queries를 통해 볼 수 있습니다. 평범한 many-to-many relationship과 마찬가지로, many-to-many로 연결된 model들의 attribute들을 이용하여 query할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Find all the groups with a member whose name starts with 'Paul'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Group.objects.filter&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;members__name__startswith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Paul'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&amp;lt;QuerySet &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&amp;lt;Group: The Beatles&amp;gt;]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또한 중간 model들의 attributes들을 이용하여 query 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Find all the members of the Beatles that joined after 1 Jan 1961&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Person.objects.filter&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
...			&lt;span class=&quot;nv&quot;&gt;group__name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'The Beatles'&lt;/span&gt;,
...			&lt;span class=&quot;nv&quot;&gt;membership__date_joined__gt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1961,1,1&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&amp;lt;QuerySet &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&amp;lt;Person: Ringo Starr]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 membership의 정보들에 접근해야 한다면 &lt;strong&gt;Membership&lt;/strong&gt; model을 직접적으로 query 할 수 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; ringos_membership &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Membership.objects.get&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;beatles, &lt;span class=&quot;nv&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ringo&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; ringos_membership.date_joined
datetime.date&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1962, 8, 16&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; ringos_membership.invite_reason
&lt;span class=&quot;s1&quot;&gt;'Needed a new drummer.'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;같은 정보에 접근할 수 있는 또 다른 방법은 &lt;strong&gt;Person&lt;/strong&gt; object로부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;many-to-many reverse relationship&lt;/code&gt;을 querying하는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; ringos_membership &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; ringo.membership_set.get&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;beatles&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; ringos_membership.date_joined
datetime.date&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1962, 8, 16&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; ringos_membership.invite_reason
&lt;span class=&quot;s1&quot;&gt;'Needed a new drummer.'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;one-to-one-relationships&quot;&gt;One-to-one relationships&lt;/h3&gt;

&lt;p&gt;one-to-one relationship을 정의하기 위해, &lt;strong&gt;OneToOneField&lt;/strong&gt;를 사용하십시오. 어느 다른 &lt;strong&gt;Field&lt;/strong&gt; type처럼 이용하면 됩니다: model의 class attribute로 추가하십시오.&lt;/p&gt;

&lt;p&gt;이것은 한 객체가 다른 객체를 “extends” 하고 있을 때 객체의 primary key에서 사용하면 가장 유용합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OneToOneField&lt;/strong&gt;는 지정된 위치의 필수 argument를 요구합니다: 모델과 relate된 class를 지정합니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 만약 “places”라는 데이터베이스를 만들고 있다면, address, phone number 등과 같이 평범한 내용들을 데이터 베이스에 포함할 것이다. 그리고 나서, 그 place들 위에 restaurant들의 데이터 베이스를 세우고 싶다면, &lt;strong&gt;Restaurant&lt;/strong&gt; model에 그 fields들을 붙여넣는 것 대신에, &lt;strong&gt;Restaurant&lt;/strong&gt;가 &lt;strong&gt;Place&lt;/strong&gt;로 &lt;strong&gt;OneToOneField&lt;/strong&gt;를 갖게 만들어 주면 됩니다(왜냐하면 reataurant “is a” place이기 때문이다; 사실, 이을 위해 전형적으로 상속을 사용하는데, 이것은 암묵적으로 one-to-one relation을 갖습니다).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ForeignKey&lt;/strong&gt; 와 함께 &lt;code class=&quot;highlighter-rouge&quot;&gt;recursive relationship&lt;/code&gt;은 정의될 수 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;references to as-yet undefined model&lt;/code&gt;도 만들어 질 수 있습니다.&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;전체 예시를 보기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;One-to-one relationship model example&lt;/code&gt;을 참고하십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OneToOneField&lt;/strong&gt;는 또한 optional &lt;strong&gt;parent_link&lt;/strong&gt; argument를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OneToOneField&lt;/strong&gt; class들은 자동적으로 model의 primary key에 연결되곤 했습니다. 하지만 더 이상 그렇지 않습니다(직접 &lt;strong&gt;primary_key&lt;/strong&gt; argument들을 넘겨주어도 말입니다). 그러므로, 이제 하나의 model에서 OneToOneField type의 다양한 field를 갖는 것이 가능합니다.&lt;/p&gt;

&lt;h2 id=&quot;models-across-files&quot;&gt;Models across files&lt;/h2&gt;

&lt;p&gt;한 model에서 다른 app에 있는 model로 relate를 할 수 있습니다. 이를 위해 당신의 모델이 정의되어 있는 파일 가장 위에 related model을 import해야 합니다. 이후, 필요한 곳 어디든지 그 다른 model class를 참조하면 됩니다. 예를 보십시오:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;geography.models&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZipCode&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Restaurant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# ...
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;zipe_code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ForeignKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ZipCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;on_delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SET_NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;blank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;field-name-restrictions&quot;&gt;Field name restrictions&lt;/h2&gt;

&lt;p&gt;Django는 model field 이름에 단 두 가지 제약만이 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;field name은 Python reserved word가 될 수 없습니다. 왜냐하면 이는 Python syntax error를 발생시킬 것입니다. 예시를 보십시오:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 'pass' is a reserved word!
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;field name은 두 개 이상의 underscore을 가질 수 없는데, 이는 Django의 query lookup syntax words이기 때문입니다. 예시를 보십시오:&lt;/p&gt;
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;foo__bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 'foo__bar' has two underscores!
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 제약 사항들은 피해갈 수 있습니다. 왜냐하면 field name은 database column 이름과 꼭 같을 필요가 없기 때문입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;db_column&lt;/code&gt; option을 참조하십시오.&lt;/p&gt;

&lt;p&gt;SQL reserved words, 예를 들어 &lt;strong&gt;join&lt;/strong&gt;, &lt;strong&gt;where&lt;/strong&gt; 또는 &lt;strong&gt;select&lt;/strong&gt;는 model field name으로 사용할 수 있는데, 왜냐하면 Django는 기본 SQL query에 있는 모든 database table 이름과 column 이름들을 직접적으로 사용하지 않기 때문입니다. 그것은 너의 특정 database 엔진의 quoting syntax를 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;custom-field-types&quot;&gt;Custom field types&lt;/h2&gt;

&lt;p&gt;만약 기존의 model fields들을 목적에 맞게 사용할 수 없다면, 또는 일반적으로 사용되지 않는 database column type을 이용하려면 자체적인 field class를 만들 수 있다. 고유의 field를 만드는 전체 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Writing custom model fields&lt;/code&gt;에 나와 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;meta-options&quot;&gt;Meta options&lt;/h1&gt;

&lt;p&gt;inner &lt;strong&gt;class Meta&lt;/strong&gt;를 다음과 같이 사용하여 model에게 metadata를 줄 수 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;horn_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
       
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ordering&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;horn_length&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;verbose_name_plural&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;oxen&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Model의 metadata는 “field가 아닌 모든 것”입니다. 예를 들어 ordering options(&lt;strong&gt;ordering&lt;/strong&gt;), database table name(&lt;strong&gt;db_table&lt;/strong&gt;), 또는 사람이 읽을 수 있는 복수형 또는 단수형 이름들(&lt;strong&gt;verbose_name&lt;/strong&gt; 그리고 &lt;strong&gt;verbose_name_plural&lt;/strong&gt;)이 있습니다. 모두 필수는 아니고 &lt;strong&gt;class Meta&lt;/strong&gt;를 model에 추가하는 것은 전적으로 optional입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Meta&lt;/strong&gt; option에 대한 전체 목록은 model option reference에서 확인 할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;model-attributes&quot;&gt;Model attributes&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;objects&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;model의 가장 중요한 attribute는 &lt;strong&gt;Manager&lt;/strong&gt;입니다. 이는 interface인데 database query operation들이 이를 통해 Django model로 제공되고 database로부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;retrieve the instances&lt;/code&gt; 하는데 사용됩니다. 만약 custom &lt;strong&gt;Manager&lt;/strong&gt;가 정의되지 않는다면, 초기 이름은 &lt;strong&gt;objects&lt;/strong&gt;입니다. Managers은 model instance가 아니라, 단지 model class를 통해서만 접근 할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;model-methods&quot;&gt;Model methods&lt;/h1&gt;

&lt;p&gt;객체를 위한 custom “row-level” 기능을 model에 추가하기 위해 custom method를 정의하십시오. &lt;strong&gt;Manager&lt;/strong&gt; mehods들은 “table-wide” 관련 작업들을 하기 위해 만들어진 반면, model methods는 특정 model instance에 대해 작동합니다.&lt;/p&gt;

&lt;p&gt;이는 business logic을 한 곳(model)에 유지하기 위한 값진 기술입니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 다음 model은 몇 개의 custom method를 갖고 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;birth_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DateField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;baby_boomer_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Returns the person's baby-boomer status.&quot;&lt;/span&gt;
        &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;datetime&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;birth_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1945&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Pre-boomer&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;birth_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1965&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Baby boomer&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Post-boomer&quot;&lt;/span&gt;
    
    &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;property&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;full_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Returns the person's full name.&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예시의 마지막 method는 &lt;code class=&quot;highlighter-rouge&quot;&gt;property&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;model &lt;code class=&quot;highlighter-rouge&quot;&gt;instance reference&lt;/code&gt;에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;각각의 model에게 자동적으로 주어진 mothod&lt;/code&gt;들의 전체 리스트가 있습니다. 이들을 override할 수 있습니다 - &lt;code class=&quot;highlighter-rouge&quot;&gt;overriding predefined model methods&lt;/code&gt;를 참고하십시오 - 그러나 거의 항상 정의해야 할 몇 가지 method들이 있습니다:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;__str__()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;모든 object의 문자 표현을 반환하는 Python의 “magic method”이다. model instance가 순수 string으로 표현되어야 할 때마다 Python과 Django이 이를 호출할 것입니다. 제일 알아 두어야 할 것은, 이는 대화형 console이나 admin에 obejct를 표시해야 할 때 일어납니다.&lt;/p&gt;

&lt;p&gt;항상 이 mothod를 정의하고 싶어할 것입니다; 초기 값이 전혀 도움이 되지 않기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;get_absolute_url()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이는 Django에게 한 object에 대해 URL을 어떻게 계산할지 알려줍니다. Django는 이를 그것의 admin interface 안에서 사용하거나 한 객체의 URL을 알아내야 할 때 필요합니다.&lt;/p&gt;

&lt;p&gt;object를 고유하게 식별하는 URL을 가진 object는 이 method를 정의해야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;overriding-predefined-model-methods&quot;&gt;Overriding predefined model methods&lt;/h2&gt;

&lt;p&gt;데이터 베이스 동작을 encapsulate하고 있는 또 다른 종류의 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;/code&gt; 집합이 있고, 이를 customize하고 싶을 것입니다. 특히 &lt;strong&gt;save()&lt;/strong&gt;와 &lt;strong&gt;delete()&lt;/strong&gt;가 동작하는 방법을 종종 바꾸고 싶을 것입니다.&lt;/p&gt;

&lt;p&gt;자유롭게 이 methods(그리고 다른 model methods) 역시 override할 수 있고 동작을 바꿀 수 있습니다.&lt;/p&gt;

&lt;p&gt;내장 method들을 override하는 전형적인 경우는 object를 저장할 때마다 어떤 일이 일어나게 하고 싶을 때 입니다. 예시를 보십시오( &lt;strong&gt;save()&lt;/strong&gt;에서 받아들이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;parameter의 문서&lt;/code&gt;를 참조하십시오):&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Blog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tagline&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TextFeild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;do_something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;do_something_else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또한 잘못된 저장을 방지할 수 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Blog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tagline&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TextField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Yoko One's blog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# Yoko shall never have her own blog!
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;nb&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# Call the &quot;real&quot; save() method
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;database에 object가 저장되는 것을 확실히 하기 위해 superclass의 method를 호출해야 하는 것을 기억하십시오 - 바로 &lt;strong&gt;super.save(*args, **kwargs)&lt;/strong&gt; 입니다. 만약 superclass의 method를 호출하는 것을 잊는다면, default behavior은 발생하지 않을 것이고 database는 변하지 않을 것입니다.&lt;/p&gt;

&lt;p&gt;또한 model method 에 사용되는 parameter를 전달하는 것이 중요합니다 - 바로 &lt;strong&gt;&lt;em&gt;args, **kwargs**들이 그렇게 해줍니다. Django는 수시로 새로운 argument를 추가하면서 내장된 model method 기능들을 확장합니다. 만약 method를 정의할 때 **&lt;/em&gt;args&lt;/strong&gt;, &lt;strong&gt;**kwargs&lt;/strong&gt;를 사용한다면, 당신의 코드는 argument들이 추가될 때 자동적으로 이들을 지원할 것입니다.&lt;/p&gt;

&lt;p class=&quot;notice--success&quot;&gt;&lt;strong&gt;Overriden model methods are not called on bulk operations&lt;/strong&gt;   &lt;code class=&quot;highlighter-rouge&quot;&gt;deleting objects in bulk using a QuerySet&lt;/code&gt;을 하거나 &lt;strong&gt;cascading delete&lt;/strong&gt;의 결과로 삭제 될 때 객체의 &lt;strong&gt;delete()&lt;/strong&gt; method는 항상 호출되지는 않습니다. customized delete logic이 실행 되었는지 확인하고 싶다면, &lt;strong&gt;pre_delete&lt;/strong&gt; 또는 &lt;strong&gt;post_delete&lt;/strong&gt;를 사용할 수 있습니다.  불행히도 bulk로 객체를 생성하거나 업데이트 할 때는 해결할 수 있는 방법이 없습니다. 왜냐하면 &lt;strong&gt;save()&lt;/strong&gt;, &lt;strong&gt;pre_save&lt;/strong&gt;, 그리고 &lt;strong&gt;post_save&lt;/strong&gt; 그 어느 것도 호출되지 않기 때문입니다.&lt;/p&gt;

&lt;h2 id=&quot;executing-custom-sql&quot;&gt;Executing custom SQL&lt;/h2&gt;

&lt;p&gt;다른 일반적인 패턴은 custom SQL statements를 model method와 module-level method에 작성하는 것입니다. raw SQL을 사용하는데 더 세부적인 사항은 &lt;code class=&quot;highlighter-rouge&quot;&gt;using raw SQL&lt;/code&gt; 을 참조하십시오.&lt;/p&gt;

&lt;h1 id=&quot;model-inheritance&quot;&gt;Model inheritance&lt;/h1&gt;

&lt;p&gt;Django에서의 model inheritance는 Python에서 일반적인 class inheritance와 거의 동일하게 작동하지만, &lt;a href=&quot;https://seonkyukim.github.io/reference/Introduction-to-models-1&quot;&gt;Introduction-to-models-1&lt;/a&gt;의 시작 부분 기초 사항들은 따라야 합니다. 즉, base class 역시 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.db.models.Model&lt;/code&gt;&lt;/strong&gt;의 하위 클래스여야 합니다.&lt;/p&gt;

&lt;p&gt;당신은 부모 모델이 (자신의 데이터베이스 테이블을 갖고 있는) 고유의 모델이 될 것인지, 아니면 부모 모델이 단지 자식 class들을 통해서만 볼 수 있는 공통된 정보들을 담고 있을 것인지만 결정하면 됩니다.&lt;/p&gt;

&lt;p&gt;다음은 Django에서 가능한 세 가지 유형의 inheritance입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;종종 부모 클래스가 각 하위 모델에 입력하고 싶지 않은 정보들을 보유하기를 원할 것입니다. 이 class는 따로 분리하여 사용하지 않으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Abstract base classes&lt;/code&gt; 를 보시면 됩니다.&lt;/li&gt;
  &lt;li&gt;(아마 완전히 다른 application으로 부터) 이미 존재하는 모델을 상속 받기 원하고 각각의 model이 그들의 database table을 갖고 있기를 원하는 경우, &lt;code class=&quot;highlighter-rouge&quot;&gt;Multi-table inheritnace&lt;/code&gt;를 살펴보십시오.&lt;/li&gt;
  &lt;li&gt;마지막으로 model field를 수정하지 않고 단지 model의 Python-level behavior를 수정하기 원하는 경우, &lt;code class=&quot;highlighter-rouge&quot;&gt;Proxy models&lt;/code&gt;를 사용할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;abstract-base-classes&quot;&gt;Abstract base classes&lt;/h2&gt;

&lt;p&gt;abstract base classes는 다수의 다른 모델들에게 공통된 정보들을 담고 싶을 때 유용합니다. &lt;strong&gt;base class&lt;/strong&gt;를 작성하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class에 &lt;strong&gt;abstract=True&lt;/strong&gt;라고 설정하면 됩니다. 그러면 이 모델은 데이터베이스를 만드는데 사용되지 않습니다. 대신에 이것이 다른 모델들을 위한 base class로 사용될 때, 이것의 field들이 child class의 필드에 추가됩니다.&lt;/p&gt;

&lt;p&gt;다음 예시를 보십시오 :&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CommonInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PositiveIntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;abstract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CommonInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;home_group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Student&lt;/strong&gt; 모델은 세 가지 필드를 갖게 될 것입니다: &lt;strong&gt;name&lt;/strong&gt;, &lt;strong&gt;age&lt;/strong&gt;, 그리고 &lt;strong&gt;home_group&lt;/strong&gt;입니다. &lt;strong&gt;CommonInfo&lt;/strong&gt; 모델은 abstract base class이기 때문에 보통의 장고 모델처럼 사용될 수 없습니다.  이 모델은 데이터베이스 테이블을 생성하지 않고 manager를 갖고 있지 않으며 instantiated 될 수 없고 직접적으로 저장 될 수 없습니다.&lt;/p&gt;

&lt;p&gt;abstract base classes로부터 상속된 필드들은 또 다른 필드나 값으로 override 할 수 있고 &lt;strong&gt;None&lt;/strong&gt;으로 제거 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;많은 용도로 이런 종류의 model inheritance 원하실 것입니다. 이것은 Python level에서 공통 정보를 분석하는 방법을 제공하면서 동시에 database level에서는 자식 모델 당 하나의 데이터베이스 테이블을 만듭니다.&lt;/p&gt;

&lt;h3 id=&quot;meta-inheritance&quot;&gt;Meta inheritance&lt;/h3&gt;

&lt;p&gt;abstract base class가 생성될 때, Django는 base class에서 선언 한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; inner class를 attribute로 사용할 수 있게 합니다. 만약 자식 class가 그것 고유의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class를 선언하지 않았을 경우, 그것은 부모의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt;를 상속받습니다. 만약 자식이 부모의 Meta class를 extend하고 싶다면, 상속받으면 됩니다. 예시를 보십시오:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CommonInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# ...
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ordering&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'name'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CommonInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# ...
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CommonInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;db_table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'student_info'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django는 abstract base class의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class에 단 하나의 값을 조정합니다: &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; attribute를 installing하기 전에, &lt;strong&gt;abstract=False&lt;/strong&gt;로 설정합니다. 이것은 abstract base classes의 자식들이 자동적으로 abstract class가 되지 않는다는 것을 의미합니다. 물론, 다른 abstract base class로부터 상속받는 또 다른 abstract base class를 만들 수 있습니다. 매번 명시적으로 &lt;strong&gt;abstract=True&lt;/strong&gt;라고 설정해야 한다는 것을 기억하십시오.&lt;/p&gt;

&lt;p&gt;몇몇 attribute들은 abstract base class의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class 안에 있기에 부적합합니다. 예를 들어 &lt;strong&gt;db_table&lt;/strong&gt;가  &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class 안에 있을 경우, (그들 고유의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt;를 명시하지 않은) 모든 자식 class들이 모두 같은 데치터베이스 테이블을 이용한다는 것인데, 이것은 원하는 작업 아닐 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;be-careful-with-related_name-and-related_query_name&quot;&gt;Be careful with related_name and related_query_name&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;ForeignKey&lt;/strong&gt; 또는 &lt;strong&gt;ManyToManyField&lt;/strong&gt;에서 &lt;strong&gt;related_name&lt;/strong&gt; 또는 &lt;strong&gt;related_query_name&lt;/strong&gt;을 사용할 경우, 항상 필드에 대한 &lt;em&gt;unique&lt;/em&gt; reverse name과 query name을 반드시 명시해 주어야 합니다. 이것은 보통 abstract base class에서 문제를 유발합니다. 왜냐하면 이 class에 있는 필드들이 각각의 자식 클래스에 포함되는데, 매번 같은 값의 (&lt;strong&gt;related_name&lt;/strong&gt;과 &lt;strong&gt;related_query_name&lt;/strong&gt;을 포함하는) attribute를 갖게 되기 때문입니다..&lt;/p&gt;

&lt;p&gt;abstract base class에서 &lt;strong&gt;related_name&lt;/strong&gt; 또는 &lt;strong&gt;related_query_name&lt;/strong&gt;을 사용할 때 이 문제를 해결하기 위해서는, value의 일부분이 &lt;strong&gt;%(app_label)s&lt;/strong&gt;와 &lt;strong&gt;%(class)s&lt;/strong&gt;를 포함하고 있어야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;%(class)s&lt;/strong&gt;는 필드가 사용되는 자식 class의 소문자 이름으로 대체됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;%(app_label)s&lt;/strong&gt;는 자식 class가 포함되어 있는 app의 소문자 이름으로 대체됩니다. 각각의 installed applicatoin은 유일하고 app 안에 있는 model class 이름도 유일하기 때문에, 최종 이름은 서로 다르게 될 것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어 &lt;strong&gt;comon/models.py&lt;/strong&gt;에 다음과 같은 app이 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m2m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ManyToManyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;OtherModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;related_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%(app_label)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s_&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%(class)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s_related&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;related_query_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%(app_label)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s_&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%(class)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;ss&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    	
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ChildA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ChildB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;rare/models.py&lt;/strong&gt;에도 다음 app이 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;common.models&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Base&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ChildB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;common.ChildA.m2m&lt;/strong&gt; 필드의 reverse name은 &lt;strong&gt;common_childa_related&lt;/strong&gt;가 될 것이고 reverse query name은 &lt;strong&gt;common_childas&lt;/strong&gt;가 될 것입니다. &lt;strong&gt;common.childB.m2m&lt;/strong&gt; 필드의 reverse name은 &lt;strong&gt;common_childb_related&lt;/strong&gt;가 될 것이고 reverse query name은 &lt;strong&gt;common_chlidbs&lt;/strong&gt;가 될 것입니다. 마지막으로 &lt;strong&gt;rare.ChildB.m2m&lt;/strong&gt; 필드의 reverse name은 &lt;strong&gt;rare_childb_related&lt;/strong&gt;가 될 것이고 reverse query name은 &lt;strong&gt;rare_childbs&lt;/strong&gt;가 될 것이다. related name이나 related query name을 구성하기 위해 &lt;strong&gt;%(class)s&lt;/strong&gt;와 &lt;strong&gt;%(app_label)s&lt;/strong&gt; 부분들을 어떻게 사용하는지는 당신에게 달려있지만, 이것을 사용하지 않을 경우, Django는 system check(또는 &lt;strong&gt;migrate&lt;/strong&gt;)를 사용할 때 error를 일으킬 것입니다.&lt;/p&gt;

&lt;p&gt;abstract base class의 필드에 대한 &lt;strong&gt;related_name&lt;/strong&gt; attribute를 명시하지 않은 경우, default reverse name은 child class 이름 뒤에 &lt;strong&gt;_set&lt;/strong&gt;이 붙은 것이 될 것이고, child class에 직접적으로 선언한 것처럼 정상적으로 작동할 것입니다. 예를 들어 위의 코드에서, &lt;strong&gt;related_name&lt;/strong&gt; attribute가 생략 되었다면, &lt;strong&gt;m2m&lt;/strong&gt; 필드의 reverse name은 &lt;strong&gt;ChildA&lt;/strong&gt;의 경우 &lt;strong&gt;childa_set&lt;/strong&gt;이 될 것이고 &lt;strong&gt;ChildB&lt;/strong&gt;의 경우 &lt;strong&gt;childb_set&lt;/strong&gt;이 될 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;multi-table-inheritance&quot;&gt;Multi-table inheritance&lt;/h2&gt;

&lt;p&gt;Django에서 지원하는 두 번째 타입의 model inheritance는 계층 구조의 각 모델이 모두 그것 고유의 모델일 때입니다. 각각의 모델은 그들 고유의 데이터베이스 테이블에 대응되고 독립적으로 queried 되고 생성될 수 있습니다. inheritance relationship은 자식 모델과 그들의 부모 사이의 links를 (자동적으로 생성되는 &lt;strong&gt;OneToOneField&lt;/strong&gt;를 통해서) 줍니다. 예시를 보십시오:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Place&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Restaurant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Place&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;serves_hot_dogs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BooleanField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;serves_pizza&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BooleanField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;데이터들은 서로 다른 데이터베이스 테이블에 있음에도 불구하고 &lt;strong&gt;Place&lt;/strong&gt;의 모든 필드들은 &lt;strong&gt;Restaurant&lt;/strong&gt;에서도 모두 이용 가능합니다. 따라서 다음 두 가지가 모두 가능합니다:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Place.objects.filter&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Bob's Cafe&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Restaurant.objects.filter&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Bob's Cafe&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Restaurant&lt;/strong&gt; 이기도 한 &lt;strong&gt;Place&lt;/strong&gt;를 갖고 있을 경우, &lt;strong&gt;Place&lt;/strong&gt; 객체로부터 소문자 모델 이름을 이용하여 &lt;strong&gt;Restaurant&lt;/strong&gt; 객체를 얻을 수 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; p &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Place.objects.get&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;12&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# If p is a Restaurant object, this will give the child class:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; p.restaurant
&amp;lt;Restaurant: ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나 위 예시에서의 &lt;strong&gt;p&lt;/strong&gt;가 &lt;strong&gt;Restaurant&lt;/strong&gt;이 아닐 경우(그것이 &lt;strong&gt;Place&lt;/strong&gt; 객체로부터 직접적으로 생성되었거나 다른 class의 부모였다면), &lt;strong&gt;p.restaurant&lt;/strong&gt;를 호출하는 것은 &lt;strong&gt;Restaurant.DoesNotExist&lt;/strong&gt; exception을 일으킬 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Restaurant&lt;/strong&gt;에 자동적으로 생성된 &lt;strong&gt;Place&lt;/strong&gt;로 link해주는 &lt;strong&gt;OneToOneField&lt;/strong&gt;는 다음과 같이 생겼습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;place_ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OneToOneField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Place&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on_delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parent_link&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 필드를 &lt;strong&gt;Restaurant&lt;/strong&gt;에 &lt;strong&gt;parent_link=True&lt;/strong&gt; 와 함께 고유의 &lt;strong&gt;OneToOneField&lt;/strong&gt;를 선언함으로써 override할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;meta-and-multi-table-inheritance&quot;&gt;Meta and multi-table inheritance&lt;/h3&gt;

&lt;p&gt;multi-table inheritance의 경우에, 자식 class에서 부모의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class를 상속받는 것은 말이 되지 않습니다. 모든 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; option들은 이미 부모 class에 적용되었고, 그들을 다시 적용하는 것은 보통 모순적인 행동입니다(abstract base class와는 반대인데, base class는 그들 스스로는 존재하지 않습니다).&lt;/p&gt;

&lt;p&gt;따라서 자식 model은 그들 부모의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class에 접근할 수 없다. 그러나 부모로부터 몇 가지 행동을 상속받는 경우가 있다: 만약 자식이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ordering&lt;/code&gt;&lt;/strong&gt; attribute 또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_latest_by&lt;/code&gt;&lt;/strong&gt; attribute를 명시하지 않는다면, 자식은 부모로부터 이들을 상속받을 것이다.&lt;/p&gt;

&lt;p&gt;만약 부모가 ordering을 갖고 있고 너는 자식이 아무런 ordering을 갖지 않기를 원하면, 명시적으로 사용을 중단 할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ChildModel(ParentModel):
	# ...
	class Meta:
		# Remove parent's ordering effect
		ordering = []
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Inheritance and reverse relations&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;multi-table inheritance가 자식과 부모를 link하기 위해 암묵적인 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 사용했기 때문에, 위의 예시처럼 부모에서 자식으로 내려가는 것이 가능하다. 하지만, 이는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; 와 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;의 default &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; 값을 사용해 나간다. 만약 너가 부모의 자식 class에 이런 종류의 relations를 둔다면, 너는 반드시 각각의 field에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; attribute를 명시해야 한다. 만약 그렇지 않으면, Django는 validation error를 일으킬 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어, 위의 &lt;strong&gt;Place&lt;/strong&gt; class 를 다시 사용하여 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 이용한 다른 자식 class를 만들자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Supplier(Place):
	customers = models.ManyToManyField(Place)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 error 결과이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Reverse query name for 'Supplier.customers'
clashes with reverse query
name for 'Supplier.place_ptr'.

HINT: Add or Change a related_name argument to the fefinition for
'Supplier.customers' or 'Supplier.place_ptr'.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 &lt;strong&gt;customers&lt;/strong&gt; field에 &lt;strong&gt;related_name&lt;/strong&gt;을 추가 해주는 것은 error를 해결할 수 있다: &lt;strong&gt;models.ManyToManyField(Place, related_name=’provider’)&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Specifying the parent link field&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위에서 말했듯이, Django는 너의 자식 class와 그 어떤 non-abstract parent model과 연결해주는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 자동적으로 생성할 것이다. 만약 다시 부모로 연결해주는 attribute 이름을 제어하고 싶은 경우, 너는 너만의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 생성하고 너의 field가 부모 class를 다시 가리키도록 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;parent_link=True&lt;/code&gt;&lt;/strong&gt;라고 설정하면 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;proxy-models&quot;&gt;Proxy models&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;multi-table inheritance&lt;/code&gt;를 사용할 때, 새로운 database table은 한 model의 각각의 하위 class에 대해 생긴다. 이는 보통 이상적인 행동인데, 이는 하위 class가 base class에 존재하지 않는 추가적인 data field를 저장할 공간을 필요로 하기 때문이다. 하지만 때때로, 너는 단지 한 model의 Python 동작을 바꾸고 싶을 것이다 - 아마 default manager를 바꾸거나 새로운 method를 추가할 것이다.&lt;/p&gt;

&lt;p&gt;이는 proxy model inheritance을 위한 것이다: 원래 model에 &lt;em&gt;proxy&lt;/em&gt;를 생성하는 것이다. 너는 proxy model의 instances를 생성하고 삭제하고 업데이트 할 수 있으며, 모든 data들은 너가 원래의 (non-proxied) model을 사용하는 것과 같이 저장된다. 차이점은 원래의 것을 변경하지 않고, proxy에서 default model ordering 또는 default manager과 같은 것들을 바꿀 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;Proxy model들은 보통의 model들과 같이 선언될 수 있다. 너는 Django에게 &lt;strong&gt;Meta&lt;/strong&gt; class의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy&lt;/code&gt;&lt;/strong&gt; attribute을 &lt;strong&gt;True&lt;/strong&gt;로 설정함으로써 알려줄 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어, Person model에 method를 추가하고 싶다고 가정하자. 너는 다음과 같이 할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Model):
	first_name = models.CharField(max_length=30)
	last_name = models.CharField(max_length=30)

class MyPerson(Person):
	class Meta:
		proxy = True

	def do_something(self):
		# ...
		pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;MyPerson&lt;/strong&gt; class는 그것의 부모 &lt;strong&gt;Person&lt;/strong&gt; class와 같은 database table에서 작동한다. 특히, 모든 새로운 Person instance들 또한 MyPerson을 통해 접근 가능하고, 반대의 경우도 가능하다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = Person.objects.create(first_name=&quot;foobar&quot;)
&amp;gt;&amp;gt;&amp;gt; MyPerson.objects.get(first_name=&quot;foobar&quot;)
&amp;lt;MyPerson: foobar&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 또한 model에서 다른 default ordering을 정의하기 위해 proxy model을 사용할 수 있다. 너는 아마 항상 &lt;strong&gt;Person&lt;/strong&gt; model을 정렬하고 싶지 않을 수 있지만, proxy를 사용할 때 규칙적으로 &lt;strong&gt;last_name&lt;/strong&gt; attribute를 이용하여 정렬할 수 있다. 이것은 쉽다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class OrderedPerson(Person):
	class Meta:
		ordering = [&quot;last_name&quot;]
		proxy = True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 보통의 &lt;strong&gt;Person&lt;/strong&gt; queries는 정렬되지 않지만, &lt;strong&gt;OrderedPerson&lt;/strong&gt; queries는 &lt;strong&gt;last_name&lt;/strong&gt;에 의해 정렬될 것이다.&lt;/p&gt;

&lt;p&gt;Proxy model은 &lt;code class=&quot;highlighter-rouge&quot;&gt;보통의 model들과 같은 방법으로&lt;/code&gt; &lt;strong&gt;Meta&lt;/strong&gt; attribute를 상속 받는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;QuerySets still return the model that was requested&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;말하자면, 너가 &lt;strong&gt;Person&lt;/strong&gt; objects를 query 할 때마다 Django가 &lt;strong&gt;MyPerson&lt;/strong&gt; object를 반환하게 하는 방법은 없다. &lt;strong&gt;Person&lt;/strong&gt; objects의 queryset은 그 타입의 objects를 반환할 것이다. proxy objects의 요점은 원래의 Person에 의존적인 코드는 proxy objects를 사용할 것이라는 점과 너 고유의 코드는 너가 추가한 extension들을 사용할 수 있다는 점이다(다른 코드는 그다지 의존적이지 않다). 이는 Person (또는 어떠한 다른) model을 너가 만든 다른 것으로 대체할 수 있는 것이 아니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Base class restrictions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;proxy model은 반드시 하나의non-abstract model class로
 부터 상속을 받아야 한다. 너는 여러 개의 non-abstract models로부터 상속받을 수 없는데, 이는 proxy model은 다른 database table에 있는 rows들 간의 어떤 연결도 제공하지 않기 때문이다. abstract model classes이 어떠한 model fields도 정의하지 않았다면, proxy model은 많은 수의 abstract model classes을 상속할 수 있다. 한 proxy model은 공통의 한 non-abstract 부모 class를 공유하고 있는 여러 proxy models로부터 상속 받을 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Proxy model managers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 너가 한 proxy model에 어떠한 model manager도 명시하지 않는다면, 그것은 그것의 model parents로부터 managers를 상속한다. 만약 너가 proxy model에 manager를 정의한다면, 그것은 default가 될 것이지만,  부모 classes에 정의된 어떠한 manager도 여전히 사용 가능하다.&lt;/p&gt;

&lt;p&gt;위의 예시를 이어 가자면, 너는 다음과 같이 &lt;strong&gt;Person&lt;/strong&gt; model을 query할 때 default manager를 바꿀 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class NewManager(models.Manager):
	# ...
	pass

class MyPerson(Person):
	objects = NewManager()

	class Meta:
		proxy = True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 proxy에 이미 존재하는 default를 대체하지 않고 새로운 manager를 추가하고 싶다면, 너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;custom manager&lt;/code&gt; 문서에 기술된 방법들을 사용할 수 있다: 새로운 manager를 갖고 있는 base class를 생성한 뒤에 primary base class 이후에 상속 받아라.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Create an abstract class for the new manager.
class ExtraManagers(models.Model):
	secondary = NewManager()
	
	class Meta:
		abstract = True

class MyPerson(Person, ExtraManagers):
	class Meta:
		proxy = True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 이를 자주 필요로 하지는 않을 것이지만, 너가 하고 싶을 때 이는 가능하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Differences between proxy inheritance and unmanaged models&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;proxy model inheritance는 model의 &lt;strong&gt;Meta&lt;/strong&gt; class에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;managed&lt;/code&gt;&lt;/strong&gt; attribute를 사용하여 unmanaged model을 생성하는 것과 비슷하게 보인다.&lt;/p&gt;

&lt;p&gt;조심스럽게 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Meta.db_table&lt;/code&gt;&lt;/strong&gt;를 설정하여 너는 기존의 model을 가리고 Python method를 거기에 추가할 수 있는 unmanaged model을 생성할 수 있다. 그러나 변경 작업을 수행하면 두 복사본을 동기화 된 상태로 유지해야 하므로 반복적이고 오류가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;다른 한편으로는 proxy model은 proxing 하고 있는 모델과 똑같이 행동하도록 만들어졌다. 그들은 부모 model과 항상 동기화 되어 있는데 그들이 직접적으로 그들의 field와 manager를 상속 받았기 때문이다.&lt;/p&gt;

&lt;p&gt;일반적인 규칙은 다음과 같다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;만약 기존의 model과 database table을 mirroring하고 기존의 모든 database table column들을 원하지 않는다면, Meta.managed=False를 써라. 이 option은 Django가 제어하지 않는 database view와 table을 modeling 할 때 유용하다.&lt;/li&gt;
  &lt;li&gt;만약 너가 model의 Python-only 동작을 변경하고 싶지만, 기존 model의 field를 유지하고 싶다면, Meta.proxy=True를 사용해라. 이는 data가 저장될 때 proxy model의 저장소 구조와 정확히 일치하도록 설정된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;multiple-inheritance&quot;&gt;Multiple inheritance&lt;/h2&gt;

&lt;p&gt;Python의 하위 class와 마찬가지로, Django model이 여러 개의 부모 model로부터 상속 받는 것이 가능하다. 일반적인 Python name resolution rule이 적용된다는 것을 명심해라. 특정 이름(e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt;)가 나타나는 첫 base class가 사용될 것이다. 예를 들어, 이것은 만약 여러 부모 class가 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class를 포함하고 있다면, 첫 번째 것이 사용될 것이며 다른 것들은 모두 무시될 것이다.&lt;/p&gt;

&lt;p&gt;일반적으로, 너는 다수의 부모로부터 상속 받을 필요가 없다. 일반적으로 유용하게 사용되는 경우는 “mix-in” class를 사용할 때이다: mix-in을 상속하고 있는 모든 class에 특정 추가적 field와 method를 추가하는 것이다. 너의 inheritance hierarchies를 가능한 간단하고 직관적으로 유지하여 특정 정보가 어디로부터 왔는지 헷갈리지 않게 해라.&lt;/p&gt;

&lt;p&gt;공통된 &lt;strong&gt;id&lt;/strong&gt; primary key field를 갖고 있는 다양한 model로부터 상속을 받는 것은 error를 일으킬 것이다. 올바르게 multiple inheritance를 사용하기 위해, 너는 base model에 명시적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoField&lt;/code&gt;&lt;/strong&gt;를 쓸 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Article(models.Model):
	article_id = models.AutoField(primary_key=True)
	...

class Book(models.Model):
	book_id = models.AutoField(primary_key=True)
	...

class BookReview(Book, Article):
	pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoField&lt;/code&gt;&lt;/strong&gt;를 갖고 있는 공통의 ancestor를 사용해라. 이는 각각의 부모 model에서 공통의 ancestor로의 OneToOneField를 명시적으로 사용하는 것을 요구하는데, 자동으로 생성되고 자식으로부터 상속받는 field들 간의 충돌을 피하기 위해서이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Piece(models.Model):
	pass

class Article(Piece):
	article_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)
	...

class Book(Piece):
	book_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)
	...

class BookReivew(Book, Article):
	pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;field-name-hiding-is-not-permitted&quot;&gt;Field name “hiding” is not permitted&lt;/h2&gt;

&lt;p&gt;보통의 Python inheritance에서, 자식 class는 부모 class로부터 어떠한 attribute를 override하는 것이 허용된다. Django에서 이것은 model fields에 대하여 주로 허락되지 않는다. 만약 non-abstract class가 &lt;strong&gt;author&lt;/strong&gt;이라 된 field를 갖고 있다면, 너는 그 base class로부터 상속 받은 다른 class에 &lt;strong&gt;author&lt;/strong&gt;이라 불리는 다른 model field나 attribute를 생성할 수 없다.&lt;/p&gt;

&lt;p&gt;이 제약은 abstract model로부터 상속 받은 model field에는 적용되지 않는다. 이러한 field들을 다른 field나 값으로 override 할 수 있고, &lt;strong&gt;field_nam = None&lt;/strong&gt;으로 설정하여 제거 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;model manager는 abstract base class로 부터 상속된다. 상속된 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;에 의해 참조되는 상속된 field를 override하는 것은 미묘한 bug를 일으킬 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;custom managers and model inheritance&lt;/code&gt;를 보아라.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;몇몇의 fields들은 model에 추가적인 attribute를 정의한다. 예를 들어 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;는 field 이름에 &lt;strong&gt;_id&lt;/strong&gt;가 추가된 별도의 attribute를 정의할 뿐만 아니라 &lt;strong&gt;related_name&lt;/strong&gt; 과 &lt;strong&gt;relate_query_name&lt;/strong&gt; 을 foreign model에 정의한다.&lt;/p&gt;

    &lt;p&gt;이런 추가적인 attributes들은 그것을 정의한 field가 바뀌거나 제거되어 더 이상 추가적인 attribute를 정의하지 않는 이상 override할 수 없다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;부모 model의 field를 override하는 것은 (&lt;strong&gt;Model.__init__&lt;/strong&gt;에서 어떤 field가 initialized 될지를 명시하는) 새로운 instance를 initializing 하는 것과 serialization과 같은 영역에 어려움이 있다. 이것들은 Python class inheritance가 똑같은 방식으로 처리 할 필요가 없는 기능이므로, Django model inheritance와 Python class inheritance는 임의적이지 않다.&lt;/p&gt;

&lt;p&gt;이런 제약은 단지 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;&lt;/strong&gt; instances인 attribute에만 적용된다. 보통의 Python attribute는 너가 원한다면 Override할 수 있다. 또한 이것은 Python 이 인식하는 attribute 이름에만 적용된다: 만약 너가 직접 database column 이름을 설정한다면, 너는 mutli-table inheritance의 child와 ancestor model에 나타나는 같은 column name을 가질 수 있다(이들은 서로 다른 database table의 column들이다).&lt;/p&gt;

&lt;p&gt;Django는 만약 너가 ancestor model에 있는 어떠한 model field를 override하면 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FieldError&lt;/code&gt;&lt;/strong&gt;를 일으킬 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;organizing-models-in-a-package&quot;&gt;Organizing models in a package&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py startapp&lt;/code&gt;&lt;/strong&gt; command는 &lt;strong&gt;models.py&lt;/strong&gt; 파일을 갖고 있는 application 구조를 생성한다. 만약 너가 많은 models을 갖고 있다면, 그들을 다른 파일에 구성하는 것이 효과적일 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 하기 위해서는 &lt;strong&gt;models&lt;/strong&gt; package를 만들어라. &lt;strong&gt;models.py&lt;/strong&gt;를 삭제하고 &lt;strong&gt;myapp/models/&lt;/strong&gt; directory를 &lt;strong&gt;__init__.py&lt;/strong&gt; 파일과 너의 models를 저장할 파일들과 함께 만들어라. 너는 model들을 &lt;strong&gt;__init__.py&lt;/strong&gt; 파일에 import 해야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 만약 너가 models directory에 &lt;strong&gt;organic.py&lt;/strong&gt;와 &lt;strong&gt;synthetic.py&lt;/strong&gt;를 갖고 있다면 다음과 같다:&lt;/p&gt;

&lt;p&gt;myapp/models/&lt;strong&gt;init&lt;/strong&gt;.py&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from .organic import Person
from .synthetic import Robot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;from .models import *를 사용하는 것보다 명시적으로 각각의 model을 import하는 것이 namespace를 어질러놓지 않을 수 있고, 코드를 더욱 읽기 쉽게 만들어주며, code analysis tools를 효과적으로 만들어준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;The Models Reference&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;model fields, related objects, 그리고 &lt;strong&gt;QuerySet&lt;/strong&gt;을 포함해서 모든 model 관련 API를 다루고 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 14 Jan 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/01/14/Models.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/14/Models.html</guid>
        
        
      </item>
    
  </channel>
</rss>
